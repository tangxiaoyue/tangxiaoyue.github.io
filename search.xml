<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Docker高级（1）--架构总览]]></title>
      <url>http://yoursite.com/2017/03/12/Docker%E9%AB%98%E7%BA%A7%EF%BC%881%EF%BC%89--%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>&#8194;&#8194;&#8194;&#8194;Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。<br><a id="more"></a></p>
<p>&#8194;&#8194;&#8194;&#8194;目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。<br>&#8194;&#8194;&#8194;&#8194;由于众多新颖的特性以及项目本身的开放性，Docker在不到两年的时间里迅速获得诸多厂商的青睐，其中更是包括Google、Microsoft、VMware等业界行业领导者。Google在今年六月份推出了Kubernetes，提供Docker容器的调度服务，而今年8月Microsoft宣布Azure上支持Kubernetes，随后传统虚拟化巨头VMware宣布与Docker强强合作。今年9月中旬，Docker更是获得4000万美元的C轮融资，以推动分布式应用方面的发展。<br>&#8194;&#8194;&#8194;&#8194;从目前的形势来看，Docker的前景一片大好。本系列文章从源码的角度出发，详细介绍Docker的架构、Docker的运行以及Docker的卓越特性。本文是Docker源码分析系列的第一篇­­­——Docker架构篇。</p>
<h3 id="Docker版本信息"><a href="#Docker版本信息" class="headerlink" title="Docker版本信息"></a>Docker版本信息</h3><p>&#8194;&#8194;&#8194;&#8194;本文关于Docker架构的分析都是基于Docker的源码与Docker相应版本的运行结果，其中Docker为最新的1.2版本。</p>
<h2 id="Docker架构分析内容安排"><a href="#Docker架构分析内容安排" class="headerlink" title="Docker架构分析内容安排"></a>Docker架构分析内容安排</h2><p>&#8194;&#8194;&#8194;&#8194;本文的目的是：在理解Docker源代码的基础上，分析Docker架构。分析过程中主要按照以下三个步骤进行：<br>  ● Docker的总架构图展示<br>  ● Docker架构图内部各模块功能与实现分析<br>  ● 以Docker命令的执行为例，进行Docker运行流程阐述</p>
<h2 id="Docker总架构图"><a href="#Docker总架构图" class="headerlink" title="Docker总架构图"></a>Docker总架构图</h2><p>&#8194;&#8194;&#8194;&#8194;学习Docker的源码并不是一个枯燥的过程，反而可以从中理解Docker架构的设计原理。Docker对使用者来讲是一个C/S模式的架构，而Docker的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑Docker的运行。<br>在此，先附上Docker总架构，如图3.1。<br><img src="http://static.zybuluo.com/BruceTang/fwvm0m4xch6xlf4zxi0u1eht/3.1.jpeg" alt="3.1.jpeg-238.3kB"><br>&#8194;&#8194;&#8194;&#8194;如图3.1，不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。<br>&#8194;&#8194;&#8194;&#8194;而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。<br>&#8194;&#8194;&#8194;&#8194;Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。<br>&#8194;&#8194;&#8194;&#8194;而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。<br>&#8194;&#8194;&#8194;&#8194;当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p>
<h2 id="Docker架构内各模块的功能与实现分析"><a href="#Docker架构内各模块的功能与实现分析" class="headerlink" title="Docker架构内各模块的功能与实现分析"></a>Docker架构内各模块的功能与实现分析</h2><p>&#8194;&#8194;&#8194;&#8194;接下来，我们将从Docker总架构图入手，抽离出架构内各个模块，并对各个模块进行更为细化的架构分析与功能阐述。主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。</p>
<h3 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h3><p>&#8194;&#8194;&#8194;&#8194;Docker Client是Docker架构中用户用来和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。<br>&#8194;&#8194;&#8194;&#8194;Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。为了简单起见，本文一律使用第一种方式作为讲述两者通信的原型。与此同时，与Docker &#8194;&#8194;&#8194;&#8194;Daemon建立连接并传输请求的时候，Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。<br>&#8194;&#8194;&#8194;&#8194;Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。</p>
<h3 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h3><p>&#8194;&#8194;&#8194;&#8194;Docker Daemon是Docker架构中一个常驻在后台的系统进程，功能是：接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker &#8194;&#8194;&#8194;&#8194;Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。<br>&#8194;&#8194;&#8194;&#8194;Docker Daemon启动所使用的可执行文件也为docker，与Docker Client启动所使用的可执行文件docker相同。在docker命令执行时，通过传入的参数来判别Docker Daemon与Docker Client。<br>&#8194;&#8194;&#8194;&#8194;Docker Daemon的架构，大致可以分为以下三部分：Docker Server、Engine和Job。Daemon架构如图4.1。<br>  &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.1 Docker Daemon架构示意图<br>  <img src="http://static.zybuluo.com/BruceTang/jzln1v9ufcecae7y9giqqvbj/4.1.jpeg" alt="4.1.jpeg-173.9kB"></p>
<h3 id="Docker-Server"><a href="#Docker-Server" class="headerlink" title="Docker Server"></a>Docker Server</h3><p> &#8194;&#8194;&#8194;&#8194; Docker Server在Docker架构中是专门服务于Docker Client的server。该server的功能是：接受并调度分发Docker Client发送的请求。Docker Server的架构如图4.2。<br> &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.2 Docker Server架构示意图<br> <img src="http://static.zybuluo.com/BruceTang/epr8qkhqg5gwn6ctk70lur7d/4.2.jpeg" alt="4.2.jpeg-157.5kB"></p>
<p> &#8194;&#8194;&#8194;&#8194;在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。<br>&#8194;&#8194;&#8194;&#8194;若Docker Client通过HTTP的形式访问Docker &#8194;&#8194;&#8194;&#8194;Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。<br>&#8194;&#8194;&#8194;&#8194;在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。<br>&#8194;&#8194;&#8194;&#8194;需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</p>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>&#8194;&#8194;&#8194;&#8194;Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。<br>&#8194;&#8194;&#8194;&#8194;在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>&#8194;&#8194;&#8194;&#8194;一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。<br>&#8194;&#8194;&#8194;&#8194;Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等</p>
<h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>&#8194;&#8194;&#8194;&#8194;Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。<br>&#8194;&#8194;&#8194;&#8194;在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。<br>&#8194;&#8194;&#8194;&#8194;其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成</p>
<h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p>&#8194;&#8194;&#8194;&#8194;Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如图4.3。<br>&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;图4.3 Graph架构示意图<br><img src="http://static.zybuluo.com/BruceTang/f2c2esg9j8i2y21kdth25zmm/4.3.jpeg" alt="4.3.jpeg-217.7kB"><br>&#8194;&#8194;&#8194;&#8194;其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。<br>&#8194;&#8194;&#8194;&#8194;同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs</p>
<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p>&#8194;&#8194;&#8194;&#8194;Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。<br>&#8194;&#8194;&#8194;&#8194;因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。<br>&#8194;&#8194;&#8194;&#8194;在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。<br>&#8194;&#8194;&#8194;&#8194;graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。<br>&#8194;&#8194;&#8194;&#8194;在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。<br>graphdriver的架构如图4.4：<br><img src="http://static.zybuluo.com/BruceTang/u6ldju10lxgsc2ieh08wjuj7/4.4.jpeg" alt="4.4.jpeg-144kB"></p>
<p>&#8194;&#8194;&#8194;&#8194;networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如图4.5：</p>
<p>&#8194;&#8194;&#8194;&#8194;execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如图4.6：<br><img src="http://static.zybuluo.com/BruceTang/x701lqh7cz8idszumchpftk7/4.6.jpeg" alt="4.6.jpeg-95.8kB"></p>
<h3 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h3><p>&#8194;&#8194;&#8194;&#8194;libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。<br>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如图4.7<br><img src="http://static.zybuluo.com/BruceTang/yewf5xufgahy74p9gkiot5bu/4.7.jpeg" alt="4.7.jpeg-128.9kB"></p>
<p>&#8194;&#8194;&#8194;&#8194;另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。<br>&#8194;&#8194;&#8194;&#8194;暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</p>
<h3 id="Docker-container"><a href="#Docker-container" class="headerlink" title="Docker container"></a>Docker container</h3><p>&#8194;&#8194;&#8194;&#8194;Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。<br>Docker按照用户的需求与指令，订制相应的Docker容器：<br>  ● 用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；<br>  ● 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；<br>  ● 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；<br>  ● 用户通过指定运行的命令，使得Docker容器执行指定的工作。<br>Docker容器示意图如图4.8：</p>
<p><img src="http://static.zybuluo.com/BruceTang/l0st9jymm96ifjkilt2xvk3c/4.8.jpeg" alt="4.8.jpeg-172.2kB"></p>
<h2 id="Docker运行案例分析"><a href="#Docker运行案例分析" class="headerlink" title="Docker运行案例分析"></a>Docker运行案例分析</h2><p>上一章节着重于Docker架构中各个部分的介绍。本章的内容，将以串联Docker各模块来简要分析，分析原型为Docker中的docker pull与docker run两个命令。</p>
<h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>&#8194;&#8194;&#8194;&amp;#8194docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。docker pull命令执行流程如图5.1。<br><img src="http://static.zybuluo.com/BruceTang/je37t67jpqe4d8wi7e0quo86/5.1.jpeg" alt="5.1.jpeg-453.6kB"></p>
<p>如图，图中标记的红色箭头表示docker pull命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。<br>(1) Docker Client接受docker pull命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/images/create? “+”xxx”；<br>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；<br>(3) mux.Router将请求路由分发至相应的handler，具体为PostImagesCreate；<br>(4) 在PostImageCreate这个handler之中，一个名为”pull”的job被创建，并开始执行；<br>(5) 名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；<br>(6) 名为”pull”的job将下载的image交给graphdriver；<br>(7) graphdriver负责将image进行存储，一方创建graph对象，另一方面在GraphDB中记录image之间的关系。</p>
<h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>&#8194;&#8194;&#8194;docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client给Docker Server发送了两次HTTP请求，第二次请求的发起取决于第一次请求的返回状态。Docker run命令执行流程如图5.2。<br><img src="http://static.zybuluo.com/BruceTang/81m0w55hy9f79tmo0d2f6fyb/5.2.jpeg" alt="5.2.jpeg-670.6kB"><br>如图，图中标记的红色箭头表示docker run命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。<br>(1) Docker Client接受docker run命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/containers/create? “+”xxx”；<br>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；<br>(3) mux.Router将请求路由分发至相应的handler，具体为PostContainersCreate；<br>(4) 在PostImageCreate这个handler之中，一个名为”create”的job被创建，并开始让该job运行；<br>(5) 名为”create”的job在运行过程中，执行Container.Create操作，该操作需要获取容器镜像来为Docker容器创建rootfs，即调用graphdriver；<br>(6) graphdriver从Graph中获取创建Docker容器rootfs所需要的所有的镜像；<br>(7) graphdriver将rootfs所有镜像，加载安装至Docker容器指定的文件目录下；<br>(8) 若以上操作全部正常执行，没有返回错误或异常，则Docker Client收到Docker Server返回状态之后，发起第二次HTTP请求。请求方法为”POST”，请求URL为”/containers/“+container_ID+”/start”；<br>(9) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；<br>(10)mux.Router将请求路由分发至相应的handler，具体为PostContainersStart；<br>(11)在PostContainersStart这个handler之中，名为”start”的job被创建，并开始执行；<br>(12)名为”start”的job执行完初步的配置工作后，开始配置与创建网络环境，调用networkdriver；<br>(13)networkdriver需要为指定的Docker容器创建网络接口设备，并为其分配IP，port，以及设置防火墙规则，相应的操作转交至libcontainer中的netlink包来完成；<br>(14)netlink完成Docker容器的网络环境配置与创建；<br>(15)返回至名为”start”的job，执行完一些辅助性操作后，job开始执行用户指令，调用execdriver；<br>(16)execdriver被调用，初始化Docker容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至libcontainer来完成；<br>(17)libcontainer被调用，完成Docker容器内部的运行环境初始化，并最终执行用户要求启动的命令。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从Docker 1.2的源码入手，分析抽象出Docker的架构图，并对该架构图中的各个模块进行功能与实现的分析，最后通过两个docker命令展示了Docker内部的运行。<br>通过对Docker架构的学习，可以全面深化对Docker设计、功能与价值的理解。同时在借助Docker实现用户定制的分布式系统时，也能更好地找到已有平台与Docker较为理想的契合点。另外，熟悉Docker现有架构以及设计思想，也能对云计算PaaS领域带来更多的启发，催生出更多实践与创新。</p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（9）--Dockerfile]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89--Dockerfile/</url>
      <content type="html"><![CDATA[<h2 id="使用Dockerfile构建nginx"><a href="#使用Dockerfile构建nginx" class="headerlink" title="使用Dockerfile构建nginx"></a>使用Dockerfile构建nginx</h2><pre><code>Dockerfile是由一行命令和语句组成的



Dockerfile构建步骤：

[root@tang /]# mkdir /dockerfile/nginx -p
我们要在nginx目录上自动化创建一个nginx镜像
</code></pre><a id="more"></a>
<pre><code>注意：D需要大写，当我们构建dockerfile的时候，docker默认会在我们当前目录读取一个名为Dockerfile的文件。这时候的D必须大写

[root@tang nginx]# cat Dockerfile 
# This Dockerfile
# My Name is TangXiaoyue
# Base image
FROM centos

# Maintainer
MAINTAINE tang 1060336375@qq.com

#Commands
RUN rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
RUN yum install -y nginx &amp;&amp; yum clean all
RUN echo &quot;daemon off;&quot; &gt;&gt;/etc/nginx/nginx.conf
ADD index.html /usr/share/nginx/html/index.html
EXPOSE 80
CMD [&quot;nginx&quot;]


#井号代表注释
#Base image  除了注释的第一行，必须是FROM，意思就是我们需要告诉dockerfile基础镜像是什么
#Maintainer 维护信息

#Commands 命令

#ADD index.html 这个文件需要我们在当前目录下有才可以，我们配置我们可以准备好，然后使用ADD命令进行添加或修改
EXPOSE 对外端口号
CMD [“nginx”] 它要启动的命令是nginx （就算是nginx服务）




我们写好dockerfile还需要一个index.html
[root@tang nginx]#  echo TangXiaoyue &gt;index.html
[root@tang nginx]# ll
total 8
-rw-r--r-- 1 root root 364 Apr  2 20:50 Dockerfile
-rw-r--r-- 1 root root  12 Apr  2 20:52 index.html

使用docker build进行构建
[root@tang ~]# docker build -t nginx_test:v1 /dockerfile/nginx/
[root@tang ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
nginx_test           v1                  bc69ee414a0f        17 seconds ago      280.7 MB


启动镜像
[root@tang ~]# docker run --name nginx_test -d -p 82:80 nginx_test:v1
7a02c27a0a04d34eec8f858e35848416b95572dbb1f485310caee5c185d2e426

[root@tang ~]# curl 127.0.0.1:82
TangXiaoyue
</code></pre><h2 id="Dockerfile参数解释"><a href="#Dockerfile参数解释" class="headerlink" title="Dockerfile参数解释"></a>Dockerfile参数解释</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><pre><code>格式：FROM&lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;。

解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。
然后后面的其它指令FROM的镜像中执行。
</code></pre><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><pre><code>格式：MAINTAINER &lt;name&gt;

    解释：指定维护者信息。
</code></pre><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><pre><code>格式：RUN &lt;command&gt;或 RUN[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。

    解释：运行命令，命令较长使可以使用\来换行。推荐使用上面数组的格式
</code></pre><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><pre><code>格式：
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；
CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT的默认参数；

解释： 
CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。
如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。
</code></pre><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><pre><code>格式：
   ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;]
   ENTRYPOINT command param1 param2（shell中执行）。

解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 

每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。
ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。 
　
所以生产实践中我们可以同时使用ENTRYPOINT和CMD， 

例如：
    ENTRYPOINT [&quot;/usr/bin/rethinkdb&quot;]
    CMD [&quot;--help&quot;]
</code></pre><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><pre><code>格式：USER daemon

    解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。
</code></pre><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><pre><code>格式：EXPOSE&lt;port&gt; [&lt;port&gt;...]

解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。
</code></pre><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><pre><code>格式：ENV&lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...

    解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定
</code></pre><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><pre><code>格式：
   ADD &lt;src&gt;... &lt;dest&gt;
   ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]

    解释：
        将指定的&lt;src&gt;复制到容器文件系统中的&lt;dest&gt; 
           所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0 
        如果文件是可识别的压缩格式，则docker会帮忙解压缩
</code></pre><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><pre><code>格式：VOLUME [&quot;/data&quot;]

    解释：可以将本地文件夹或者其他container的文件夹挂载到container中。
</code></pre><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><pre><code>格式：WORKDIR/path/to/workdir

    解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。 
    可以多次切换(相当于cd命令)， 
    也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:

    WORKDIR /a
    WORKDIR b
    WORKDIR c
    RUN pwd
    则最终路径为 /a/b/c。
</code></pre><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><pre><code>ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行
</code></pre><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><pre><code>格式：ARG&lt;name&gt;[=&lt;default value&gt;]

    解释：ARG指定了一个变量在docker build的时候使用，
         可以使用--build-arg &lt;varname&gt;=&lt;value&gt;来指定参数的值，不过如果构建的时候不指定就会报错。
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（6）--仓库管理]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89--%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Docker的仓库是DockerHub，类似于github，github有一个开源的软件叫gitlab。Docker也有一个开源软件docker registry</p>
</blockquote>
<a id="more"></a>
<pre><code>[root@tang ~]# docker pull registry

[root@tang ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
docker.io/centos     latest              98d35105a391        2 weeks ago         192.5 MB
docker.io/registry   latest              047218491f8c        4 weeks ago         33.17 MB

默认占用5000端口，我们查看是否存在5000端口
[root@tang ~]# netstat -lntup | grep 5000

运行容器
[root@tang ~]# docker run -d -p 5000:5000 registry
f002089ab95474290853a2a24b86cb0adbb5848c4a468175304b59b27d6e3b0e

提示：docker比较老的版本运行起来就可以运行，1.7之后都不可以
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（8）--网络管理]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89--%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="Docker四种网络模式"><a href="#Docker四种网络模式" class="headerlink" title="Docker四种网络模式"></a>Docker四种网络模式</h3><h4 id="第一种网络模式host"><a href="#第一种网络模式host" class="headerlink" title="第一种网络模式host"></a>第一种网络模式host</h4><pre><code>host模式: 使用--net=host指定docker使用的网络实际上和宿主机一样,在容器内看到的网卡ip是宿主机上的ip.
</code></pre><a id="more"></a>
<pre><code>[root@docker ~]# docker run -itd -h node1 --name node1 --net=host centos bash
406cdb306f3c350b6f5344048ae25426f1df3f6863162c0b3a91e3dcd48eba
[root@docker ~]# ifconfig |awk -F &apos; &apos;  &apos;NR==10{print$2}&apos;
172.17.82.185
[root@docker ~]# docker-enter node1    #进去之后修改主机名，因为主机名个宿主机一样，貌似-h也指定不了主机名
[root@node1 ~]# yum install -y net-tools
[root@node1 ~]# ifconfig |awk -F &apos; &apos;  &apos;NR==10{print$2}&apos;
172.17.82.185
</code></pre><h4 id="第二种网络模式container"><a href="#第二种网络模式container" class="headerlink" title="第二种网络模式container"></a>第二种网络模式container</h4><pre><code>container模式: 使用--net=container:container_id/container_name多个容器使用共同的网络,看到的ip是一样的.


[root@docker ~]# docker run -itd -h node2 --name node2  --net=container:node1 centos bash     #此处不能指定主机名创建，否则失败
/usr/bin/docker-current: Error response from daemon: Conflicting options: hostname and the network mode.
See &apos;/usr/bin/docker-current run --help&apos;
[root@docker ~]# docker run -itd  --name node2 --net=container:node1 centos bash
0fc16c4a055cf0035c1241ba6cce6c5ad0c711f2ef13e0589c3254f19a96b271
[root@docker ~]# docker-enter node2
[root@node2 ~]# yum install -y net-tools
[root@node2 ~]# ifconfig |awk -F &apos; &apos;  &apos;NR==10{print$2}&apos;    #和node1的ip一样，也和宿主机的ip一样（node1使用的是--net=host模式）
172.17.82.185
</code></pre><h4 id="第三种网络模式none"><a href="#第三种网络模式none" class="headerlink" title="第三种网络模式none"></a>第三种网络模式none</h4><pre><code>none模式: 使用--net=none, 这种模式下,不会配置任何网络

[root@docker ~]# docker run -itd -h node3 --name node3 --net=none centos
c1f4bd859566f11517248718a94456066d16ad66748a2c78743881e450d4ca09
[root@docker ~]# docker-enter node3
[root@node3 ~]# ping www.baidu.com
ping: www.baidu.com: Name or service not known
</code></pre><h4 id="第四种网络模式bridge"><a href="#第四种网络模式bridge" class="headerlink" title="第四种网络模式bridge"></a>第四种网络模式bridge</h4><pre><code>bridge模式: 使用--net=bridge.创建完容器默认为这种网络模式.类似与vmware的nat网络模式.

[root@docker ~]# docker run -itd -h node4 --name node4 --net=bridge centos bash
fc4f817e741f22615d0cdbab6608877d268ea15be6ba790cae5706d03871ac41
</code></pre><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><pre><code>[root@docker ~]# docker run -itd -h node1 --name node1 centos bash
27df97f0e77e745660ee7b9c8b318c64f63e6aa632db3d3b0c44c4e0f4006124
[root@docker ~]# docker-enter node1
[root@node1 ~]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
[root@node1 ~]# yum install -y nginx
[root@docker ~]# docker commit -m &quot;nginx&quot; -a &quot;tang&quot; 27df97f0e77e nginx:v1
    #此处仅容器做为镜像，主要是减少以后重复性的工作，不需要新建一个容器在部署nginx

[root@docker ~]# docker run -itd -h nginx --name nginx -p 81:80 nginx:v1 bash      #-p 端口映射，射到宿主机81端口上
a5dd375e829d05734a935d5f41723841568b543822a64a4ec277480f5f552e41
[root@docker ~]# docker-enter nginx
Last login: Mon Apr  3 07:00:51 UTC 2017
[root@nginx ~]# /usr/sbin/nginx 
[root@nginx ~]# echo &quot;TangXiaoyue&quot; &gt; /usr/share/nginx/html/1.html
[root@nginx ~]# curl 127.0.0.1/1.html
TangXiaoyue
[root@nginx ~]# exit
logout
[root@docker ~]#  curl 127.0.0.1:81/1.html
TangXiaoyue
</code></pre><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><pre><code>1.安装mysql
[root@docker ~]# docker run --privileged -itd -h node1 --name node1 centos /sbin/init
fd547b535ff3af19bf36b219f542864962d60480a8d56836db30c20f079ec43f
[root@docker ~]# docker-enter node1
[root@node1 ~]# yum install -y wget
[root@node1 ~]# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
[root@node1 ~]# rpm -ivh mysql-community-release-el7-5.noarch.rpm
[root@node1 ~]# yum install mysql-community-server
[root@node1 ~]# systemctl start mysql.service
[root@node1 ~]# mysql -uroot
&gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;);

2.制作mysql镜像
[root@docker ~]# docker commit -m &quot;mysql&quot; -a &quot;tang&quot; fd547b535ff3 mysql:v1
sha256:21af416e70b0302163e4aa279118afdd96a0c8590487268a3d26920caf6c5d1a
[root@docker ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
mysql                v1                  21af416e70b0        4 seconds ago       797.3 MB


[root@docker ~]# docker run --privileged -itd -h mysql --name mysql mysql:v1 /sbin/init
8d71a34516a2c05a7ea63fde5773785360d1301509d687797eec5ead62a01d55


3.以mysql、nginx镜像分别创建两个容器并端口映射
[root@docker ~]# docker run -itd -h nginx --name nginx -p 10080:80 --link mysql:db nginx:v1 bash
8aea6116f67c9760b8f4d3de08251b28af839b9e2195860ad4b24d54833c286a
[root@docker ~]# docker-enter nginx
Last login: Mon Apr  3 07:00:51 UTC 2017
[root@nginx ~]# yum install -y telnet
[root@nginx ~]# telnet db 3306
Trying 172.18.0.3...
Connected to db.
Escape character is &apos;^]&apos;.
CHost &apos;172.18.0.4&apos; is not allowed to connect to this MySQL serverConnection closed by foreign host.
[root@nginx ~]# cat /etc/hosts
172.18.0.3    db mysql mysql
172.18.0.4    nginx
</code></pre><h3 id="配置网桥-centos7"><a href="#配置网桥-centos7" class="headerlink" title="配置网桥(centos7)"></a>配置网桥(centos7)</h3>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（7）--数据管理]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89--%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="挂载本地目录到容器里"><a href="#挂载本地目录到容器里" class="headerlink" title="挂载本地目录到容器里"></a>挂载本地目录到容器里</h4><pre><code>[root@tang /]# mkdir /data/docker -p
root@tang docker]# mkdir docker_01
[root@tang docker]# docker run -it -h docker_01 --name docker_01 -v /data/docker/docker_01/:/docker_01 centos bash
[root@docker_01 /]# cd /docker_01/        
[root@docker_01 docker_01]# touch docker_01.txt
</code></pre><a id="more"></a>
<pre><code>[root@docker_01 docker_01]# exit
exit
[root@tang docker]# cd /data/docker/docker_01/
[root@tang docker_01]# ll
total 0
-rw-r--r-- 1 root root 0 Apr  3 08:03 docker_01.txt

[root@tang docker_01]# cd ..
[root@tang docker]# mkdir docker_02
[root@tang docker]# docker run -it -h docker_02 --name docker_02 -v /data/docker/docker_02/:/docker_02 centos bash
[root@docker_02 /]# cd /docker_02/
[root@docker_02 docker_02]# mkdir docker_02.txt
[root@docker_02 docker_02]# exit
exit
[root@tang docker]# cd docker_02/
[root@tang docker_02]# ll
total 4
drwxr-xr-x 2 root root 4096 Apr  3 08:05 docker_02.txt

提示：    
      -v: 指定挂载目录
      : : 前面的为本地目录
      : : 后面到为容器里的目录
      即使将删除这个容器,文件也不会丢失.
</code></pre><h4 id="挂载数据卷-多个容器挂载宿主机的同一个目录"><a href="#挂载数据卷-多个容器挂载宿主机的同一个目录" class="headerlink" title="挂载数据卷(多个容器挂载宿主机的同一个目录)"></a>挂载数据卷(多个容器挂载宿主机的同一个目录)</h4><pre><code>[root@tang data]# docker run -it -h docker_03 --name docker_03
--volumes-from docker_01 centos bash
[root@docker_03 /]# cd /docker_01/
[root@docker_03 docker_01]# ll
total 0
-rw-r--r-- 1 root root 0 Apr  3 00:03 docker_01.txt
[root@docker_03 docker_01]# df -h|grep docker_01
/dev/vda1                           99G  5.4G   88G   6% /docker_01
[root@docker_03 docker_01]# echo &quot;This is Doceker_3&quot; &gt; /docker_01/3.txt
[root@docker_03 docker_01]# ll
total 4
-rw-r--r-- 1 root root 18 Apr  3 00:26 3.txt
-rw-r--r-- 1 root root  0 Apr  3 00:03 docker_01.txt
[root@tang ~]# docker start docker_01
docker_01
[root@tang ~]# docker-enter docker_01
[root@docker_01 ~]# cd /docker_01/
[root@docker_01 docker_01]# ll
total 4
-rw-r--r-- 1 root root 18 Apr  3 00:26 3.txt
-rw-r--r-- 1 root root  0 Apr  3 00:03 docker_01.txt
</code></pre><h4 id="自定义数据卷容器"><a href="#自定义数据卷容器" class="headerlink" title="自定义数据卷容器"></a>自定义数据卷容器</h4><pre><code>[root@tang ~]# docker run -itd -h node --name node -v /data centos bash
056ac10e28855c3d29a94fe552711e6a712a5670e6e9c43c4b79270cbc6b0a0f
                #这里的/data是容器node的/data目录,而不是宿主机的/data目录

[root@tang ~]# docker-enter node
[root@node ~]#  touch /data/1 /data/2 /data/3
[root@node ~]# cd /data/
[root@node data]# ll
total 0
-rw-r--r-- 1 root root 0 Apr  3 01:00 1
-rw-r--r-- 1 root root 0 Apr  3 01:00 2
-rw-r--r-- 1 root root 0 Apr  3 01:00 3
[root@node data]# exit
logout
[root@tang ~]# docker run -itd -h node1 --name node1 --volumes-from node centos bash
2965a8f1184a7a1cbd26ef07e4b3d201fa17e5b68a52c619d6292da75c85d117
[root@tang ~]# docker-enter node1
[root@node1 ~]# cd /data/
[root@node1 data]# ll
total 0
-rw-r--r-- 1 root root 0 Apr  3 01:00 1
-rw-r--r-- 1 root root 0 Apr  3 01:00 2
-rw-r--r-- 1 root root 0 Apr  3 01:00 3
[root@node1 data]# touch 4
[root@node data]# ll
total 0
-rw-r--r-- 1 root root 0 Apr  3 01:00 1
-rw-r--r-- 1 root root 0 Apr  3 01:00 2
-rw-r--r-- 1 root root 0 Apr  3 01:00 3
-rw-r--r-- 1 root root 0 Apr  3 01:02 4
</code></pre><h4 id="数据卷的备份"><a href="#数据卷的备份" class="headerlink" title="数据卷的备份"></a>数据卷的备份</h4><pre><code>[root@docker ~]# mkdir /docker_data_backup
[root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash
250da7a47222e52c5a5d387ff8ce816a72b221ffb8d481739c4c68073507fe
[root@docker ~]# docker-enter tang
[root@tang ~]# mkdir /data
[root@tang ~]# touch /data/{1,2,3,4}
[root@tang ~]# tar cvf /backup/data.tar /data/
[root@tang ~]# cd /backup/
[root@tang backup]# ll
total 12
-rw-r--r-- 1 root root 10240 Apr  3 01:30 data.tar
[root@tang backup]# exit
logout
[root@docker ~]# cd /docker_data_backup/
[root@docker docker_data_backup]# ll
total 12
-rw-r--r-- 1 root root 10240 Apr  3 09:30 data.tar
</code></pre><h4 id="数据卷的恢复"><a href="#数据卷的恢复" class="headerlink" title="数据卷的恢复"></a>数据卷的恢复</h4><pre><code>[root@docker ~]# mkdir /docker_data_backup
[root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash
3728f6b0a6e5b47f904de0474db7d4479f33e87740906e1539eca385c3fab04d
[root@docker ~]# docker-enter tang
[root@tang ~]# mkdir /tools/
[root@tang ~]# touch /tools/{1,2,3,4}
[root@tang ~]# tar zcvf /backup/tools.tar /tools/
/tools/
/tools/1
/tools/2
/tools/3
/tools/4
[root@tang ~]# ll /backup/
total 4
-rw-r--r-- 1 root root 162 Apr  3 02:08 tools.tar
[root@tang ~]# exit
logout

[root@docker ~]# docker run -itd -h tang1 --name tang1 -v /tang1 centos bash
7ec371bb67f136234878771c227c4245a0ccf6c986e8c94a412d6c4111852a2b
[root@docker ~]# docker run -itd -h tang2 --name tang2 --volumes-from tang1 -v /docker_data_backup/:/backup centos bash
53e4cea1c45f3c081a6dd95b935f906aa037e6ed2170b6249a913ccd6fb4c119
[root@docker ~]# docker-enter tang2
[root@tang2 ~]# ll /backup/
total 4
-rw-r--r-- 1 root root 162 Apr  3 02:08 tools.tar
[root@tang2 tang1]# tar xvf /backup/tools.tar -C /tang1
[root@tang2 tang1]# exit
logout
[root@docker ~]# docker-enter tang1
[root@tang1 ~]# cd /tang1/
[root@tang1 tang1]# ll
total 4
drwxr-xr-x 2 root root 4096 Apr  3 02:07 tools
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker问题梳理--持续更新]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="关于systemctl无法启动服务的问题处理"><a href="#关于systemctl无法启动服务的问题处理" class="headerlink" title="关于systemctl无法启动服务的问题处理"></a>关于systemctl无法启动服务的问题处理</h3><pre><code>问题：

使用systemctl启动服务的时候出现以下异常：

Failed to get D-Bus connection: Operation not permitted 


解决：

docker run --privileged -itd -h node1 --name node1 centos /sbin/init
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（2）--命令]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89--%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h3><pre><code>yum install -y docker                                    #下载
systemctl start docker                                    #启动
systemctl enable docker                                    #自启动
</code></pre><a id="more"></a>
<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><pre><code>docker search  images                                    #搜索镜像
docker pull images                                    #下载镜像
docker    images                                    #查看镜像
docker tag centos6  centos6_x86                                    #镜像改名
docker save image&gt;/opt/images.tar.gz                                    #导出镜像
docker load&lt;/opt/images.tar.gz                                    #导入镜像
docker load --input /opt/images.tar.gz                                            #导入镜像
docker rmi images_id                                                            #删除镜像
docker rmi $(docker images -q)                                                    #删除所有镜像
</code></pre><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><pre><code>docker ps -a                                                                    #查看容器
docker run centos /bin/echo &quot;hehe&quot;                                                #首次创建一个容器
docekr run -h tang --name tang -t -i centos /bin/bah                            #创建一个以tang为名的容器；
                                                                                    --name：指定容器名    
                                                                                    -t：分配一个tty终端    
                                                                                    -i：容器的标准输出保持打开状态 
                                                                                    -h:指定主机名
docker create -it --name centos1 centos                                            #使用create创建容器
docekr stop ID（name）                                                            #停止容器
docker start ID（name）                                                            #启动容器
docker attach ID（name）                                                            #进入容器
docker exec -it ID(name)  /bin/bash
docker rm  ID（name）                                                            #删除容器    
                                                                                    -f：强制删除容器，包括在运行的
                                                                                #exec和attach总结: 
                                                                                    attach登陆容器后,退出时容器会关闭. 
                                                                                    推荐使用exec进入容器
docker rm $(docker ps -a -q)                                                    #删除所有容器
</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><pre><code>docker run --name nginx -d -P nginx                                                #随机映射 
docker run --name nginx -d -p 81:80 nginx                                         #指定映射
docker run -it --name nginx -p 80:80 nginx /bin/bash                            #指定映射
</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code>docker logs ID（name）                                                            #查看日志
</code></pre><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><pre><code>docker run -it --name tang -v /data centos                                         #默认挂载目录
docekr inspect ID(name)                                                            #查看容器信息
                                                                                    ==查看mounts模块
docekr run -it --name tang -v /data:/data centos                                   #指定挂载目录
docker run -it --name tang -v /data:/data:rw centos                                 #指定权限挂载
                                                                                    ==rw：读写
docker run -it --name tang -v /data:/data:ro centos                             #指定权限挂载
                                                                                ==ro：只读
docker run -it --name tang  ~/.bash_history:/.bash_history centos                #记录历史记录
</code></pre><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><pre><code>docker run -d --name nfs -v /data:/data centos                                     #启动nfs容器，挂在一个卷，
                                            -d：直接在后台执行
docker run -it --name test1 --volumes-from nfs centos                            #启动test1容器，挂载到nfs的数据卷容器上
docker run -it --name test2 --volumes-from nfs centos                             #启动test2容器，挂载到nfs的数据卷容器上
                                        #test1和test2的/data数据可以共享
</code></pre><h3 id="手动制作镜像"><a href="#手动制作镜像" class="headerlink" title="手动制作镜像"></a>手动制作镜像</h3><pre><code>docker run -it --name mynginx centos                                            #基础centos进行创建容器mynginx
</code></pre><h2 id="在mynginx容器内安装nginx"><a href="#在mynginx容器内安装nginx" class="headerlink" title="在mynginx容器内安装nginx"></a>在mynginx容器内安装nginx</h2><pre><code>rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
yum install -y nginx
docker commit -m &quot;my nginx&quot; f9c7dfb6f552 tang/mynginx:v1                        #提交镜像，
                                            ==同时打一个标签叫mynginx:v1
                                            ==tang相当于你向github上提交的用户名
docker run -it --anme nginxv1 tang/mynginx:v1                                    #基于镜像tang/mynginx:v1创建容器nginxv1
```
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（3）--容器登入]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%99%BB%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="docker-enter登入容器"><a href="#docker-enter登入容器" class="headerlink" title="docker-enter登入容器"></a>docker-enter登入容器</h3><blockquote>
<p>强烈推荐使用此种方法：简单、方便</p>
</blockquote>
<pre><code>下载.bashrc_docker，并将内容放到.bashrc中。

这个文件中定义了很多方便使用Docker的命令，比如docker-pid可以获取某个容器的 PID；
而 docker-enter 可以进入容器或直接在容器内执行命令
</code></pre><a id="more"></a>
<pre><code>[root@tang ~]# wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker

[root@tang ~]# echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc


[root@tang ~]# docker-
docker-containerd               docker-ctr-current              docker-pid
docker-containerd-current       docker-current                  docker-storage-setup
docker-containerd-shim          docker-enter                    
docker-containerd-shim-current  docker-ip 

[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         24 minutes ago      Up 23 minutes                           tang

[root@tang ~]# docker-pid tang
19271

[root@tang ~]# nsenter --target 19271  --mount --uts --ipc --net --pid  #此种方法进入容器以下会讲到
[root@test /]# exit
logout

[root@tang ~]# docker-ip tang
172.18.0.2

直接使用docker-enter命令进入容器，非常方便！
[root@tang ~]# docker-enter tang
Last login: Sun Apr  2 06:38:47 UTC 2017

[root@test ~]# exit
logout

[root@tang ~]# docker ps   #退出登陆窗口后，容器还在
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         26 minutes ago      Up 9 seconds                            tang

注意：以在容器的上下文中运行任意命令！即在宿主机上执行容器里的命令

[root@tang ~]# docker-enter tang uptime
 07:06:28 up 1 day, 22:44,  0 users,  load average: 0.00, 0.01, 0.05

注意：在宿主机上使用docker-enter命令执行容器中的命令时，最好后面加上--符号，这样容器里的所有存在的命令都可以正常执行。
[root@tang ~]# docker-enter tang -- uptime

 07:06:59 up 1 day, 22:45,  0 users,  load average: 0.00, 0.01, 0.05

[root@tang ~]# docker-enter tang -- df -h
Filesystem                                                                                         Size  Used Avail Use% Mounted on
/dev/mapper/docker-253:1-2024335-661487685eb1f6a356157463d60db20caa2c1fb3ac273de680c367e3b12dabab   10G  238M  9.8G   3% /
tmpfs                                                                                              920M     0  920M   0% /dev
tmpfs                                                                                              920M     0  920M   0% /sys/fs/cgroup
/dev/vda1                                                                                           99G  4.7G   89G   5% /etc/hosts
shm                                                                                                 64M     0   64M   0% /dev/shm

[root@tang ~]# cat /etc/redhat-release 
CentOS Linux release 7.2.1511 (Core) 

[root@tang ~]# docker-enter tang -- cat /etc/redhat-release 
CentOS Linux release 7.3.1611 (Core)
</code></pre><h3 id="nsenter登入容器"><a href="#nsenter登入容器" class="headerlink" title="nsenter登入容器"></a>nsenter登入容器</h3><pre><code>使用外部工具nsenter登陆容器，该工具和docker exec命令的效果差不多。

使用nsenter或dockerexec，都可以在容器的上下文（严格地说，是命名空间）中运行任意命令！


==nsenter安装：
[root@tang ~]#  yum install util-linux -y 


==nsenter使用：
[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         50 minutes ago      Up 24 minutes                           tang

[root@tang ~]# docker inspect -f &quot;{{ .State.Pid }}&quot; tang
19271

[root@tang ~]# nsenter -t 19271  -m -u -i -n -p

解释nsenter指令中进程id之后的参数的含义：

–mount参数是进去到mount namespace中 
–uts参数是进入到uts namespace中 
–ipc参数是进入到System V IPC namaspace中 
–net参数是进入到network namespace中 
–pid参数是进入到pid namespace中 
–user参数是进入到user namespace中

[root@tang ~]#  nsenter --help

Usage:
 nsenter [options] &lt;program&gt; [&lt;argument&gt;...]

Run a program with namespaces of other processes.

Options:
 -t, --target &lt;pid&gt;     target process to get namespaces from
 -m, --mount[=&lt;file&gt;]   enter mount namespace
 -u, --uts[=&lt;file&gt;]     enter UTS namespace (hostname etc)
 -i, --ipc[=&lt;file&gt;]     enter System V IPC namespace
 -n, --net[=&lt;file&gt;]     enter network namespace
 -p, --pid[=&lt;file&gt;]     enter pid namespace
 -U, --user[=&lt;file&gt;]    enter user namespace
 -S, --setuid &lt;uid&gt;     set uid in entered namespace
 -G, --setgid &lt;gid&gt;     set gid in entered namespace
     --preserve-credentials do not touch uids or gids
 -r, --root[=&lt;dir&gt;]     set the root directory
 -w, --wd[=&lt;dir&gt;]       set the working directory
 -F, --no-fork          do not fork before exec ing &lt;program&gt;
 -Z, --follow-context   set SELinux context according to --target PID
 -h, --help     display this help and exit
 -V, --version  output version information and exit

我们进入容器中查看进程 
以下是以nsenter启动的进程
[root@test /]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  11768  1684 ?        Ss+  07:03   0:00 /bin/bash
root        77  0.0  0.1  15200  1988 ?        S    07:31   0:00 -bash
root        90  0.0  0.0  50872  1816 ?        R+   07:31   0:00 ps aux

/bin/bash是我们运行容器产生的进程
-bash 是我们使用nsenter产生的，这样如果我们退出容器，容器就不会退出，因为-bash还在运行

[root@test /]# exit
logout

[root@tang ~]# docker ps 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         55 minutes ago      Up 29 minutes                           tang

因为每次进入容器都需要输入那两条命令，所以我们可以写一个脚本来获取。 

==脚本内容如下：
[root@tang opt]# cat docker_in.sh 
#!/bin/bash
# Use nsenter to access docker
docker_in(){
  NAME_ID=$1
  PID=$(docker inspect -f &quot;{{ .State.Pid }}&quot; $NAME_ID)
  nsenter -t $PID -m -u -i -n -p
}
docker_in $1

[root@tang opt]# chmod +x docker_in.sh 
[root@tang opt]# ./docker_in.sh tang
[root@test /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 07:03 ?        00:00:00 /bin/bash
root        91     0  0 07:34 ?        00:00:00 -bash
root       104    91  0 07:34 ?        00:00:00 ps -ef
[root@test /]# exit
logout
[root@tang opt]# docker exec tang ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 07:03 ?        00:00:00 /bin/bash
root       105     0  0 07:35 ?        00:00:00 ps -ef


我们还可以使用exec进入docker容器中

[root@tang opt]# docker exec -it tang /bin/bash
</code></pre><h3 id="start-ai登入容器"><a href="#start-ai登入容器" class="headerlink" title="start -ai登入容器"></a>start -ai登入容器</h3><pre><code>对于一个已关闭的容器的登陆，可以使用&quot;docker start -ai container&quot;登陆。这种其实就是先启动容器，然后再进入容器内。

[root@tang ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         About an hour ago   Exited (0) 53 seconds ago                       tang

[root@tang ~]# docker start -ai tang   #-a -i 都可以
[root@test /]# exit
exit
[root@tang ~]# docker start -i tang
[root@tang ~]# docker start -a tang
</code></pre><h3 id="docker-exec登入容器"><a href="#docker-exec登入容器" class="headerlink" title="docker exec登入容器"></a>docker exec登入容器</h3><pre><code>使用自带命令docker exec登陆容器

命令格式：docker exec -ti container_id /bin/bash

[root@tang ~]# docker ps    #前提是容器已经启动
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         About an hour ago   Up 2 minutes                            tang
[root@tang ~]# docker exec -it tang /bin/bash
[root@test /]# exit
</code></pre><h3 id="docker-attach登入容器"><a href="#docker-attach登入容器" class="headerlink" title="docker attach登入容器"></a>docker attach登入容器</h3><pre><code>使用自带命令docker attach登陆容器。

命令格式：docker attach container_id

[root@tang ~]# docker ps   #前提容器已经启动了
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e657e9214a57        centos              &quot;/bin/bash&quot;         About an hour ago   Up 5 minutes                            tang
[root@tang ~]# docker attach tang
[root@test /]# exit
</code></pre><h3 id="ssh登入容器"><a href="#ssh登入容器" class="headerlink" title="ssh登入容器"></a>ssh登入容器</h3><pre><code>使用ssh登陆容器。这种方法需要在容器中启动sshd，存在开销和攻击面增大的问题。同时也违反了Docker所倡导的一个容器一个进程的原则

ssh登入会专门写一篇文章介绍。这里就不叙述了
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（4）--镜像管理]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89--%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="使用容器生成镜像"><a href="#使用容器生成镜像" class="headerlink" title="使用容器生成镜像"></a>使用容器生成镜像</h3><pre><code>[root@tang ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre>  <a id="more"></a>
<pre><code>[root@tang ~]# docker run -it -h nginx --name nginx  centos  /bin/bash

[root@nginx /]# rpm -ivh
http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm

[root@nginx /]# yum install -y nginx

[root@tang ~]# docker ps -a 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
e46c71171306        centos              &quot;/bin/bash&quot;         2 minutes ago       Exited (0) 40 seconds ago                       nginx

[root@tang ~]# docker commit -m &quot;my nginx&quot; -a &quot;tang&quot; e46c71171306 new_nginx:v1
sha256:c15ceb0a6871e3a56e3b22d67254d09b2e03a8ae909719a6dea0daaf937940ef

    -m: 改动信息
    -a: 作者信息
    e46c71171306: 这一串为容器ID
    new_nginx:01 新镜像的名字

[root@tang ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED              SIZE
new_nginx            v1                  c15ceb0a6871        About a minute ago   355 MB
docker.io/centos     latest              98d35105a391        2 weeks ago          192.5 MB
docker.io/registry   latest              047218491f8c        4 weeks ago          33.17 MB
</code></pre><h3 id="基于本地模块创建镜像"><a href="#基于本地模块创建镜像" class="headerlink" title="基于本地模块创建镜像"></a>基于本地模块创建镜像</h3><pre><code>模版获取,直接到openva官网下载(https://openvz.org/Download/template/precreated)

[root@tang opt]# wget http://download.openvz.org/template/precreated/centos-6-x86_64-minimal.tar.gz

[root@tang opt]# cat centos-6-x86_64-minimal.tar.gz |docker import - centos6
sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c

[root@tang opt]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
centos6      
</code></pre><h3 id="镜像导出-导入"><a href="#镜像导出-导入" class="headerlink" title="镜像导出/导入"></a>镜像导出/导入</h3><pre><code>[root@tang opt]# docker save centos6 &gt;/opt/centos6.tar.gz   #导出

[root@tang opt]# ll
total 1539880
-rw-r--r-- 1 root root 565194752 Apr  2 16:19 centos6.tar.gz

[root@tang opt]# docker rmi centos6
Untagged: centos6:latest
Deleted: sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c
Deleted: sha256:dbcc6b3893af5f0b45e06f2934f73f5dc34f2e9e54fc4d50a51cc47195f19089

[root@tang opt]# docker load &lt; /opt/centos6.tar.gz              #导入
[root@tang opt]# docker load --input /opt/centos6.tar.gz        #导入

#以上两种导入方法都可以

[root@tang opt]# docker tag centos6  centos6_x86                #改名
</code></pre><h3 id="将镜像上传到dockerhub官网"><a href="#将镜像上传到dockerhub官网" class="headerlink" title="将镜像上传到dockerhub官网"></a>将镜像上传到dockerhub官网</h3><pre><code>需要提前注册dockerhub账号

1. docker hub 帐号在本地验证登陆:

[root@tang opt]# docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.
Username: tangxiaoyue
Password: 
Login Succeeded

2. docker push 镜像到docker hub 的仓库
docker push
&lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt;

[root@tang ~]# docker tag centos tangxiaoyue/centos_tang:latest

[root@tang ~]# docker push tangxiaoyue/centos_tang
The push refers to a repository [docker.io/tangxiaoyue/centos_tang]
9b198ff9ff5b: Mounted from library/centos 
latest: digest: sha256:be5b4a93f116a57ab3fd454ada72421eac892a3a4925627ac9a44f65fcd69cf8 size: 529
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法大全]]></title>
      <url>http://yoursite.com/2017/03/11/Markdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<p><strong>题记：随着Markdown语言的热度不断提升，越来越多的人喜欢使用Markdown这种简洁、便宜的语言来编辑自己的blog、文章。下面笔者就一些简单常用的Markdown语句进行介绍，希望对大家在进行Markdown语言编辑自己的文章时有所帮助。</strong></p>
<a id="more"></a>
<h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1.斜体和粗体"></a>1.斜体和粗体</h2><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>1. *斜体*或_斜体_
2. **粗体**
3. ***加粗斜体***
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<ul>
<li><em>这是一段斜体</em>   </li>
<li><strong>这是一段粗体</strong>   </li>
<li><strong><em>这是一段加粗斜体</em></strong>   </li>
</ul>
<h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h2><blockquote>
<p>第一种写法： </p>
</blockquote>
<pre><code>1.这是一个一级标题   
2.================
3.   
4. 这是一个一级标题   
5. --------------------------
</code></pre><blockquote>
<p>第二种写法：</p>
</blockquote>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre><h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>1.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk)     
2.  
3.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk &quot;梵居闹市&quot;)   
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<p>欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="external">梵居闹市</a><br>欢迎来到<a href="http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="external">梵居闹市</a></p>
<h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><blockquote>
<p>代码：   </p>
</blockquote>
<pre><code>我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]    
[Leanote 笔记][2]是一个不错的[网站][]。     
[1]: http://www. google.com &quot;Google&quot;  
[2]:http://www. leanote.com &quot;Leanote&quot;
[3]:http://http:/ /blog.leanote.com/freewalk &quot;梵居闹市&quot;       
[网站]:http: //http://blog.leanote.com/freewalk
</code></pre><blockquote>
<p>显示效果：    </p>
</blockquote>
<p>我经常去的几个网站<a href="Markdown是一种纯文本标记语言">Google</a>、<a href="http://www.leanote.com" title="Leanote" target="_blank" rel="external">Leanote</a>以及<a href="http://http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="external">自己的博客</a><br><a href="http://www.leanote.com" title="Leanote" target="_blank" rel="external">Leanote 笔记</a>是一个不错的<a href="http://http://blog.leanote.com/freewalk" target="_blank" rel="external">网站</a>。</p>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><blockquote>
<p>代码： </p>
</blockquote>
<pre><code>&lt;http://example.com/&gt;   
&lt;address@example.com&gt;
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<p><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a><br><a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x61;&#x64;&#100;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x61;&#x64;&#100;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></p>
<h2 id="4-锚点"><a href="#4-锚点" class="headerlink" title="4.锚点"></a>4.锚点</h2><blockquote>
<p>代码：  </p>
</blockquote>
<pre><code>跳转到[目录](#index)
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<p>跳转到<a href="#index">目录</a></p>
<h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li><p>使用 *，+，- 表示无序列表。</p>
<blockquote>
<p>代码：  </p>
</blockquote>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三<blockquote>
<p>显示效果：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>1. 有序列表项 一
2. 有序列表项 二
3. 有序列表项 三
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 
*   那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩</li>
</ul>
<h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！

     那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！


*    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<ul>
<li><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p> 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </p>
</li>
<li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>*  阅读的方法:（一个空格）
    &gt; 打开书本。
    &gt; 打开电灯。
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<ul>
<li>阅读的方法:<blockquote>
<p>打开书本。<br>打开电灯。</p>
</blockquote>
</li>
</ul>
<h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p><strong>语法说明：</strong><br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：   </p>
<ul>
<li><p>一列表项包含一个列表区块： </p>
<pre><code>&lt;代码写在这&gt;
</code></pre></li>
</ul>
<h3 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h3><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：     </p>
<pre><code>1986. What a great season.
</code></pre><p>会显示成：     </p>
<ol>
<li>What a great season.</li>
</ol>
<p>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：      </p>
<pre><code>1986\. What a great season.
</code></pre><p>会显示成：<br>1986. What a great season.</p>
<h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h2><ul>
<li><p>代码：</p>
<pre><code>&gt; 这是一个有两段文字的引用,
&gt; 无意义的占行文字1.
&gt; 无意义的占行文字2.
&gt; 
&gt; 无意义的占行文字3.
&gt; 无意义的占行文字4
</code></pre></li>
<li>显示效果：  </li>
</ul>
<blockquote>
<p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.     </p>
<p>无意义的占行文字3.<br>无意义的占行文字4.     </p>
</blockquote>
<h3 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h3><ul>
<li><p>代码：</p>
<pre><code>&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白

&gt;&gt; 自己看教程！ - 愤青

&gt; 教程在哪？ - 小白
</code></pre></li>
<li>显示效果：</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="引用其它要素"><a href="#引用其它要素" class="headerlink" title="引用其它要素"></a>引用其它要素</h3><ul>
<li><p>代码：</p>
<pre><code>&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></li>
<li>显示效果：</li>
</ul>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></blockquote>
<h2 id="7-插入图像"><a href="#7-插入图像" class="headerlink" title="7. 插入图像"></a>7. 插入图像</h2><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><ul>
<li><p>代码： </p>
<pre><code>高圆圆： 
![高圆圆](ht tp://pic2016.5442.com:82/2015/1117/16/7.jpg%21960.jpg &quot;高圆圆&quot;)
</code></pre></li>
</ul>
<ul>
<li>显示效果</li>
</ul>
<p>高圆圆：<br><img src="http://pic2016.5442.com:82/2015/1117/16/7.jpg%21960.jpg" alt="高圆圆" title="高圆圆"></p>
<h2 id="8-内容目录"><a href="#8-内容目录" class="headerlink" title="8. 内容目录"></a>8. 内容目录</h2><ul>
<li>markdownpad居然不支持该语法，我就呵呵了.<blockquote>
<p>代码：</p>
</blockquote>
</li>
</ul>
<pre><code>[TOC]0.目录   
[TOC]1. 斜体和粗体          
[TOC]2. 分级标题
[TOC]3. 超链接
[TOC]     行内式
[TOC]     参考式
[TOC]    自动链接
[TOC]4. 锚点
</code></pre><h2 id="9-注脚"><a href="#9-注脚" class="headerlink" title="9. 注脚"></a>9. 注脚</h2><blockquote>
<p>代码：</p>
</blockquote>
<pre><code>使用 Markdown[1]可以效率的书写文档,你可以使用 Leanote[Le] 编辑器进行书写。

[1]:Markdown是一种纯文本标记语言

[Le]:开源笔记平台，支持Markdown和笔记直接发为博文
</code></pre><blockquote>
<p>显示效果：</p>
</blockquote>
<p>使用 Markdown<a href="Markdown是一种纯文本标记语言">1</a>可以效率的书写文档,你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">Le</a> 编辑器进行书写。       </p>
<p><br></p>
<p><br></p>
<p>   <strong>原文链接：<a href="http://blog.leanote.com/post/freewalk/Markdown-语法手册" target="_blank" rel="external">http://blog.leanote.com/post/freewalk/Markdown-语法手册</a></strong></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 基础（5）--容器管理]]></title>
      <url>http://yoursite.com/2017/03/11/Docker%20%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="查看启动的容器"><a href="#查看启动的容器" class="headerlink" title="查看启动的容器"></a>查看启动的容器</h4><pre><code>[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
2f8c14f16e03        centos              &quot;/bin/bash&quot;         5 minutes ago       Up 2 minutes                            tang
</code></pre>  <a id="more"></a>
<h4 id="查看所有的容器-包括启动、停止"><a href="#查看所有的容器-包括启动、停止" class="headerlink" title="查看所有的容器(包括启动、停止)"></a>查看所有的容器(包括启动、停止)</h4><pre><code>[root@tang ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
e5d7ccb9522c        centos              &quot;/bin/bash&quot;         15 seconds ago      Exited (0) 12 seconds ago                       tang1
2f8c14f16e03        centos              &quot;/bin/bash&quot;         3 minutes ago       Up 1 seconds                                    tang

Exited:表示该容器已经退出。没有启动
</code></pre><h4 id="创建容器-create、run-、进入容器"><a href="#创建容器-create、run-、进入容器" class="headerlink" title="创建容器(create、run)、进入容器"></a>创建容器(create、run)、进入容器</h4><pre><code>[root@tang ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
docker.io/centos     latest              98d35105a391        2 weeks ago         192.5 MB
docker.io/registry   latest              047218491f8c        4 weeks ago         33.17 MB

[root@tang ~]# docker create -it --name tang_create centos /bin/bash                     #使用create创建容器
3b316839ea357a3fe47fcae3488d6f491882ecb8c954412c502cbd6dcf9e2478

[root@tang ~]# docker run -it --name tang_run centos /bin/bash                          #使用run创建容器
[root@b5dbba42703a /]# exit
exit
</code></pre><h4 id="启动停止容器"><a href="#启动停止容器" class="headerlink" title="启动停止容器"></a>启动停止容器</h4><pre><code>[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

[root@tang ~]# docker start tang_run                #start启动容器
tang_run

[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b5dbba42703a        centos              &quot;/bin/bash&quot;         4 minutes ago       Up 14 seconds                           tang_run

[root@tang ~]# docker stop tang_run                 #stop停止容器
tang_run
[root@tang ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre><h4 id="创建容器-指定容器名"><a href="#创建容器-指定容器名" class="headerlink" title="创建容器,指定容器名"></a>创建容器,指定容器名</h4><pre><code>[root@tang ~]# docker run -itd -h tang_run --name tang centos /bin/bash
8afe717f82718214056a61e3881552338d5c911d272a80342edec063b5048
        -d: 容器退出后不关闭容器.
        -h:指定主机名
</code></pre><h4 id="删除容器-镜像"><a href="#删除容器-镜像" class="headerlink" title="删除容器/镜像"></a>删除容器/镜像</h4><pre><code>[root@tang ~]# docker rm tang                               #删除容器
[root@tang ~]# docker rm -f tang                            #强制删除容器，不管是否在运行
[root@tang ~]# docker rm $(docker ps -a -q)                 #删除所有容器
</code></pre><h4 id="导出容器-可迁移到其它机器-导入容器"><a href="#导出容器-可迁移到其它机器-导入容器" class="headerlink" title="导出容器(可迁移到其它机器)/导入容器"></a>导出容器(可迁移到其它机器)/导入容器</h4><pre><code>[root@tang ~]# docker export tang &gt;/opt/tang.tar            #导出容器
[root@tang ~]# docker rm tang
tang
[root@tang ~]# cat /opt/tang.tar |docker import - tang      #恢复的只是一个镜像，需要通过镜像创建容器
[root@tang ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
tang                 latest              393d449b1ed4        44 seconds ago      192.5 MB


提示：如果在之前那个容器内创建的文件，导出，导入之后容器内的文件是不变的
</code></pre>]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XtraBackup主从复制及备份]]></title>
      <url>http://yoursite.com/2017/03/11/XtraBackup%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h4 id="XtraBackup备份"><a href="#XtraBackup备份" class="headerlink" title="XtraBackup备份"></a>XtraBackup备份</h4><pre><code>1、yum安装mysql（以centos7为例）
###主从操作一致

#查看操作系统版本：
[root@node2 ~]# cat /etc/redhat-release
CentOS Linux release 7.0.1406 (Core)

#关闭防火墙和seLinux
[root@node2 ~]# systemctl stop firewalld
[root@node2 ~]# sed -i &quot;s#SELINUX=enforcing#SELINUX=disabled#g&quot; /etc/selinux/config
[root@node2 ~]# setenforce 0

#yum安装mysql
wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
rpm -ivh mysql-community-release-el7-5.noarch.rpm
yum install mysql-community-server
systemctl start mysql.service
mysql -uroot
&gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;);

###配置主从
主：
vim /etc/my.cnf
[mysqld]
log-bin = mysql-bin
server-id=1

从：
vim /etc/my.cnf
[mysqld]
log-bin = mysql-bin
server-id=2

2、安装xtrabackup备份软件（主从进行安装）
wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.3.4/binary/redhat/6/x86_64/percona-xtrabackup-2.3.4-1.el6.x86_64.rpm
yum install -y epel-release
yum localinstall percona-xtrabackup-2.3.4-1.el6.x86_64.rpm
yum install -y perl-Time-HiRes

#查看版本
&gt;select version();

#查看前默认的存储引擎
&gt;show variables like &apos;%storage_engine%&apos;;


3、导入数据（为了模拟比较真实可以往主库导入数据）（主库操作）
#导入bubi_api数据库
[root@node2 opt]# mysql -uroot -ppassword &lt; bubi_api.sql #
查看数据大小 
&gt; use information_schema;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
&gt; select concat(round(sum(data_length/1024/1024),2),&apos;MB&apos;) as data from tables;
+----------+
| data |
+----------+
| 194.94MB |
+----------+
1 row in set (0.04 sec)

4、数据库备份（主操作）
###备份
[root@node2 opt]# mkdir /extrabackup
[root@node2 opt]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=bubi --parallel=4 /mnt/resource/extrabackup
###出现completed OK! 表示备份成功

语法解释：–user=数据库用户
–password=数据库密码
–socket=指定socket
–default-file=指定配置文件
- 最后面是存放位

###保持事务一致（主操作）
[root@node2 2017-02-17_14-45-11]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --parallel=4 --apply-log /extrabackup/2017-02-17_14-45-11/
###出现completed OK!表示事务保持了一致，可以用于恢复




二、mysql主从同步操作
1、传输数据、将/extrabackup/2017-02-17_14-45-11/拷贝到从库
[root@node2 extrabackup]# scp -r 2017-02-17_14-45-11 root@192.168.1.13:/extrabackup/

2、从库恢复数据
[root@node3 extrabackup]# ll
总用量 0
drwx------. 4 root root 47 2月 17 14:47 2017-02-17_14-45-11

#停止mysql
[root@node3 extrabackup]# systemctl stop mysql

#清空mysql data目录
[root@node3 extrabackup]# cd /var/lib/mysql
[root@node3 mysql]# mv * /opt/mysqlbak/

#数据恢复
innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --copy-back /extrabackup/2017-02-17_11-49-35/
###出现completed OK! 表示恢复成功

#还原权限
[root@node3 mysql]# cd ..
[root@node3 lib]# chown mysql:mysql mysql -R

#重启mysql并查看数据的大小
[root@node3 lib]# systemctl start mysql
[root@node3 lib]# ps -ef | grep mysql
mysql 8173 1 0 14:59 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe --basedir=/usr
mysql 8338 8173 3 14:59 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sock
root 8364 5840 0 15:00 pts/0 00:00:00 grep --color=auto mysql

&gt; use information_schema;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt;    
+----------+
| data |
+----------+
| 194.94MB |
+----------+
1 row in set (0.26 sec)

###数据主从大小都一样

3、mysql主从同步操作
###主库授权
&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;rep&apos;@&apos;192.168.1.13&apos; IDENTIFIED BY &apos;123456&apos;;
&gt;FLUSH PRIVILEGES;

###从库开启同步
[root@node3 mysql]# cat /extrabackup/2017-02-17_14-45-11/xtrabackup_binlog_info
mysql-bin.000001 171510867

CHANGE MASTER TO
MASTER_HOST=&apos;10.25.159.23&apos;,
MASTER_USER=&apos;rep&apos;,
MASTER_PASSWORD=&apos;db0226&apos;,
MASTER_PORT=3306,
MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,
MASTER_LOG_POS=982559769;

####在还没同步之前我们可以在主库继续增加入一个库，验证不锁表是否可以同步
mysql&gt; show databases;
+--------------------+
| Database |
+--------------------+
| information_schema |
| bubi_api |
| mysql |
| performance_schema |
| tang |
+--------------------+
5 rows in set (0.00 sec)

#####开启主从同步
&gt;flush logs;
&gt; start slave; ###从库操作
&gt; show slave status\G
Slave_IO_Running: Yes
Slave_SQL_Running: Yes

##查看从库数据
mysql&gt; show databases;
+--------------------+
| Database |
+--------------------+
| information_schema |
| bubi_api |
| mysql |
| performance_schema |
| tang |
+--------------------+
5 rows in set (0.00 sec)

注意：
1、当从库停掉了（宕机还没测试）。主库继续写入数据，从库开启时，会自动同步




##########mysql命令
#查看binlog是否开启
&gt;show binary logs;

#查看serverid
&gt;show variables like &apos;server_id&apos;;

#查看binlog模式
&gt;show variables like &apos;%log%&apos;;


&gt;/dev/null 2&gt;&amp;1
</code></pre>]]></content>
      
        <categories>
            
            <category> Mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo常用命令]]></title>
      <url>http://yoursite.com/2017/03/11/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><strong><em>Hexo部署步骤</em></strong></p>
<pre><code>npm install    
npm install hexo-deployer-git --save   
hexo new &quot;新页面&quot;    
hexo clean   
hexo generate
hexo deploy    
</code></pre><a id="more"></a>
<p> <br></p>
<p><strong><em>Hexo常用命令</em></strong></p>
<pre><code>hexo new &quot;postName&quot;                 #新建文章     
hexo new page &quot;pageName&quot;             #新建页面   
hexo generate                         #生成静态页面至public目录    
hexo server                            #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）    
hexo deploy                         #将.deploy目录部署到GitHub       
hexo help                             #查看帮助
hexo version                        #查看Hexo的版本
</code></pre><p><br></p>
<p><strong><em>复合命令</em></strong></p>
<pre><code>hexo deploy -g #生成加部署   
hexo server -g #生成加预览    
</code></pre><p>命令的简写为：</p>
<pre><code>hexo n == hexo new    
hexo g == hexo generate   
hexo s == hexo server   
hexo d == hexo deploy   
</code></pre>]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[五分钟商学院--大纲]]></title>
      <url>http://yoursite.com/2016/09/25/%E4%BA%94%E5%88%86%E9%92%9F%E5%95%86%E5%AD%A6%E9%99%A2--%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<p>商业四大体系合体。</p>
<p>1）商业，你与企业外部的关系；<br>2）管理，你与企业内部的关系；<br>3）个人，你与自己的关系；<br>4）以及提升前三者的：工具。    </p>
<a id="more"></a>
<h2 id="商业篇"><a href="#商业篇" class="headerlink" title="商业篇"></a>商业篇</h2><h3 id="消费心理学"><a href="#消费心理学" class="headerlink" title="消费心理学"></a>消费心理学</h3><p>1.心理账户<br>2.沉没成本<br>3.比例偏见<br>4.损失规避<br>5.价格锚点          </p>
<h3 id="商业世界五大基础逻辑"><a href="#商业世界五大基础逻辑" class="headerlink" title="商业世界五大基础逻辑"></a>商业世界五大基础逻辑</h3><p>6.流量之河<br>7.倍率之刀<br>8.价量之秤<br>9.风险之眼<br>10.规则之缝  </p>
<h3 id="互联网世界五大基本定律"><a href="#互联网世界五大基本定律" class="headerlink" title="互联网世界五大基本定律"></a>互联网世界五大基本定律</h3><p>11.信息对称<br>12.平台经济<br>13.边际成本<br>14.长尾理论<br>15.免费理论  </p>
<h3 id="行为经济学"><a href="#行为经济学" class="headerlink" title="行为经济学"></a>行为经济学</h3><p>16.结果偏见<br>17.适应性偏见<br>18.鸡蛋理论<br>19.概率偏见<br>20.凡勃伦效应</p>
<h3 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h3><p>21.供需理论<br>22.边际效用<br>23.机会成本<br>24.代理两难<br>25.科斯定理   </p>
<h3 id="宏观经济学"><a href="#宏观经济学" class="headerlink" title="宏观经济学"></a>宏观经济学</h3><p>26.节约悖论<br>27.张维迎林毅夫之争<br>28.人口抚养比<br>29.经济泡沫<br>30.福利经济  </p>
<h3 id="金融法律"><a href="#金融法律" class="headerlink" title="金融法律"></a>金融法律</h3><p>31.风险投资<br>32.公司的形态：有限责任，合伙企业，个人独资<br>33.期权（员工激励方案）<br>34.庞氏骗局<br>35.互联网金融   </p>
<h3 id="市场营销-Product"><a href="#市场营销-Product" class="headerlink" title="市场营销 Product"></a>市场营销 Product</h3><p>36.产品定位<br>37.自我认知<br>38.极致单品<br>39.三驾马车<br>40.最小可用品  </p>
<h3 id="市场营销-Price"><a href="#市场营销-Price" class="headerlink" title="市场营销 Price"></a>市场营销 Price</h3><p>41.渗透定价法<br>42.组合定价法<br>43.撇脂定价法<br>44.价格歧视<br>45.客户自定价   </p>
<h3 id="市场营销-Promotion"><a href="#市场营销-Promotion" class="headerlink" title="市场营销 Promotion"></a>市场营销 Promotion</h3><p>46.定位营销<br>47.饥饿营销<br>48.死亡之井<br>49.危机公关<br>50.独特的销售主张-USP   </p>
<h3 id="市场营销-Place"><a href="#市场营销-Place" class="headerlink" title="市场营销 Place"></a>市场营销 Place</h3><p>51.深度分销<br>52.直接销售<br>53.虚实结合<br>54.社区商务<br>55.反向定制  </p>
<h3 id="市场营销-互联网营销"><a href="#市场营销-互联网营销" class="headerlink" title="市场营销 互联网营销"></a>市场营销 互联网营销</h3><p>56.社群经济<br>57.口碑经济（POE理论）<br>58.粉丝经济<br>59.引爆点<br>60.红利理论  </p>
<h3 id="所有现象背后都有商业逻辑"><a href="#所有现象背后都有商业逻辑" class="headerlink" title="所有现象背后都有商业逻辑"></a>所有现象背后都有商业逻辑</h3><p>61.运动对赌<br>62.雇佣客户<br>63.服务行业美女越多，经济越不景气<br>64.狩猎式 vs 农耕式<br>65.稳定平衡态 vs 不稳定平衡态   </p>
<h2 id="管理篇"><a href="#管理篇" class="headerlink" title="管理篇"></a>管理篇</h2><h3 id="管理选人"><a href="#管理选人" class="headerlink" title="管理选人"></a>管理选人</h3><p>66.上下车法则<br>67.奥格尔维定律<br>68.首因效应/光环效应<br>69.特雷默定律<br>70.重视面试被拒的人   </p>
<h3 id="管理育人"><a href="#管理育人" class="headerlink" title="管理育人"></a>管理育人</h3><p>71.蘑菇定律<br>72.师傅制<br>73.情境领导II<br>74.鲶鱼效应<br>75.贝尼斯定理  </p>
<h3 id="管理用人"><a href="#管理用人" class="headerlink" title="管理用人"></a>管理用人</h3><p>76.不值得定律<br>77.懒蚂蚁效应<br>78.热炉法则<br>79.拜伦法则<br>80.波特定律  </p>
<h3 id="管理留人"><a href="#管理留人" class="headerlink" title="管理留人"></a>管理留人</h3><p>81.酒与污水定律<br>82.格雷欣法则（劣币驱逐良币）<br>83.雷尼尔效应<br>84.南风法则<br>85.离职面试  </p>
<h3 id="管理就是激励需求理论"><a href="#管理就是激励需求理论" class="headerlink" title="管理就是激励需求理论"></a>管理就是激励需求理论</h3><p>86.马斯洛人类需求五层次理论-生理<br>87.马斯洛人类需求五层次理论-安全<br>88.马斯洛人类需求五层次理论-归属<br>89.马斯洛人类需求五层次理论-尊重<br>90.马斯洛人类需求五层次理论-实现  </p>
<h3 id="管理就是激励其他理论"><a href="#管理就是激励其他理论" class="headerlink" title="管理就是激励其他理论"></a>管理就是激励其他理论</h3><p>91.卡诺满意度模型<br>92.赫兹伯格的双因素激励理论<br>93.亚佛斯德原则（期望理论）<br>94.马蝇效应<br>95.波什定律   </p>
<h3 id="从员工到经理"><a href="#从员工到经理" class="headerlink" title="从员工到经理"></a>从员工到经理</h3><p>96.古狄逊定理<br>97.吉格勒定理<br>98.刺猬法则<br>99.目标置换效应<br>100.篮球架子原理  </p>
<h3 id="管理1"><a href="#管理1" class="headerlink" title="管理1"></a>管理1</h3><p>101.崔西定律<br>102.蓝柏格定理<br>103.阿什定律<br>104.彼得斯定律<br>105.超限效应   </p>
<h3 id="管理2"><a href="#管理2" class="headerlink" title="管理2"></a>管理2</h3><p>106.奥卡姆剃刀定律<br>107.法约尔原则（责权利心法）<br>108.例外原则<br>109.洛克忠告<br>110.海恩法则   </p>
<h3 id="管理3"><a href="#管理3" class="headerlink" title="管理3"></a>管理3</h3><p>111.波特法则<br>112.卡贝定律<br>113.飞轮效应<br>114.墨菲定律<br>115.克里夫兰法则   </p>
<h3 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h3><p>116.球队，交响乐队，军队<br>117.木桶定律<br>118.多样性（异性效应）<br>119.苛希纳定律<br>120.蚁群效应  </p>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>121.作战指挥室<br>122.关键路径<br>123.范围、时间、资源的金三角<br>124.风险管理（已知的未知风险）<br>125.权利来源：专业   </p>
<h3 id="管理常见病"><a href="#管理常见病" class="headerlink" title="管理常见病"></a>管理常见病</h3><p>126.破窗效应<br>127.旁观者效应<br>128.帕金森定律<br>129.彼得原理<br>130.手表定律  </p>
<h2 id="个人篇"><a href="#个人篇" class="headerlink" title="个人篇"></a>个人篇</h2><h3 id="高效能人士的七种习惯"><a href="#高效能人士的七种习惯" class="headerlink" title="高效能人士的七种习惯"></a>高效能人士的七种习惯</h3><p>131.范式转变<br>132.情感账户<br>133.积极主动<br>134.以终为始<br>135.要事第一  </p>
<h3 id="高效能人士的七种习惯-1"><a href="#高效能人士的七种习惯-1" class="headerlink" title="高效能人士的七种习惯"></a>高效能人士的七种习惯</h3><p>136.双赢思维<br>137.知彼解己<br>138.统合综效<br>139.不断更新<br>140.找到心声  </p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>141.时间成本<br>142.GTD<br>143.猴子理论<br>144.三八理论<br>145.番茄钟   </p>
<h3 id="职业素养"><a href="#职业素养" class="headerlink" title="职业素养"></a>职业素养</h3><p>146.如何打招呼<br>147.如何吃西餐<br>148.如何和老板一起坐车<br>149.如何搭配衣服<br>150.邮件礼仪   </p>
<h3 id="学习能力"><a href="#学习能力" class="headerlink" title="学习能力"></a>学习能力</h3><p>151.幸存者偏见<br>152.库博经验学习圈<br>153.知识、技能、态度<br>154.学习小组（私人董事会）<br>155.如何最快速的学习    </p>
<h3 id="思考能力"><a href="#思考能力" class="headerlink" title="思考能力"></a>思考能力</h3><p>156.六顶思考帽<br>157.批判性思维/辩证思维<br>158.系统思维-关联的、整体的、动态的<br>159.正向思维<br>160.逆向思维   </p>
<h3 id="逻辑思维"><a href="#逻辑思维" class="headerlink" title="逻辑思维"></a>逻辑思维</h3><p>161.偷换概念-同一律<br>162.自相矛盾-矛盾律<br>163.模棱两可-排中律<br>164.三段论<br>165.归纳法与黑天鹅事件   </p>
<h3 id="谈判能力"><a href="#谈判能力" class="headerlink" title="谈判能力"></a>谈判能力</h3><p>166.吉普赛陷阱<br>167.定位调整偏见<br>168.有限的权利 &amp; 不露面的人<br>169.战略延迟 &amp; 最终期限<br>170.吃惊 &amp; 撤退    </p>
<h3 id="情感能力"><a href="#情感能力" class="headerlink" title="情感能力"></a>情感能力</h3><p>171.元能力：同理心<br>172.元能力：自我认知（卢维斯定理）<br>173.元能力：自我控制<br>174.元能力：自我激励<br>175.元能力：人际关系处理   </p>
<h3 id="演讲能力"><a href="#演讲能力" class="headerlink" title="演讲能力"></a>演讲能力</h3><p>176.导游心法<br>177.注意力法则<br>178.空中加油<br>179.案例和幽默感<br>180.打透     </p>
<h3 id="沟通能力"><a href="#沟通能力" class="headerlink" title="沟通能力"></a>沟通能力</h3><p>181.快乐痛苦四原则<br>182.亨利法则<br>183.踢猫效应<br>184.电梯测验<br>185.如何问出好问题    </p>
<h3 id="创新能力"><a href="#创新能力" class="headerlink" title="创新能力"></a>创新能力</h3><p>186.创新者的窘境<br>187.人无我有，人有我优，人优我廉……<br>188.达维多定律<br>189.路径依赖<br>190.比伦定律   </p>
<h3 id="领导能力"><a href="#领导能力" class="headerlink" title="领导能力"></a>领导能力</h3><p>191.远（后喻文明）<br>192.小（科斯定理）<br>193.变（企业生命周期）<br>194.快（快鱼吃慢鱼）<br>195.专（网状激活系统）   </p>
<h2 id="战略篇"><a href="#战略篇" class="headerlink" title="战略篇"></a>战略篇</h2><h3 id="战略工具"><a href="#战略工具" class="headerlink" title="战略工具"></a>战略工具</h3><p>196.麦肯锡·MECE法<br>197.波特·五力模型<br>198.波士顿矩阵<br>199.金字塔原理<br>200.通用电器矩阵    </p>
<h3 id="战略工具-1"><a href="#战略工具-1" class="headerlink" title="战略工具"></a>战略工具</h3><p>201.正态分布理论<br>202.逻辑树/决策树<br>203.平衡计分表<br>204.SWOT模型<br>205.麦肯锡·七步成诗法    </p>
<h3 id="博弈工具"><a href="#博弈工具" class="headerlink" title="博弈工具"></a>博弈工具</h3><p>206.纳什均衡<br>207.囚徒困境<br>208.贝叶斯均衡<br>209.智猪博弈<br>210.公地悲剧     </p>
<h3 id="博弈工具-1"><a href="#博弈工具-1" class="headerlink" title="博弈工具"></a>博弈工具</h3><p>211.你分我拿<br>212.拍卖逻辑<br>213.零和游戏原理<br>214.拍卖美元<br>215.用餐者困境    </p>
<h3 id="决策工具"><a href="#决策工具" class="headerlink" title="决策工具"></a>决策工具</h3><p>216.儒佛尔定律<br>217.吉德林法则<br>218.布利丹效应<br>219.羊群效应<br>220.麦穗哲理     </p>
<h3 id="创新工具"><a href="#创新工具" class="headerlink" title="创新工具"></a>创新工具</h3><p>221.减法创新<br>222.除法创新<br>223.乘法创新<br>224.任务统筹策略<br>225.属性依存策略   </p>
<h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><p>226.OKR<br>227.MBTI人格理论（自我管理）<br>228.SMART原则（目标管理）<br>229.PDCA循环规则（项目管理）<br>230.5W2H法（目标管理）    </p>
<h3 id="思考工具"><a href="#思考工具" class="headerlink" title="思考工具"></a>思考工具</h3><p>231.头脑风暴法<br>232.思考工具：白板<br>233.思维导图<br>234.5WHY分析法<br>235.复盘     </p>
<h3 id="沟通工具"><a href="#沟通工具" class="headerlink" title="沟通工具"></a>沟通工具</h3><p>236.有效的1：1<br>237.罗伯特议事规则<br>238.白板墙、低隔板、下午茶和即时贴<br>239.拉波波特评论规则<br>240.结构沟通法     </p>
<h3 id="财务工具"><a href="#财务工具" class="headerlink" title="财务工具"></a>财务工具</h3><p>241.财务分析中的五力分析法<br>242.零基预算？<br>243.本福特定律<br>244.独立P&amp;L<br>245.计算企业价值     </p>
<h3 id="营销工具"><a href="#营销工具" class="headerlink" title="营销工具"></a>营销工具</h3><p>246.直播营销<br>247.Focus Group<br>248.STP<br>249.4C<br>250.4P   </p>
<h3 id="未来已来"><a href="#未来已来" class="headerlink" title="未来已来"></a>未来已来</h3><p>256.零边际成本社会<br>257.奇点临近<br>258.比特币<br>259.基因科技<br>260.人工智能   </p>
]]></content>
      
        <categories>
            
            <category> 读书 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五分钟商学院 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysqladmin命令总结]]></title>
      <url>http://yoursite.com/2016/03/11/Mysqladmin%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<pre><code>mysqladmin 工具的使用格式：
mysqladmin [option] command [command option] command ......
</code></pre><a id="more"></a>
<pre><code>参数选项：
-c number 自动运行次数统计，必须和 -i 一起使用
-i number 间隔多长时间重复执行

0）每个两秒查看一次服务器的状态，总共重复5次。
[root@test-huanqiu ~]# mysqladmin -uroot -p -i 2 -c 5 status


1）查看服务器的状况：status
[root@test-huanqiu ~]# mysqladmin -uroot -p status

2）修改root 密码：
[root@test-huanqiu ~]# mysqladmin -u root -p原密码 password &apos;newpassword&apos;

3）检查mysqlserver是否可用：
[root@test-huanqiu ~]# mysqladmin -uroot -p ping

4）查询服务器的版本
[root@test-huanqiu ~]# mysqladmin -uroot -p version

5）查看服务器状态的当前值：
[root@test-huanqiu ~]# mysqladmin -uroot -p extended-status

6）查询服务器系统变量值：
[root@test-huanqiu ~]# mysqladmin -uroot -p variables

7）显示服务器所有运行的进程：
[root@test-huanqiu ~]# mysqladmin -uroot -p processlist
[root@test-huanqiu ~]# mysqladmin -uroot -p-i 1 processlist   

8）创建数据库
[root@test-huanqiu ~]# mysqladmin -uroot -p create daba-test//每秒刷新一次

9）显示服务器上的所有数据库
[root@test-huanqiu ~]# mysqlshow -uroot -p

10）显示数据库daba-test下有些什么表：
[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test

11）统计daba-test 下数据库表列的汇总
[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v

12）统计daba-test 下数据库表的列数和行数
[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v -v

13）删除数据库 daba-test
[root@test-huanqiu ~]# mysqladmin -uroot -p drop daba-test

14）重载权限信息
[root@test-huanqiu ~]# mysqladmin -uroot -p reload

15）刷新所有表缓存，并关闭和打开log
[root@test-huanqiu ~]# mysqladmin -uroot -p refresh

16）使用安全模式关闭数据库
[root@test-huanqiu ~]# mysqladmin -uroot -p shutdown

17）刷新命令mysqladmin flush commands
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-hosts
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-logs
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-privileges
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-status
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-tables
[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-threads

18）mysqladmin 执行kill 进程：
[root@test-huanqiu ~]# mysqladmin -uroot -p processlist
[root@test-huanqiu ~]# mysqladmin -uroot -p kill idnum

19）停止和启动MySQL replication on a slave server
[root@test-huanqiu ~]# mysqladmin -u root -p stop-slave
[root@test-huanqiu ~]# mysqladmin -u root -p start-slave

20）同时执行多个命令
[root@test-huanqiu ~]# mysqladmin -u root -p process status version
</code></pre>]]></content>
      
        <categories>
            
            <category> Mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
