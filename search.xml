<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Docker 基础（8）--网络管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89--%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker四种网络模式第一种网络模式hosthost模式: 使用--net=host指定docker使用的网络实际上和宿主机一样,在容器内看到的网卡ip是宿主机上的ip. [root@docker ~]# docker run -itd -h node1 --name node1 --net=host centos bash 406cdb306f3c350b6f5344048ae25426f1df3f6863162c0b3a91e3dcd48eba [root@docker ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 [root@docker ~]# docker-enter node1 #进去之后修改主机名，因为主机名个宿主机一样，貌似-h也指定不了主机名 [root@node1 ~]# yum install -y net-tools [root@node1 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 第二种网络模式containercontainer模式: 使用--net=container:container_id/container_name多个容器使用共同的网络,看到的ip是一样的. [root@docker ~]# docker run -itd -h node2 --name node2 --net=container:node1 centos bash #此处不能指定主机名创建，否则失败 /usr/bin/docker-current: Error response from daemon: Conflicting options: hostname and the network mode. See &apos;/usr/bin/docker-current run --help&apos; [root@docker ~]# docker run -itd --name node2 --net=container:node1 centos bash 0fc16c4a055cf0035c1241ba6cce6c5ad0c711f2ef13e0589c3254f19a96b271 [root@docker ~]# docker-enter node2 [root@node2 ~]# yum install -y net-tools [root@node2 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; #和node1的ip一样，也和宿主机的ip一样（node1使用的是--net=host模式） 172.17.82.185 第三种网络模式nonenone模式: 使用--net=none, 这种模式下,不会配置任何网络 [root@docker ~]# docker run -itd -h node3 --name node3 --net=none centos c1f4bd859566f11517248718a94456066d16ad66748a2c78743881e450d4ca09 [root@docker ~]# docker-enter node3 [root@node3 ~]# ping www.baidu.com ping: www.baidu.com: Name or service not known 第四种网络模式bridgebridge模式: 使用--net=bridge.创建完容器默认为这种网络模式.类似与vmware的nat网络模式. [root@docker ~]# docker run -itd -h node4 --name node4 --net=bridge centos bash fc4f817e741f22615d0cdbab6608877d268ea15be6ba790cae5706d03871ac41 外部访问容器[root@docker ~]# docker run -itd -h node1 --name node1 centos bash 27df97f0e77e745660ee7b9c8b318c64f63e6aa632db3d3b0c44c4e0f4006124 [root@docker ~]# docker-enter node1 [root@node1 ~]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@node1 ~]# yum install -y nginx [root@docker ~]# docker commit -m &quot;nginx&quot; -a &quot;tang&quot; 27df97f0e77e nginx:v1 #此处仅容器做为镜像，主要是减少以后重复性的工作，不需要新建一个容器在部署nginx [root@docker ~]# docker run -itd -h nginx --name nginx -p 81:80 nginx:v1 bash #-p 端口映射，射到宿主机81端口上 a5dd375e829d05734a935d5f41723841568b543822a64a4ec277480f5f552e41 [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# /usr/sbin/nginx [root@nginx ~]# echo &quot;TangXiaoyue&quot; &gt; /usr/share/nginx/html/1.html [root@nginx ~]# curl 127.0.0.1/1.html TangXiaoyue [root@nginx ~]# exit logout [root@docker ~]# curl 127.0.0.1:81/1.html TangXiaoyue 容器互联1.安装mysql [root@docker ~]# docker run --privileged -itd -h node1 --name node1 centos /sbin/init fd547b535ff3af19bf36b219f542864962d60480a8d56836db30c20f079ec43f [root@docker ~]# docker-enter node1 [root@node1 ~]# yum install -y wget [root@node1 ~]# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# rpm -ivh mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# yum install mysql-community-server [root@node1 ~]# systemctl start mysql.service [root@node1 ~]# mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); 2.制作mysql镜像 [root@docker ~]# docker commit -m &quot;mysql&quot; -a &quot;tang&quot; fd547b535ff3 mysql:v1 sha256:21af416e70b0302163e4aa279118afdd96a0c8590487268a3d26920caf6c5d1a [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql v1 21af416e70b0 4 seconds ago 797.3 MB [root@docker ~]# docker run --privileged -itd -h mysql --name mysql mysql:v1 /sbin/init 8d71a34516a2c05a7ea63fde5773785360d1301509d687797eec5ead62a01d55 3.以mysql、nginx镜像分别创建两个容器并端口映射 [root@docker ~]# docker run -itd -h nginx --name nginx -p 10080:80 --link mysql:db nginx:v1 bash 8aea6116f67c9760b8f4d3de08251b28af839b9e2195860ad4b24d54833c286a [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# yum install -y telnet [root@nginx ~]# telnet db 3306 Trying 172.18.0.3... Connected to db. Escape character is &apos;^]&apos;. CHost &apos;172.18.0.4&apos; is not allowed to connect to this MySQL serverConnection closed by foreign host. [root@nginx ~]# cat /etc/hosts 172.18.0.3 db mysql mysql 172.18.0.4 nginx 配置网桥(centos7)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（3）--容器登入]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[docker-enter登入容器 强烈推荐使用此种方法：简单、方便 下载.bashrc_docker，并将内容放到.bashrc中。 这个文件中定义了很多方便使用Docker的命令，比如docker-pid可以获取某个容器的 PID； 而 docker-enter 可以进入容器或直接在容器内执行命令 [root@tang ~]# wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker [root@tang ~]# echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc [root@tang ~]# docker- docker-containerd docker-ctr-current docker-pid docker-containerd-current docker-current docker-storage-setup docker-containerd-shim docker-enter docker-containerd-shim-current docker-ip [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 24 minutes ago Up 23 minutes tang [root@tang ~]# docker-pid tang 19271 [root@tang ~]# nsenter --target 19271 --mount --uts --ipc --net --pid #此种方法进入容器以下会讲到 [root@test /]# exit logout [root@tang ~]# docker-ip tang 172.18.0.2 直接使用docker-enter命令进入容器，非常方便！ [root@tang ~]# docker-enter tang Last login: Sun Apr 2 06:38:47 UTC 2017 [root@test ~]# exit logout [root@tang ~]# docker ps #退出登陆窗口后，容器还在 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 26 minutes ago Up 9 seconds tang 注意：以在容器的上下文中运行任意命令！即在宿主机上执行容器里的命令 [root@tang ~]# docker-enter tang uptime 07:06:28 up 1 day, 22:44, 0 users, load average: 0.00, 0.01, 0.05 注意：在宿主机上使用docker-enter命令执行容器中的命令时，最好后面加上--符号，这样容器里的所有存在的命令都可以正常执行。 [root@tang ~]# docker-enter tang -- uptime 07:06:59 up 1 day, 22:45, 0 users, load average: 0.00, 0.01, 0.05 [root@tang ~]# docker-enter tang -- df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/docker-253:1-2024335-661487685eb1f6a356157463d60db20caa2c1fb3ac273de680c367e3b12dabab 10G 238M 9.8G 3% / tmpfs 920M 0 920M 0% /dev tmpfs 920M 0 920M 0% /sys/fs/cgroup /dev/vda1 99G 4.7G 89G 5% /etc/hosts shm 64M 0 64M 0% /dev/shm [root@tang ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@tang ~]# docker-enter tang -- cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) nsenter登入容器使用外部工具nsenter登陆容器，该工具和docker exec命令的效果差不多。 使用nsenter或dockerexec，都可以在容器的上下文（严格地说，是命名空间）中运行任意命令！ ==nsenter安装： [root@tang ~]# yum install util-linux -y ==nsenter使用： [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 50 minutes ago Up 24 minutes tang [root@tang ~]# docker inspect -f &quot;{{ .State.Pid }}&quot; tang 19271 [root@tang ~]# nsenter -t 19271 -m -u -i -n -p 解释nsenter指令中进程id之后的参数的含义： –mount参数是进去到mount namespace中 –uts参数是进入到uts namespace中 –ipc参数是进入到System V IPC namaspace中 –net参数是进入到network namespace中 –pid参数是进入到pid namespace中 –user参数是进入到user namespace中 [root@tang ~]# nsenter --help Usage: nsenter [options] &lt;program&gt; [&lt;argument&gt;...] Run a program with namespaces of other processes. Options: -t, --target &lt;pid&gt; target process to get namespaces from -m, --mount[=&lt;file&gt;] enter mount namespace -u, --uts[=&lt;file&gt;] enter UTS namespace (hostname etc) -i, --ipc[=&lt;file&gt;] enter System V IPC namespace -n, --net[=&lt;file&gt;] enter network namespace -p, --pid[=&lt;file&gt;] enter pid namespace -U, --user[=&lt;file&gt;] enter user namespace -S, --setuid &lt;uid&gt; set uid in entered namespace -G, --setgid &lt;gid&gt; set gid in entered namespace --preserve-credentials do not touch uids or gids -r, --root[=&lt;dir&gt;] set the root directory -w, --wd[=&lt;dir&gt;] set the working directory -F, --no-fork do not fork before exec ing &lt;program&gt; -Z, --follow-context set SELinux context according to --target PID -h, --help display this help and exit -V, --version output version information and exit 我们进入容器中查看进程 以下是以nsenter启动的进程 [root@test /]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 11768 1684 ? Ss+ 07:03 0:00 /bin/bash root 77 0.0 0.1 15200 1988 ? S 07:31 0:00 -bash root 90 0.0 0.0 50872 1816 ? R+ 07:31 0:00 ps aux /bin/bash是我们运行容器产生的进程 -bash 是我们使用nsenter产生的，这样如果我们退出容器，容器就不会退出，因为-bash还在运行 [root@test /]# exit logout [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 55 minutes ago Up 29 minutes tang 因为每次进入容器都需要输入那两条命令，所以我们可以写一个脚本来获取。 ==脚本内容如下： [root@tang opt]# cat docker_in.sh #!/bin/bash # Use nsenter to access docker docker_in(){ NAME_ID=$1 PID=$(docker inspect -f &quot;{{ .State.Pid }}&quot; $NAME_ID) nsenter -t $PID -m -u -i -n -p } docker_in $1 [root@tang opt]# chmod +x docker_in.sh [root@tang opt]# ./docker_in.sh tang [root@test /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 91 0 0 07:34 ? 00:00:00 -bash root 104 91 0 07:34 ? 00:00:00 ps -ef [root@test /]# exit logout [root@tang opt]# docker exec tang ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 105 0 0 07:35 ? 00:00:00 ps -ef 我们还可以使用exec进入docker容器中 [root@tang opt]# docker exec -it tang /bin/bash start -ai登入容器对于一个已关闭的容器的登陆，可以使用&quot;docker start -ai container&quot;登陆。这种其实就是先启动容器，然后再进入容器内。 [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Exited (0) 53 seconds ago tang [root@tang ~]# docker start -ai tang #-a -i 都可以 [root@test /]# exit exit [root@tang ~]# docker start -i tang [root@tang ~]# docker start -a tang docker exec登入容器使用自带命令docker exec登陆容器 命令格式：docker exec -ti container_id /bin/bash [root@tang ~]# docker ps #前提是容器已经启动 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 2 minutes tang [root@tang ~]# docker exec -it tang /bin/bash [root@test /]# exit docker attach登入容器使用自带命令docker attach登陆容器。 命令格式：docker attach container_id [root@tang ~]# docker ps #前提容器已经启动了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 5 minutes tang [root@tang ~]# docker attach tang [root@test /]# exit ssh登入容器使用ssh登陆容器。这种方法需要在容器中启动sshd，存在开销和攻击面增大的问题。同时也违反了Docker所倡导的一个容器一个进程的原则 ssh登入会专门写一篇文章介绍。这里就不叙述了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（5）--容器管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[查看启动的容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f8c14f16e03 centos &quot;/bin/bash&quot; 5 minutes ago Up 2 minutes tang 查看所有的容器(包括启动、停止)[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e5d7ccb9522c centos &quot;/bin/bash&quot; 15 seconds ago Exited (0) 12 seconds ago tang1 2f8c14f16e03 centos &quot;/bin/bash&quot; 3 minutes ago Up 1 seconds tang Exited:表示该容器已经退出。没有启动 创建容器(create、run)、进入容器[root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB [root@tang ~]# docker create -it --name tang_create centos /bin/bash #使用create创建容器 3b316839ea357a3fe47fcae3488d6f491882ecb8c954412c502cbd6dcf9e2478 [root@tang ~]# docker run -it --name tang_run centos /bin/bash #使用run创建容器 [root@b5dbba42703a /]# exit exit 启动停止容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker start tang_run #start启动容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b5dbba42703a centos &quot;/bin/bash&quot; 4 minutes ago Up 14 seconds tang_run [root@tang ~]# docker stop tang_run #stop停止容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 创建容器,指定容器名[root@tang ~]# docker run -itd -h tang_run --name tang centos /bin/bash 8afe717f82718214056a61e3881552338d5c911d272a80342edec063b5048 -d: 容器退出后不关闭容器. -h:指定主机名 删除容器/镜像[root@tang ~]# docker rm tang #删除容器 [root@tang ~]# docker rm -f tang #强制删除容器，不管是否在运行 [root@tang ~]# docker rm $(docker ps -a -q) #删除所有容器 导出容器(可迁移到其它机器)/导入容器[root@tang ~]# docker export tang &gt;/opt/tang.tar #导出容器 [root@tang ~]# docker rm tang tang [root@tang ~]# cat /opt/tang.tar |docker import - tang #恢复的只是一个镜像，需要通过镜像创建容器 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tang latest 393d449b1ed4 44 seconds ago 192.5 MB 提示：如果在之前那个容器内创建的文件，导出，导入之后容器内的文件是不变的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（7）--数据管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89--%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[挂载本地目录到容器里[root@tang /]# mkdir /data/docker -p root@tang docker]# mkdir docker_01 [root@tang docker]# docker run -it -h docker_01 --name docker_01 -v /data/docker/docker_01/:/docker_01 centos bash [root@docker_01 /]# cd /docker_01/ [root@docker_01 docker_01]# touch docker_01.txt [root@docker_01 docker_01]# exit exit [root@tang docker]# cd /data/docker/docker_01/ [root@tang docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 08:03 docker_01.txt [root@tang docker_01]# cd .. [root@tang docker]# mkdir docker_02 [root@tang docker]# docker run -it -h docker_02 --name docker_02 -v /data/docker/docker_02/:/docker_02 centos bash [root@docker_02 /]# cd /docker_02/ [root@docker_02 docker_02]# mkdir docker_02.txt [root@docker_02 docker_02]# exit exit [root@tang docker]# cd docker_02/ [root@tang docker_02]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 08:05 docker_02.txt 提示： -v: 指定挂载目录 : : 前面的为本地目录 : : 后面到为容器里的目录 即使将删除这个容器,文件也不会丢失. 挂载数据卷(多个容器挂载宿主机的同一个目录)[root@tang data]# docker run -it -h docker_03 --name docker_03 --volumes-from docker_01 centos bash [root@docker_03 /]# cd /docker_01/ [root@docker_03 docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@docker_03 docker_01]# df -h|grep docker_01 /dev/vda1 99G 5.4G 88G 6% /docker_01 [root@docker_03 docker_01]# echo &quot;This is Doceker_3&quot; &gt; /docker_01/3.txt [root@docker_03 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@tang ~]# docker start docker_01 docker_01 [root@tang ~]# docker-enter docker_01 [root@docker_01 ~]# cd /docker_01/ [root@docker_01 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt 自定义数据卷容器[root@tang ~]# docker run -itd -h node --name node -v /data centos bash 056ac10e28855c3d29a94fe552711e6a712a5670e6e9c43c4b79270cbc6b0a0f #这里的/data是容器node的/data目录,而不是宿主机的/data目录 [root@tang ~]# docker-enter node [root@node ~]# touch /data/1 /data/2 /data/3 [root@node ~]# cd /data/ [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node data]# exit logout [root@tang ~]# docker run -itd -h node1 --name node1 --volumes-from node centos bash 2965a8f1184a7a1cbd26ef07e4b3d201fa17e5b68a52c619d6292da75c85d117 [root@tang ~]# docker-enter node1 [root@node1 ~]# cd /data/ [root@node1 data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node1 data]# touch 4 [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 -rw-r--r-- 1 root root 0 Apr 3 01:02 4 数据卷的备份[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 250da7a47222e52c5a5d387ff8ce816a72b221ffb8d481739c4c68073507fe [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /data [root@tang ~]# touch /data/{1,2,3,4} [root@tang ~]# tar cvf /backup/data.tar /data/ [root@tang ~]# cd /backup/ [root@tang backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 01:30 data.tar [root@tang backup]# exit logout [root@docker ~]# cd /docker_data_backup/ [root@docker docker_data_backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 09:30 data.tar 数据卷的恢复[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 3728f6b0a6e5b47f904de0474db7d4479f33e87740906e1539eca385c3fab04d [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /tools/ [root@tang ~]# touch /tools/{1,2,3,4} [root@tang ~]# tar zcvf /backup/tools.tar /tools/ /tools/ /tools/1 /tools/2 /tools/3 /tools/4 [root@tang ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang ~]# exit logout [root@docker ~]# docker run -itd -h tang1 --name tang1 -v /tang1 centos bash 7ec371bb67f136234878771c227c4245a0ccf6c986e8c94a412d6c4111852a2b [root@docker ~]# docker run -itd -h tang2 --name tang2 --volumes-from tang1 -v /docker_data_backup/:/backup centos bash 53e4cea1c45f3c081a6dd95b935f906aa037e6ed2170b6249a913ccd6fb4c119 [root@docker ~]# docker-enter tang2 [root@tang2 ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang2 tang1]# tar xvf /backup/tools.tar -C /tang1 [root@tang2 tang1]# exit logout [root@docker ~]# docker-enter tang1 [root@tang1 ~]# cd /tang1/ [root@tang1 tang1]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 02:07 tools]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker问题梳理--持续更新]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于systemctl无法启动服务的问题处理问题： 使用systemctl启动服务的时候出现以下异常： Failed to get D-Bus connection: Operation not permitted 解决： docker run --privileged -itd -h node1 --name node1 centos /sbin/init]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（2）--命令]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89--%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[安装下载yum install -y docker #下载 systemctl start docker #启动 systemctl enable docker #自启动 镜像操作docker search images #搜索镜像 docker pull images #下载镜像 docker images #查看镜像 docker tag centos6 centos6_x86 #镜像改名 docker save image&gt;/opt/images.tar.gz #导出镜像 docker load&lt;/opt/images.tar.gz #导入镜像 docker load --input /opt/images.tar.gz #导入镜像 docker rmi images_id #删除镜像 docker rmi $(docker images -q) #删除所有镜像 容器操作docker ps -a #查看容器 docker run centos /bin/echo &quot;hehe&quot; #首次创建一个容器 docekr run -h tang --name tang -t -i centos /bin/bah #创建一个以tang为名的容器； --name：指定容器名 -t：分配一个tty终端 -i：容器的标准输出保持打开状态 -h:指定主机名 docker create -it --name centos1 centos #使用create创建容器 docekr stop ID（name） #停止容器 docker start ID（name） #启动容器 docker attach ID（name） #进入容器 docker exec -it ID(name) /bin/bash docker rm ID（name） #删除容器 -f：强制删除容器，包括在运行的 #exec和attach总结: attach登陆容器后,退出时容器会关闭. 推荐使用exec进入容器 docker rm $(docker ps -a -q) #删除所有容器 映射docker run --name nginx -d -P nginx #随机映射 docker run --name nginx -d -p 81:80 nginx #指定映射 docker run -it --name nginx -p 80:80 nginx /bin/bash #指定映射 日志docker logs ID（name） #查看日志 数据管理docker run -it --name tang -v /data centos #默认挂载目录 docekr inspect ID(name) #查看容器信息 ==查看mounts模块 docekr run -it --name tang -v /data:/data centos #指定挂载目录 docker run -it --name tang -v /data:/data:rw centos #指定权限挂载 ==rw：读写 docker run -it --name tang -v /data:/data:ro centos #指定权限挂载 ==ro：只读 docker run -it --name tang ~/.bash_history:/.bash_history centos #记录历史记录 数据卷容器docker run -d --name nfs -v /data:/data centos #启动nfs容器，挂在一个卷， -d：直接在后台执行 docker run -it --name test1 --volumes-from nfs centos #启动test1容器，挂载到nfs的数据卷容器上 docker run -it --name test2 --volumes-from nfs centos #启动test2容器，挂载到nfs的数据卷容器上 #test1和test2的/data数据可以共享 手动制作镜像docker run -it --name mynginx centos #基础centos进行创建容器mynginx 在mynginx容器内安装nginxrpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm yum install -y nginx docker commit -m &quot;my nginx&quot; f9c7dfb6f552 tang/mynginx:v1 #提交镜像， ==同时打一个标签叫mynginx:v1 ==tang相当于你向github上提交的用户名 docker run -it --anme nginxv1 tang/mynginx:v1 #基于镜像tang/mynginx:v1创建容器nginxv1 ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（6）--仓库管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89--%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker的仓库是DockerHub，类似于github，github有一个开源的软件叫gitlab。Docker也有一个开源软件docker registry [root@tang ~]# docker pull registry [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 默认占用5000端口，我们查看是否存在5000端口 [root@tang ~]# netstat -lntup | grep 5000 运行容器 [root@tang ~]# docker run -d -p 5000:5000 registry f002089ab95474290853a2a24b86cb0adbb5848c4a468175304b59b27d6e3b0e 提示：docker比较老的版本运行起来就可以运行，1.7之后都不可以]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（4）--镜像管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89--%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[使用容器生成镜像[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker run -it -h nginx --name nginx centos /bin/bash [root@nginx /]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@nginx /]# yum install -y nginx [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e46c71171306 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 40 seconds ago nginx [root@tang ~]# docker commit -m &quot;my nginx&quot; -a &quot;tang&quot; e46c71171306 new_nginx:v1 sha256:c15ceb0a6871e3a56e3b22d67254d09b2e03a8ae909719a6dea0daaf937940ef -m: 改动信息 -a: 作者信息 e46c71171306: 这一串为容器ID new_nginx:01 新镜像的名字 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE new_nginx v1 c15ceb0a6871 About a minute ago 355 MB docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 基于本地模块创建镜像模版获取,直接到openva官网下载(https://openvz.org/Download/template/precreated) [root@tang opt]# wget http://download.openvz.org/template/precreated/centos-6-x86_64-minimal.tar.gz [root@tang opt]# cat centos-6-x86_64-minimal.tar.gz |docker import - centos6 sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c [root@tang opt]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos6 镜像导出/导入[root@tang opt]# docker save centos6 &gt;/opt/centos6.tar.gz #导出 [root@tang opt]# ll total 1539880 -rw-r--r-- 1 root root 565194752 Apr 2 16:19 centos6.tar.gz [root@tang opt]# docker rmi centos6 Untagged: centos6:latest Deleted: sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c Deleted: sha256:dbcc6b3893af5f0b45e06f2934f73f5dc34f2e9e54fc4d50a51cc47195f19089 [root@tang opt]# docker load &lt; /opt/centos6.tar.gz #导入 [root@tang opt]# docker load --input /opt/centos6.tar.gz #导入 #以上两种导入方法都可以 [root@tang opt]# docker tag centos6 centos6_x86 #改名 将镜像上传到dockerhub官网需要提前注册dockerhub账号 1. docker hub 帐号在本地验证登陆: [root@tang opt]# docker login Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one. Username: tangxiaoyue Password: Login Succeeded 2. docker push 镜像到docker hub 的仓库 docker push &lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt; [root@tang ~]# docker tag centos tangxiaoyue/centos_tang:latest [root@tang ~]# docker push tangxiaoyue/centos_tang The push refers to a repository [docker.io/tangxiaoyue/centos_tang] 9b198ff9ff5b: Mounted from library/centos latest: digest: sha256:be5b4a93f116a57ab3fd454ada72421eac892a3a4925627ac9a44f65fcd69cf8 size: 529]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法大全]]></title>
      <url>%2F2017%2F03%2F11%2FMarkdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[题记：随着Markdown语言的热度不断提升，越来越多的人喜欢使用Markdown这种简洁、便宜的语言来编辑自己的blog、文章。下面笔者就一些简单常用的Markdown语句进行介绍，希望对大家在进行Markdown语言编辑自己的文章时有所帮助。 1.斜体和粗体 代码： 1. *斜体*或_斜体_ 2. **粗体** 3. ***加粗斜体*** 显示效果： 这是一段斜体 这是一段粗体 这是一段加粗斜体 2.分级标题 第一种写法： 1.这是一个一级标题 2.================ 3. 4. 这是一个一级标题 5. -------------------------- 第二种写法： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3.超链接行内式 代码： 1.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk) 2. 3.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk &quot;梵居闹市&quot;) 显示效果： 欢迎来到梵居闹市欢迎来到梵居闹市 参考式 代码： 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]: http://www. google.com &quot;Google&quot; [2]:http://www. leanote.com &quot;Leanote&quot; [3]:http://http:/ /blog.leanote.com/freewalk &quot;梵居闹市&quot; [网站]:http: //http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 自动链接 代码： &lt;http://example.com/&gt; &lt;address@example.com&gt; 显示效果： http://example.com/&#x61;&#100;&#x64;&#114;&#101;&#115;&#x73;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d; 4.锚点 代码： 跳转到[目录](#index) 显示效果： 跳转到目录 5.列表无序列表 使用 *，+，- 表示无序列表。 代码： 无序列表项 一 无序列表项 二 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表 代码： 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 列表缩进 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 包含段落的列表 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表 代码： * 阅读的方法:（一个空格） &gt; 打开书本。 &gt; 打开电灯。 显示效果： 阅读的方法: 打开书本。打开电灯。 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 一列表项包含一个列表区块： &lt;代码写在这&gt; 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 会显示成： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 1986\. What a great season. 会显示成：1986. What a great season. 6. 引用 代码： &gt; 这是一个有两段文字的引用, &gt; 无意义的占行文字1. &gt; 无意义的占行文字2. &gt; &gt; 无意义的占行文字3. &gt; 无意义的占行文字4 显示效果： 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4. 引用的多层嵌套 代码： &gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白 &gt;&gt; 自己看教程！ - 愤青 &gt; 教程在哪？ - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 引用其它要素 代码： &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 显示效果： 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像行内式 代码： 高圆圆： ![高圆圆](ht tp://pic2016.5442.com:82/2015/1117/16/7.jpg%21960.jpg &quot;高圆圆&quot;) 显示效果 高圆圆： 8. 内容目录 markdownpad居然不支持该语法，我就呵呵了. 代码： [TOC]0.目录 [TOC]1. 斜体和粗体 [TOC]2. 分级标题 [TOC]3. 超链接 [TOC] 行内式 [TOC] 参考式 [TOC] 自动链接 [TOC]4. 锚点 9. 注脚 代码： 使用 Markdown[1]可以效率的书写文档,你可以使用 Leanote[Le] 编辑器进行书写。 [1]:Markdown是一种纯文本标记语言 [Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果： 使用 Markdown1可以效率的书写文档,你可以使用 LeanoteLe 编辑器进行书写。 原文链接：http://blog.leanote.com/post/freewalk/Markdown-语法手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（9）--Dockerfile]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89--Dockerfile%2F</url>
      <content type="text"><![CDATA[使用Dockerfile构建nginxDockerfile是由一行命令和语句组成的 Dockerfile构建步骤： [root@tang /]# mkdir /dockerfile/nginx -p 我们要在nginx目录上自动化创建一个nginx镜像 注意：D需要大写，当我们构建dockerfile的时候，docker默认会在我们当前目录读取一个名为Dockerfile的文件。这时候的D必须大写 [root@tang nginx]# cat Dockerfile # This Dockerfile # My Name is TangXiaoyue # Base image FROM centos # Maintainer MAINTAINE tang 1060336375@qq.com #Commands RUN rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm RUN yum install -y nginx &amp;&amp; yum clean all RUN echo &quot;daemon off;&quot; &gt;&gt;/etc/nginx/nginx.conf ADD index.html /usr/share/nginx/html/index.html EXPOSE 80 CMD [&quot;nginx&quot;] #井号代表注释 #Base image 除了注释的第一行，必须是FROM，意思就是我们需要告诉dockerfile基础镜像是什么 #Maintainer 维护信息 #Commands 命令 #ADD index.html 这个文件需要我们在当前目录下有才可以，我们配置我们可以准备好，然后使用ADD命令进行添加或修改 EXPOSE 对外端口号 CMD [“nginx”] 它要启动的命令是nginx （就算是nginx服务） 我们写好dockerfile还需要一个index.html [root@tang nginx]# echo TangXiaoyue &gt;index.html [root@tang nginx]# ll total 8 -rw-r--r-- 1 root root 364 Apr 2 20:50 Dockerfile -rw-r--r-- 1 root root 12 Apr 2 20:52 index.html 使用docker build进行构建 [root@tang ~]# docker build -t nginx_test:v1 /dockerfile/nginx/ [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx_test v1 bc69ee414a0f 17 seconds ago 280.7 MB 启动镜像 [root@tang ~]# docker run --name nginx_test -d -p 82:80 nginx_test:v1 7a02c27a0a04d34eec8f858e35848416b95572dbb1f485310caee5c185d2e426 [root@tang ~]# curl 127.0.0.1:82 TangXiaoyue Dockerfile参数解释FROM格式：FROM&lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;。 解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。 然后后面的其它指令FROM的镜像中执行。 MAINTAINER格式：MAINTAINER &lt;name&gt; 解释：指定维护者信息。 RUN格式：RUN &lt;command&gt;或 RUN[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。 解释：运行命令，命令较长使可以使用\来换行。推荐使用上面数组的格式 CMD格式： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式； CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用； CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT的默认参数； 解释： CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。 如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。 ENTRYPOINT格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;] ENTRYPOINT command param1 param2（shell中执行）。 解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。 ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。 所以生产实践中我们可以同时使用ENTRYPOINT和CMD， 例如： ENTRYPOINT [&quot;/usr/bin/rethinkdb&quot;] CMD [&quot;--help&quot;] USER格式：USER daemon 解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。 EXPOSE格式：EXPOSE&lt;port&gt; [&lt;port&gt;...] 解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。 ENV格式：ENV&lt;key&gt; &lt;value&gt; ENV &lt;key&gt;=&lt;value&gt; ... 解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定 ADD格式： ADD &lt;src&gt;... &lt;dest&gt; ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 解释： 将指定的&lt;src&gt;复制到容器文件系统中的&lt;dest&gt; 所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0 如果文件是可识别的压缩格式，则docker会帮忙解压缩 VOLUME格式：VOLUME [&quot;/data&quot;] 解释：可以将本地文件夹或者其他container的文件夹挂载到container中。 WORKDIR格式：WORKDIR/path/to/workdir 解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。 可以多次切换(相当于cd命令)， 也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如: WORKDIR /a WORKDIR b WORKDIR c RUN pwd 则最终路径为 /a/b/c。 ONBUILDONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行 ARG格式：ARG&lt;name&gt;[=&lt;default value&gt;] 解释：ARG指定了一个变量在docker build的时候使用， 可以使用--build-arg &lt;varname&gt;=&lt;value&gt;来指定参数的值，不过如果构建的时候不指定就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql 启动慢查询日志（不用重启）]]></title>
      <url>%2F2017%2F03%2F11%2FMysql%20%E5%90%AF%E5%8A%A8%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[1. 查看mysql系统参数 mysql&gt; show variables like &quot;%slow%&quot;; +---------------------------+-------------------------------+ | Variable_name | Value | +---------------------------+-------------------------------+ | log_slow_admin_statements | OFF | | log_slow_slave_statements | OFF | | slow_launch_time | 2 | | slow_query_log | OFF | | slow_query_log_file | /mysql/data/nagiosdb-slow.log | +---------------------------+-------------------------------+ 5 rows in set (0.00 sec) slow_query_log： off关闭状态 on开启状态 slow_launch_time 默认超过2s为慢查询 slow_query_log_file 慢查询日志存放地点 这三个参数，在不同的mysql版本中，不太一样，不过都可以通过 show variables like &quot;%slow%&quot; 查看出来 2. 运行如下命令即可运行慢查询日志mysql&gt; set global slow_query_log=ON; Query OK, 0 rows affected (0.03 sec) mysql&gt; set global slow_launch_time=5; Query OK, 0 rows affected (0.00 sec) mysql&gt; show variables like &quot;%slow%&quot;; +---------------------------+-------------------------------+ | Variable_name | Value | +---------------------------+-------------------------------+ | log_slow_admin_statements | OFF | | log_slow_slave_statements | OFF | | slow_launch_time | 5 | | slow_query_log | ON | | slow_query_log_file | /mysql/data/nagiosdb-slow.log | +---------------------------+-------------------------------+ 5 rows in set (0.00 sec) mysql 5.1.6版本起，slow_query_log 和 slow_launch_time 支持写文件或写数据库表两种方式，并且日志的开启，输出方式的修改，都可以在global级别动态修改。 只需简单通过set global slow_query_log=ON;即可开启慢查询，而不需要重启数据库！ 3. 可以直接写到配置文件中 my.cnfslow_query_log_file=/mysql/log/nagiosdb-slow.log slow_launch_time=5 可以完成配]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql的二进制日志binlog的模式说明]]></title>
      <url>%2F2017%2F03%2F11%2FMysql%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97binlog%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[1.Row日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况。 优点： 在row模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了， 所以row的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程和function，以及trigger的调用和出发无法被正确复制问题。 缺点： 在row模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。 mysql&gt; insert into username(username) select * from aa; ERROR 1146 (42S02): Table &apos;test.username&apos; doesn&apos;t exist mysql&gt; insert into user(username) select * from aa; Query OK, 1 row affected (0.01 sec) Records: 1 Duplicates: 0 Warnings: 0 查看binlog root@xuebinbin:/vobiledata/mysqllog# mysqlbinlog mysql-bin.000017 BINLOG &apos; 63EfUBNQAAAALgAAAA8CAAAAAA8AAAAAAAEABHRlc3QABHVzZXIAAgIPAi0AAA== 63EfUBdQAAAAJgAAADUCAAAAAA8AAAAAAAEAAv/8BAAFYmFveXU= &apos;/*!*/; ### INSERT INTO test.user ### SET ### @1=4 /* SHORTINT meta=0 nullable=0 is_null=0 */ ### @2=&apos;baoyu&apos; /* VARSTRING(45) meta=45 nullable=0 is_null=0 */ # at 565 #120806 0:27:39 server id 80 end_log_pos 592 Xid = 20 COMMIT/*!*/; DELIMITER ; # End of log file ROLLBACK /* added by mysqlbinlog */; /*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/; 由此可见，row模式是针对每一行的数据，而于关联表无关，它把关联中的相应数据记录在log中。这样一来会产生大量的数据。 2.statement每一条会修改数据的sql都会记录到master的binlog中，slave在复制的时候sql进程会解析成和原来master端执行多相同的sql再执行 。 优点： 在statement模式下首先就是解决了row模式的缺点，不需要记录每一行数据的变化减少了binlog日志量，节省了I/O以及存储资源，提高性能。因为他只需要激励在master上所执行的语句的细节一届执行语句时候的上下的信息。 缺点： 在statement模式下，由于他是记录的执行语句，所以，为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。 另外就是，由于mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement中，目前已经发现不少情况会造成Mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现， 比如：sleep()函数在有些版本中就不能被正确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。 由于row是基于每一行来记录的变化，所以不会出现，类似的问题。 mysql&gt; insert into user(username) values(&apos;xuebinbin&apos;); ERROR 1598 (HY000): Binary logging not possible. Message: Transaction level &apos;READ-COMMITTED&apos; in InnoDB is not safe for binlog mode &apos;STATEMENT&apos; mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ -&gt; ; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into user(username) values(&apos;xuebinbin&apos;); Query OK, 1 row affected (0.00 sec) 查看binlog root@xuebinbin:/vobiledata/mysqllog# mysqlbinlog mysql-bin.000008 BEGIN /*!*/; # at 174 #120806 14:47:35 server id 80 end_log_pos 202 Intvar SET INSERT_ID=2/*!*/; # at 202 #120806 14:47:35 server id 80 end_log_pos 311 Query thread_id=5 exec_time=0 error_code=0 use test/*!*/; SET TIMESTAMP=1344235655/*!*/; insert into user(username) values(&apos;xuebinbin&apos;) /*!*/; # at 311 #120806 14:47:35 server id 80 end_log_pos 338 Xid = 20 COMMIT/*!*/; # at 338 #120806 14:53:18 server id 80 end_log_pos 357 Stop DELIMITER ; # End of log file ROLLBACK /* added by mysqlbinlog */; /*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/; 结果发现statement是以sql记录形式记录的。这样的话一个sql就只记录一条，减少了大量的数据存储。 3.Mixed（该模式是STATEMENT和ROW的混合使用。）早起的MySQL一直都只有基于statemen 的复制模式，直到5.1.5版本的MySQL才开始支持row 复制。从5.0 开始，MySQL的复制已经解决了大量老版本中出现的无法正确复制的问题。但是由于存储过程的出现，给 MySQL Replication 又带来了更大的新挑战。 从5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。 在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。 新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，并不是所有的修改都会以 row 模式来记录， 比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo常用命令]]></title>
      <url>%2F2017%2F03%2F11%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Hexo部署步骤 npm install npm install hexo-deployer-git --save hexo new &quot;新页面&quot; hexo clean hexo generate hexo deploy Hexo常用命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令的简写为： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五分钟商学院--大纲]]></title>
      <url>%2F2016%2F09%2F25%2F%E4%BA%94%E5%88%86%E9%92%9F%E5%95%86%E5%AD%A6%E9%99%A2--%E5%A4%A7%E7%BA%B2%2F</url>
      <content type="text"><![CDATA[商业四大体系合体。 1）商业，你与企业外部的关系；2）管理，你与企业内部的关系；3）个人，你与自己的关系；4）以及提升前三者的：工具。 商业篇消费心理学1.心理账户2.沉没成本3.比例偏见4.损失规避5.价格锚点 商业世界五大基础逻辑6.流量之河7.倍率之刀8.价量之秤9.风险之眼10.规则之缝 互联网世界五大基本定律11.信息对称12.平台经济13.边际成本14.长尾理论15.免费理论 行为经济学16.结果偏见17.适应性偏见18.鸡蛋理论19.概率偏见20.凡勃伦效应 微观经济学21.供需理论22.边际效用23.机会成本24.代理两难25.科斯定理 宏观经济学26.节约悖论27.张维迎林毅夫之争28.人口抚养比29.经济泡沫30.福利经济 金融法律31.风险投资32.公司的形态：有限责任，合伙企业，个人独资33.期权（员工激励方案）34.庞氏骗局35.互联网金融 市场营销 Product36.产品定位37.自我认知38.极致单品39.三驾马车40.最小可用品 市场营销 Price41.渗透定价法42.组合定价法43.撇脂定价法44.价格歧视45.客户自定价 市场营销 Promotion46.定位营销47.饥饿营销48.死亡之井49.危机公关50.独特的销售主张-USP 市场营销 Place51.深度分销52.直接销售53.虚实结合54.社区商务55.反向定制 市场营销 互联网营销56.社群经济57.口碑经济（POE理论）58.粉丝经济59.引爆点60.红利理论 所有现象背后都有商业逻辑61.运动对赌62.雇佣客户63.服务行业美女越多，经济越不景气64.狩猎式 vs 农耕式65.稳定平衡态 vs 不稳定平衡态 管理篇管理选人66.上下车法则67.奥格尔维定律68.首因效应/光环效应69.特雷默定律70.重视面试被拒的人 管理育人71.蘑菇定律72.师傅制73.情境领导II74.鲶鱼效应75.贝尼斯定理 管理用人76.不值得定律77.懒蚂蚁效应78.热炉法则79.拜伦法则80.波特定律 管理留人81.酒与污水定律82.格雷欣法则（劣币驱逐良币）83.雷尼尔效应84.南风法则85.离职面试 管理就是激励需求理论86.马斯洛人类需求五层次理论-生理87.马斯洛人类需求五层次理论-安全88.马斯洛人类需求五层次理论-归属89.马斯洛人类需求五层次理论-尊重90.马斯洛人类需求五层次理论-实现 管理就是激励其他理论91.卡诺满意度模型92.赫兹伯格的双因素激励理论93.亚佛斯德原则（期望理论）94.马蝇效应95.波什定律 从员工到经理96.古狄逊定理97.吉格勒定理98.刺猬法则99.目标置换效应100.篮球架子原理 管理1101.崔西定律102.蓝柏格定理103.阿什定律104.彼得斯定律105.超限效应 管理2106.奥卡姆剃刀定律107.法约尔原则（责权利心法）108.例外原则109.洛克忠告110.海恩法则 管理3111.波特法则112.卡贝定律113.飞轮效应114.墨菲定律115.克里夫兰法则 团队合作116.球队，交响乐队，军队117.木桶定律118.多样性（异性效应）119.苛希纳定律120.蚁群效应 项目管理121.作战指挥室122.关键路径123.范围、时间、资源的金三角124.风险管理（已知的未知风险）125.权利来源：专业 管理常见病126.破窗效应127.旁观者效应128.帕金森定律129.彼得原理130.手表定律 个人篇高效能人士的七种习惯131.范式转变132.情感账户133.积极主动134.以终为始135.要事第一 高效能人士的七种习惯136.双赢思维137.知彼解己138.统合综效139.不断更新140.找到心声 时间管理141.时间成本142.GTD143.猴子理论144.三八理论145.番茄钟 职业素养146.如何打招呼147.如何吃西餐148.如何和老板一起坐车149.如何搭配衣服150.邮件礼仪 学习能力151.幸存者偏见152.库博经验学习圈153.知识、技能、态度154.学习小组（私人董事会）155.如何最快速的学习 思考能力156.六顶思考帽157.批判性思维/辩证思维158.系统思维-关联的、整体的、动态的159.正向思维160.逆向思维 逻辑思维161.偷换概念-同一律162.自相矛盾-矛盾律163.模棱两可-排中律164.三段论165.归纳法与黑天鹅事件 谈判能力166.吉普赛陷阱167.定位调整偏见168.有限的权利 &amp; 不露面的人169.战略延迟 &amp; 最终期限170.吃惊 &amp; 撤退 情感能力171.元能力：同理心172.元能力：自我认知（卢维斯定理）173.元能力：自我控制174.元能力：自我激励175.元能力：人际关系处理 演讲能力176.导游心法177.注意力法则178.空中加油179.案例和幽默感180.打透 沟通能力181.快乐痛苦四原则182.亨利法则183.踢猫效应184.电梯测验185.如何问出好问题 创新能力186.创新者的窘境187.人无我有，人有我优，人优我廉……188.达维多定律189.路径依赖190.比伦定律 领导能力191.远（后喻文明）192.小（科斯定理）193.变（企业生命周期）194.快（快鱼吃慢鱼）195.专（网状激活系统） 战略篇战略工具196.麦肯锡·MECE法197.波特·五力模型198.波士顿矩阵199.金字塔原理200.通用电器矩阵 战略工具201.正态分布理论202.逻辑树/决策树203.平衡计分表204.SWOT模型205.麦肯锡·七步成诗法 博弈工具206.纳什均衡207.囚徒困境208.贝叶斯均衡209.智猪博弈210.公地悲剧 博弈工具211.你分我拿212.拍卖逻辑213.零和游戏原理214.拍卖美元215.用餐者困境 决策工具216.儒佛尔定律217.吉德林法则218.布利丹效应219.羊群效应220.麦穗哲理 创新工具221.减法创新222.除法创新223.乘法创新224.任务统筹策略225.属性依存策略 管理工具226.OKR227.MBTI人格理论（自我管理）228.SMART原则（目标管理）229.PDCA循环规则（项目管理）230.5W2H法（目标管理） 思考工具231.头脑风暴法232.思考工具：白板233.思维导图234.5WHY分析法235.复盘 沟通工具236.有效的1：1237.罗伯特议事规则238.白板墙、低隔板、下午茶和即时贴239.拉波波特评论规则240.结构沟通法 财务工具241.财务分析中的五力分析法242.零基预算？243.本福特定律244.独立P&amp;L245.计算企业价值 营销工具246.直播营销247.Focus Group248.STP249.4C250.4P 未来已来256.零边际成本社会257.奇点临近258.比特币259.基因科技260.人工智能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[精英日课--精英的见识和我们的时代]]></title>
      <url>%2F2016%2F08%2F09%2F%E7%B2%BE%E8%8B%B1%E6%97%A5%E8%AF%BE--%E7%B2%BE%E8%8B%B1%E7%9A%84%E8%A7%81%E8%AF%86%E5%92%8C%E6%88%91%E4%BB%AC%E7%9A%84%E6%97%B6%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[1 马斯洛的理论说，人的需求像个金字塔，是有不同层次的。底层是生理和安全，往上是爱、尊重和自我实现。满足了底层，就会有高层的需求，就好像罗胖说的“等钱多到没意义了，别的意义就出来了”。 马斯洛的理论一直有争议，但是你得承认，它很好的描述了人与人之间的差距。有的人认为最微小的物质比什么都重要，有的人却在追求自我实现。他们之前的差别，当然不仅仅是钱多钱少，更重要的显然是认知上。 这个认知不是智商。人的智商和身高一样，是正态分布，再高也高不到哪去；可是人的成就却是幂律分布的–是一系列苦练和正反馈积累的结果–差距如同云泥。 成就到了一定程度，你就算吧她所有的资源都拿走，他想必还是像能穿越小说里的主人公干一番大事，因为他已经积累了大量的智识。 智慧和见识。大人物应该有什么样的见识呢？ 2 美苏冷战期间，双方曾经有过一些表示友好的举动，比如在对方国家办展览。1959年苏联搞了一个美国展，其中展示了美式的大房子，里面各种家用电器。苏联宣传说这种生活是一般美国人享受不到的 ，但其实那就是美国普通中产阶级生活水准没错，电冰箱早在1920年就已经在美国家庭普及了。 当时尼克松作为美国副总统访问苏联，跟赫鲁晓夫一起参观了这个美国展。二人走进美式样板房，尼克松看里面有个洗衣机，他找到了一个话题灵感。 尼克松说，咱们两国为什么非得高火箭竞争呢，咱们制造洗衣机不是更好吗？ 可是赫鲁晓夫有完全不同的思路。赫鲁晓夫说，你们美国人不要以为苏联人没见过洗衣机，其实我们苏联每个新房都有洗衣机–而且我们的洗衣机都是一样的，不像你们资本主义搞各种不同型号的洗衣机，这不纯属浪费吗？ 这就是史上著名的“厨房辩论”，尼克松因为这个辩论拿到了很多高分形象。现在我们可以判定，赫鲁晓夫在这场辩论中完败。中间有个小花絮是尼克松说美国将会让每个家庭都拥有一辆汽车，赫鲁晓夫可能太过急于找回场子，竟说那苏联就能让每个家庭都拥有一架飞机！尼克松马上反应，你想把飞机停在哪？ 1959年的时间，各国正在从传统向现代化演变。赫鲁晓夫在别的方面可能才智过人，在一个更传统场合肯定游刃有余–但是面对“现代界”，竟然没有一个最基本的见识。 这是因为现代化的见识不是常说 3 就算生活在发达国家，也不是所有人都有现代化思维。 美国社会科学家Herbert Gant曾经有个研究，比较了波士顿工薪阶层和精英阶层的文化差异。他发现工薪阶层的一个特点是只相信自己的亲友，二非常不信任外部世界，甚至可能对陌生人有一种自发的敌意。他把这些人成为“都市村民”住在都市里，却仍然都是村名思维。 对比之下，中产精英阶层的人没有那么强烈的亲缘意识，他们很容易跟陌生人合作，而且非常信任办事规则。 对比今日的中国这个现象不是很明显吗？小城镇里人们特别讲亲属和熟人关系，没有关系寸步难行，这也是为什么有理想的年轻人非得去大城市！什么叫发达？什么叫精英？真正的差距是思维模式。 像这样的差异我们还可以列举很多–请允许我用“精英”和“普通人”来标记这两种思维。 精英能够理解复杂的抽象概念，而普通人处处使用简单形象逻辑 精英探索未知，而普通人恐惧未知 精英从长远打算，而普通人缺乏自控 精英注重个人选择和自由–尼克松真是用这一点说明美国需要不同型号的洗衣机，而普通人认为别人应该更自己一样。 精英拥抱改变，而普通人拒绝改变 精英跟各个阶层的人都有交往，而普通人只跟本阶层的人交往 精英爱谈论想法，而普通人爱谈论人和东西 精英吧自由时间花在学习上，而普通人把自由时间花在娱乐上….. 等等等等。还有一个区别值得特别提一下，那就是精英注重效率，而普通人注重公平。 现在世界的一个趋势是贫富差距越来越大，而精英对此根本不在于。这是为什么“精英”，所谓“1%”，在美国已经几乎是个贬义词。 问题在于，如果精英比普通人仅仅强在他是个富二代或者官二代，我们完全有权鄙视他们–可如果精英的成功是基于努力程度和见识水平，那我们的道德优越感还有多大的意义呢？ 4 好在中国，“精英”目前可能还是个好词。 中国不但跟美国搞洗衣机竞争，而且正在取胜。但美国中产阶级日渐萎缩的这个时代，中国中产阶级正在高速崛起。有人说非得有房有车或者年薪百万才叫中产阶级，在我看来纯属夸张。只要马斯洛金字塔的顶层攀登，自我实现的需求，就是中产。 我们从来没给冰箱加过锁，经常网上分享家里的宠物猫的照片，无论在工作还是消费上都有多种选择，而且正在追求更大的作为。 所以我们想向精英学习。既然现代世界跟我们的直觉，跟心灵鸡汤，跟寓言故事和成语故事都非常不同，我们就想用精英的眼光和思维方式去理解、玩转、和改变这个世界。 最好的办法就是亲身参与，而最快的办法则是读书。 互联网也不知是幸运还是不幸，我们正好赶上了互联网时代。 5 在这个本来最需要读书的时代，因为有了互联网，人们不爱读书了。 所谓“互联网上知识丰富”，其实是个假象，大多数人在网上接触到的内容极其有限。如果有关现代化的见识是一片汪洋大海，我们每天在新闻、论坛、微博和朋友圈看到的东西，大约相当于海滩上几个漂亮的贝壳。 最新奇的东西在哪里？最刺激的东西在哪里？最野性的东西在哪里？它们和最有用，最深刻，最高妙的东西在一起，在书里，在小众刊物里，在论文里。想要得到这些东西，你得下海。 这些更好的东西没有流行，一是因为下海需要大量的智识积累和时间成本，二是因为它们的生产者不知道怎么跟读者说话。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XtraBackup主从复制及备份]]></title>
      <url>%2F2016%2F03%2F10%2FXtraBackup%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A4%87%E4%BB%BD%2F</url>
      <content type="text"><![CDATA[XtraBackup备份1、yum安装mysql（以centos7为例） ###主从操作一致 #查看操作系统版本： [root@node2 ~]# cat /etc/redhat-release CentOS Linux release 7.0.1406 (Core) #关闭防火墙和seLinux [root@node2 ~]# systemctl stop firewalld [root@node2 ~]# sed -i &quot;s#SELINUX=enforcing#SELINUX=disabled#g&quot; /etc/selinux/config [root@node2 ~]# setenforce 0 #yum安装mysql wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server systemctl start mysql.service mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); ###配置主从 主： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=1 从： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=2 2、安装xtrabackup备份软件（主从进行安装） wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.3.4/binary/redhat/6/x86_64/percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y epel-release yum localinstall percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y perl-Time-HiRes #查看版本 &gt;select version(); #查看前默认的存储引擎 &gt;show variables like &apos;%storage_engine%&apos;; 3、导入数据（为了模拟比较真实可以往主库导入数据）（主库操作） #导入bubi_api数据库 [root@node2 opt]# mysql -uroot -ppassword &lt; bubi_api.sql # 查看数据大小 &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed &gt; select concat(round(sum(data_length/1024/1024),2),&apos;MB&apos;) as data from tables; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.04 sec) 4、数据库备份（主操作） ###备份 [root@node2 opt]# mkdir /extrabackup [root@node2 opt]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=bubi --parallel=4 /mnt/resource/extrabackup ###出现completed OK! 表示备份成功 语法解释：–user=数据库用户 –password=数据库密码 –socket=指定socket –default-file=指定配置文件 - 最后面是存放位 ###保持事务一致（主操作） [root@node2 2017-02-17_14-45-11]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --parallel=4 --apply-log /extrabackup/2017-02-17_14-45-11/ ###出现completed OK!表示事务保持了一致，可以用于恢复 二、mysql主从同步操作 1、传输数据、将/extrabackup/2017-02-17_14-45-11/拷贝到从库 [root@node2 extrabackup]# scp -r 2017-02-17_14-45-11 root@192.168.1.13:/extrabackup/ 2、从库恢复数据 [root@node3 extrabackup]# ll 总用量 0 drwx------. 4 root root 47 2月 17 14:47 2017-02-17_14-45-11 #停止mysql [root@node3 extrabackup]# systemctl stop mysql #清空mysql data目录 [root@node3 extrabackup]# cd /var/lib/mysql [root@node3 mysql]# mv * /opt/mysqlbak/ #数据恢复 innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --copy-back /extrabackup/2017-02-17_11-49-35/ ###出现completed OK! 表示恢复成功 #还原权限 [root@node3 mysql]# cd .. [root@node3 lib]# chown mysql:mysql mysql -R #重启mysql并查看数据的大小 [root@node3 lib]# systemctl start mysql [root@node3 lib]# ps -ef | grep mysql mysql 8173 1 0 14:59 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe --basedir=/usr mysql 8338 8173 3 14:59 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sock root 8364 5840 0 15:00 pts/0 00:00:00 grep --color=auto mysql &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.26 sec) ###数据主从大小都一样 3、mysql主从同步操作 ###主库授权 &gt; GRANT REPLICATION SLAVE ON *.* TO &apos;rep&apos;@&apos;192.168.1.13&apos; IDENTIFIED BY &apos;123456&apos;; &gt;FLUSH PRIVILEGES; ###从库开启同步 [root@node3 mysql]# cat /extrabackup/2017-02-17_14-45-11/xtrabackup_binlog_info mysql-bin.000001 171510867 CHANGE MASTER TO MASTER_HOST=&apos;10.25.159.23&apos;, MASTER_USER=&apos;rep&apos;, MASTER_PASSWORD=&apos;db0226&apos;, MASTER_PORT=3306, MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;, MASTER_LOG_POS=982559769; ####在还没同步之前我们可以在主库继续增加入一个库，验证不锁表是否可以同步 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) #####开启主从同步 &gt;flush logs; &gt; start slave; ###从库操作 &gt; show slave status\G Slave_IO_Running: Yes Slave_SQL_Running: Yes ##查看从库数据 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) 注意： 1、当从库停掉了（宕机还没测试）。主库继续写入数据，从库开启时，会自动同步 ##########mysql命令 #查看binlog是否开启 &gt;show binary logs; #查看serverid &gt;show variables like &apos;server_id&apos;; #查看binlog模式 &gt;show variables like &apos;%log%&apos;; &gt;/dev/null 2&gt;&amp;1]]></content>
    </entry>

    
  
  
</search>
