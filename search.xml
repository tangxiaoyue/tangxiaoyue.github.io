<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[100个大数据名词和术语汇总]]></title>
      <url>%2F2017%2F05%2F05%2F100%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%90%8D%E8%AF%8D%E5%92%8C%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[数据的出现带来了许多新的术语，但这些术语往往比较难以理解。因此，我们通过本文给出一个常用的大数据术语表，抛砖引玉，供大家深入了解，部分定义参考了相应的博客文章。 A聚合 (Aggregation) – 搜索、合并、显示数据的过程算法 (Algorithms) – 可以完成某种数据分析的数学公式分析法 (Analytics) – 用于发现数据的内在涵义异常检测 (Anomaly detection)– 在数据集中搜索与预期模式或行为不匹配的数据项。除了“Anomalies”,用来表示异常的词有以下几种：outliers, exceptions, surprises, contaminants.他们通常可提供关键的可执行信息匿名化 (Anonymization) – 使数据匿名，即移除所有与个人隐私相关的数据应用 (Application)– 实现某种特定功能的计算机软件人工智能 (Artificial Intelligence) – 研发智能机器和智能软件，这些智能设备能够感知周遭的环境，并根据要求作出相应的反应，甚至能自我学习。 B行为分析法 (Behavioural Analytics) – 这种分析法是根据用户的行为如“怎么做”，“为什么这么做”，以及“做了什么”来得出结论，而不是仅仅针对人物和时间的一门分析学科，它着眼于数据中的人性化模式大数据科学家 (Big Data Scientist) – 能够设计大数据算法使得大数据变得有用的人大数据创业公司 (Big data startup) – 指研发最新大数据技术的新兴公司生物测定术 (Biometrics) – 根据个人的特征进行身份识别B字节 (BB: Brontobytes) – 约等于1000 YB(Yottabytes)，相当于未来数字化宇宙的大小。1 B字节包含了27个0！商业智能 (Business Intelligence) – 是一系列理论、方法学和过程，使得数据更容易被理解 C分类分析 (Classification analysis) – 从数据中获得重要的相关性信息的系统化过程; 这类数据也被称为元数据(meta data),是描述数据的数据云计算 (Cloud computing) – 构建在网络上的分布式计算系统，数据是存储于机房外的（即云端）聚类分析 (Clustering analysis) – 它是将相似的对象聚合在一起，每类相似的对象组合成一个聚类(也叫作簇)的过程。这种分析方法的目的在于分析数据间的差异和相似性冷数据存储 (Cold data storage) – 在低功耗服务器上存储那些几乎不被使用的旧数据。但这些数据检索起来将会很耗时对比分析 (Comparative analysis) – 在非常大的数据集中进行模式匹配时，进行一步步的对比和计算过程得到分析结果复杂结构的数据 (Complex structured data) – 由两个或多个复杂而相互关联部分组成的数据，这类数据不能简单地由结构化查询语言或工具(SQL)解析计算机产生的数据 (Computer generated data) – 如日志文件这类由计算机生成的数据并发 (Concurrency) – 同时执行多个任务或运行多个进程相关性分析 (Correlation analysis) – 是一种数据分析方法，用于分析变量之间是否存在正相关，或者负相关客户关系管理 (CRM: Customer Relationship Management)– 用于管理销售、业务过程的一种技术，大数据将影响公司的客户关系管理的策略 D仪表板 (Dashboard) – 使用算法分析数据，并将结果用图表方式显示于仪表板中数据聚合工具 (Data aggregation tools) – 将分散于众多数据源的数据转化成一个全新数据源的过程数据分析师 (Data analyst) – 从事数据分析、建模、清理、处理的专业人员数据库 (Database) – 一个以某种特定的技术来存储数据集合的仓库数据库即服务 (Database-as-a-Service) – 部署在云端的数据库，即用即付，例如亚马逊云服务 (AWS: Amazon Web Services)数据库管理系统 (DBMS: Database Management System) – 收集、存储数据，并提供数据的访问数据中心 (Data centre) – 一个实体地点，放置了用来存储数据的服务器数据清洗 (Data cleansing) – 对数据进行重新审查和校验的过程，目的在于删除重复信息、纠正存在的错误，并提供数据一致性数据管理员 (Data custodian) – 负责维护数据存储所需技术环境的专业技术人员数据道德准则 (Data ethical guidelines) – 这些准则有助于组织机构使其数据透明化，保证数据的简洁、安全及隐私数据订阅 (Data feed) – 一种数据流，例如Twitter订阅和RSS数据集市 (Data marketplace) – 进行数据集买卖的在线交易场所数据挖掘 (Data mining) – 从数据集中发掘特定模式或信息的过程数据建模 (Data modelling) – 使用数据建模技术来分析数据对象，以此洞悉数据的内在涵义数据集 (Data set) – 大量数据的集合数据虚拟化 (Data virtualization) – 数据整合的过程，以此获得更多的数据信息，这个过程通常会引入其他技术，例如数据库，应用程序，文件系统，网页技术，大数据技术等等去身份识别 (De-identification) – 也称为匿名化(anonymization)，确保个人不会通过数据被识别判别分析 (Discriminant analysis) – 将数据分类；按不同的分类方式，可将数据分配到不同的群组，类别或者目录。是一种统计分析法，可以对数据中某些群组或集群的已知信息进行分析，并从中获取分类规则。分布式文件系统 (Distributed File System) – 提供简化的，高可用的方式来存储、分析、处理数据的系统文件存贮数据库 (Document Store Databases) – 又称为文档数据库(document-oriented database), 为存储、管理、恢复文档数据而专门设计的数据库，这类文档数据也称为半结构化数据 E探索性分析 (Exploratory analysis) – 在没有标准的流程或方法的情况下从数据中发掘模式。是一种发掘数据和数据集主要特性的一种方法E字节 (EB: Exabytes) – 约等于1000 PB(petabytes), 约等于1百万 GB。如今全球每天所制造的新信息量大约为1 EB提取-转换-加载 (ETL: Extract, Transform and Load) – 是一种用于数据库或者数据仓库的处理过程，天善学院有国内唯一的最全的 ETL 学习课程。即从各种不同的数据源提取(E)数据，并转换(T)成能满足业务需要的数据，最后将其加载(L)到数据库 F故障切换 (Failover) – 当系统中某个服务器发生故障时，能自动地将运行任务切换到另一个可用服务器或节点上容错设计 (Fault-tolerant design) – 一个支持容错设计的系统应该能够做到当某一部分出现故障也能继续运行 G游戏化 (Gamification) – 在其他非游戏领域中运用游戏的思维和机制，这种方法可以以一种十分友好的方式进行数据的创建和侦测，非常有效。图形数据库 (Graph Databases) – 运用图形结构(例如，一组有限的有序对，或者某种实体)来存储数据，这种图形存储结构包括边缘、属性和节点。它提供了相邻节点间的自由索引功能，也就是说，数据库中每个元素间都与其他相邻元素直接关联。网格计算 (Grid computing) – 将许多分布在不同地点的计算机连接在一起，用以处理某个特定问题，通常是通过云将计算机相连在一起。 HHadoop– 一个开源的分布式系统基础框架，可用于开发分布式程序，进行大数据的运算与存储。Hadoop 数据库 (HBase) – 一个开源的、非关系型、分布式数据库，与Hadoop框架共同使用HDFS – Hadoop 分布式文件系统 (Hadoop Distributed File System)；是一个被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统高性能计算 (HPC: High-Performance-Computing)– 使用超级计算机来解决极其复杂的计算问题 I内存数据库 (IMDB: In-memory) – 一种数据库管理系统，与普通数据库管理系统不同之处在于，它用主存来存储数据，而非硬盘。其特点在于能高速地进行数据的处理和存取。物联网 (Internet of Things)– 在普通的设备中装上传感器，使这些设备能够在任何时间任何地点与网络相连。 J法律上的数据一致性 (Juridical data compliance) – 当你使用的云计算解决方案，将你的数据存储于不同的国家或不同的大陆时，就会与这个概念扯上关系了。你需要留意这些存储在不同国家的数据是否符合当地的法律。 K键值数据库 (KeyValue Databases) – 数据的存储方式是使用一个特定的键，指向一个特定的数据记录，这种方式使得数据的查找更加方便快捷。键值数据库中所存的数据通常为编程语言中基本数据类型的数据。 L延迟 (Latency) – 表示系统时间的延迟遗留系统 (Legacy system) – 是一种旧的应用程序，或是旧的技术，或是旧的计算系统，现在已经不再支持了。负载均衡 (Load balancing) – 将工作量分配到多台电脑或服务器上，以获得最优结果和最大的系统利用率。位置信息 (Location data) – GPS信息，即地理位置信息。日志文件 (Log file) – 由计算机系统自动生成的文件，记录系统的运行过程。 MM2M数据 (Machine2Machine data) – 两台或多台机器间交流与传输的内容机器数据 (Machine data)– 由传感器或算法在机器上产生的数据机器学习 (Machine learning) – 人工智能的一部分，指的是机器能够从它们所完成的任务中进行自我学习，通过长期的累积实现自我改进。MapReduce – 是处理大规模数据的一种软件框架(Map: 映射，Reduce: 归纳)。大规模并行处理 (MPP: Massively Parallel Processing) – 同时使用多个处理器(或多台计算机) 处理同一个计算任务。元数据 (Metadata) – 被称为描述数据的数据，即描述数据数据属性(数据是什么)的信息。MongoDB – 一种开源的非关系型数据库(NoSQL database)多维数据库 (Multi-Dimensional Databases) – 用于优化数据联机分析处理(OLAP)程序，优化数据仓库的一种数据库。多值数据库 (MultiValue Databases) – 是一种非关系型数据库(NoSQL), 一种特殊的多维数据库：能处理3个维度的数据。主要针对非常长的字符串，能够完美地处理HTML和XML中的字串。 N自然语言处理 (Natural Language Processing) – 是计算机科学的一个分支领域，它研究如何实现计算机与人类语言之间的交互。网络分析 (Network analysis) – 分析网络或图论中节点间的关系，即分析网络中节点间的连接和强度关系。NewSQL – 一个优雅的、定义良好的数据库系统，比SQL更易学习和使用，比NoSQL更晚提出的新型数据库NoSQL – 顾名思义，就是“不使用SQL”的数据库。这类数据库泛指传统关系型数据库以外的其他类型的数据库。这类数据库有更强的一致性，能处理超大规模和高并发的数据。 O对象数据库 (Object Databases) – (也称为面象对象数据库)以对象的形式存储数据，用于面向对象编程。它不同于关系型数据库和图形数据库，大部分对象数据库都提供一种查询语言，允许使用声明式编程(declarative programming)访问对象.基于对象图像分析 (Object-based Image Analysis) – 数字图像分析方法是对每一个像素的数据进行分析，而基于对象的图像分析方法则只分析相关像素的数据，这些相关像素被称为对象或图像对象。操作型数据库 (Operational Databases) – 这类数据库可以完成一个组织机构的常规操作，对商业运营非常重要，一般使用在线事务处理，允许用户访问 、收集、检索公司内部的具体信息。优化分析 (Optimization analysis) – 在产品设计周期依靠算法来实现的优化过程，在这一过程中，公司可以设计各种各样的产品并测试这些产品是否满足预设值。本体论 (Ontology) – 表示知识本体，用于定义一个领域中的概念集及概念之间的关系的一种哲学思想。(译者注: 数据被提高到哲学的高度，被赋予了世界本体的意义，成为一个独立的客观数据世界)异常值检测 (Outlier detection) – 异常值是指严重偏离一个数据集或一个数据组合总平均值的对象，该对象与数据集中的其他它相去甚远，因此，异常值的出现意味着系统发生问题，需要对此另加分析。 P模式识别 (Pattern Recognition) – 通过算法来识别数据中的模式，并对同一数据源中的新数据作出预测P字节 (PB: Petabytes) – 约等于1000 TB(terabytes), 约等于1百万 GB (gigabytes)。欧洲核子研究中心(CERN)大型强子对撞机每秒产生的粒子个数就约为1 PB平台即服务 (PaaS: Platform-as-a-Service)– 为云计算解决方案提供所有必需的基础平台的一种服务预测分析 (Predictive analysis) – 大数据分析方法中最有价值的一种分析方法，这种方法有助于预测个人未来(近期)的行为，例如某人很可能会买某些商品，可能会访问某些网站，做某些事情或者产生某种行为。通过使用各种不同的数据集，例如历史数据，事务数据，社交数据，或者客户的个人信息数据，来识别风险和机遇隐私 (Privacy)– 把具有可识别出个人信息的数据与其他数据分离开，以确保用户隐私。公共数据 (Public data) – 由公共基金创建的公共信息或公共数据集。 Q数字化自我 (Quantified Self) – 使用应用程序跟踪用户一天的一举一动，从而更好地理解其相关的行为查询 (Query) – 查找某个问题答案的相关信息 R再识别 (Re-identification)– 将多个数据集合并在一起，从匿名化的数据中识别出个人信息回归分析 (Regression analysis) – 确定两个变量间的依赖关系。这种方法假设两个变量之间存在单向的因果关系(译者注：自变量，因变量，二者不可互换)RFID – 射频识别; 这种识别技术使用一种无线非接触式射频电磁场传感器来传输数据实时数据 (Real-time data) – 指在几毫秒内被创建、处理、存储、分析并显示的数据推荐引擎 (Recommendation engine)– 推荐引擎算法根据用户之前的购买行为或其他购买行为向用户推荐某种产品路径分析 (Routing analysis) – 针对某种运输方法通过使用多种不同的变量分析从而找到一条最优路径，以达到降低燃料费用，提高效率的目的 S半结构化数据 (Semi-structured data) – 半结构化数据并不具有结构化数据严格的存储结构，但它可以使用标签或其他形式的标记方式以保证数据的层次结构情感分析 (Sentiment Analysis) – 通过算法分析出人们是如何看待某些话题信号分析 (Signal analysis) – 指通过度量随时间或空间变化的物理量来分析产品的性能。特别是使用传感器数据。相似性搜索 (Similarity searches) – 在数据库中查询最相似的对象，这里所说的数据对象可以是任意类型的数据仿真分析 (Simulation analysis)– 仿真是指模拟真实环境中进程或系统的操作。仿真分析可以在仿真时考虑多种不同的变量，确保产品性能达到最优智能网格 (Smart grid) – 是指在能源网中使用传感器实时监控其运行状态，有助于提高效率软件即服务 (SaaS: Software-as-a-Service)– 基于Web的通过浏览器使用的一种应用软件空间分析 (Spatial analysis) – 空间分析法分析地理信息或拓扑信息这类空间数据，从中得出分布在地理空间中的数据的模式和规律SQL – 在关系型数据库中，用于检索数据的一种编程语言构化数据 (Structured data) -可以组织成行列结构，可识别的数据。这类数据通常是一条记录，或者一个文件，或者是被正确标记过的数据中的某一个字段，并且可以被精确地定位到。 TT字节 (TB: Terabytes) – 约等于1000 GB(gigabytes)。1 TB容量可以存储约300小时的高清视频。时序分析 (Time series analysis) – 分析在重复测量时间里获得的定义良好的数据。分析的数据必须是良好定义的，并且要取自相同时间间隔的连续时间点。拓扑数据分析 (Topological Data Analysis)– 拓扑数据分析主要关注三点：复合数据模型、集群的识别、以及数据的统计学意义。交易数据 (Transactional data) – 随时间变化的动态数据透明性 (Transparency) – 消费者想要知道他们的数据有什么作用、被作何处理，而组织机构则把这些信息都透明化了。 U非结构化数据 (Un-structured data) – 非结构化数据一般被认为是大量纯文本数据，其中还可能包含日期，数字和实例。 V价值 (Value)– (译者注：大数据4V特点之一) 所有可用的数据，能为组织机构、社会、消费者创造出巨大的价值。这意味着各大企业及整个产业都将从大数据中获益。可变性(Variability) – 也就是说，数据的含义总是在（快速）变化的。例如，一个词在相同的推文中可以有完全不同的意思。多样 (Variety) – (译者注：大数据4V特点之一) 数据总是以各种不同的形式呈现，如结构化数据，半结构化数据，非结构化数据，甚至还有复杂结构化数据高速 (Velocity) – (译者注：大数据4V特点之一) 在大数据时代，数据的创建、存储、分析、虚拟化都要求被高速处理。真实性 (Veracity) – 组织机构需要确保数据的真实性，才能保证数据分析的正确性。因此，真实性(Veracity)是指数据的正确性。可视化 (Visualization) – 只有正确的可视化，原始数据才可被投入使用。这里的“可视化”并非普通的图型或饼图，可视化指是的复杂的图表，图表中包含大量的数据信息，但可以被很容易地理解和阅读。大量 (Volume) – (译者注：大数据4V特点之一) 指数据量，范围从Megabytes至Brontobytes W天气数据 (Weather data) – 是一种重要的开放公共数据来源，如果与其他数据来源合成在一起，可以为相关组织机构提供深入分析的依据 XXML数据库 (XML Databases) – XML数据库是一种以XML格式存储数据的数据库。XML数据库通常与面向文档型数据库相关联，开发人员可以对XML数据库的数据进行查询，导出以及按指定的格式序列化 YY字节 (Yottabytes) – 约等于1000 ZB (Zettabytes), 约等于250万亿张DVD的数据容量。现今，整个数字化宇宙的数据量为1 YB, 并且将每18年翻一番。 ZZ字节 (ZB: Zettabytes) – 约等于1000 EB (Exabytes), 约等于1百万 TB。据预测，到2016年全球范围内每天网络上通过的信息大约能达到1 ZB。 附：存储容量单位换算表 1 Bit (比特) = Binary Digit 8 Bits = 1 Byte (字节) 1,000 Bytes = 1 Kilobyte 1,000 Kilobytes = 1 Megabyte 1,000 Megabytes = 1 Gigabyte 1,000 Gigabytes = 1 Terabyte 1,000 Terabytes = 1 Petabyte 1,000 Petabytes = 1 Exabyte 1,000 Exabytes = 1 Zettabyte 1,000 Zettabytes = 1 Yottabyte 1,000 Yottabytes = 1 Brontobyte 1,000 Brontobytes = 1 Geopbyte]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用端口梳理]]></title>
      <url>%2F2017%2F05%2F02%2F%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[大家在学习计算机的时候，对于最常用的几个端口比如80端口肯定有很深的印象，但是对于其他一些不是那么常用的端口可能就没那么了解。所以，在一些使用频率相对较高的端口上，很容易会引发一些由于陌生而出现的错误，或者被黑客利用某些端口进行入侵。对于这件事情，大部分人都很头疼——最多可达65535个的端口，让人怎么记？别怕，这次专门给大家整理了一些比较常见端口信息，遇到问题，一查就好！ 注意：一个计算机最多有65535个端口，端口不能重复。 常用端口号： IIS（HTTP）：80 SQLServer：1433 Oracle：1521 MySQL：3306 FTP：21 SSH：22 Tomcat：8080 常用和不常用端口一览表 端口：0 服务：Reserved 说明：通常用于分析操作系统。这一方法能够工作是因为在一些系统中“0”是无效端口，当你试图使用通常的闭合端口连接它时将产生不同的结果。一种典型的扫描，使用IP地址为0.0.0.0，设置ACK位并在以太网层广播。 端口：1 服务：tcpmux 说明：这显示有人在寻找SGI Irix机器。Irix是实现tcpmux的主要提供者，默认情况下tcpmux在这种系统中被打开。Irix机器在发布是含有几个默认的无密码的帐户，如：IP、GUEST UUCP、NUUCP、DEMOS 、TUTOR、DIAG、OUTOFBOX等。许多管理员在安装后忘记删除这些帐户。因此HACKER在INTERNET上搜索tcpmux并利用这些帐户。 端口：7 服务：Echo 说明：能看到许多人搜索Fraggle放大器时，发送到X.X.X.0和X.X.X.255的信息。 端口：19 服务：Character Generator 说明：这是一种仅仅发送字符的服务。UDP版本将会在收到UDP包后回应含有垃圾字符的包。TCP连接时会发送含有垃圾字符的数据流直到连接关闭。HACKER利用IP欺骗可以发动DoS攻击。伪造两个chargen服务器之间的UDP包。同样Fraggle DoS攻击向目标地址的这个端口广播一个带有伪造受害者IP的数据包，受害者为了回应这些数据而过载。 端口：21 服务：FTP 说明：FTP服务器所开放的端口，用于上传、下载。最常见的攻击者用于寻找打开anonymous的FTP服务器的方法。这些服务器带有可读写的目录。木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口。 端口：22 服务：Ssh 说明：PcAnywhere建立的TCP和这一端口的连接可能是为了寻找ssh。这一服务有许多弱点，如果配置成特定的模式，许多使用RSAREF库的版本就会有不少的漏洞存在。 端口：23 服务：Telnet 说明：远程登录，入侵者在搜索远程登录UNIX的服务。大多数情况下扫描这一端口是为了找到机器运行的操作系统。还有使用其他技术，入侵者也会找到密码。木马Tiny Telnet Server就开放这个端口。 端口：25 服务：SMTP 说明：SMTP服务器所开放的端口，用于发送邮件。入侵者寻找SMTP服务器是为了传递他们的SPAM。入侵者的帐户被关闭，他们需要连接到高带宽的E-MAIL服务器上，将简单的信息传递到不同的地址。木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口。 端口：31 服务：MSG Authentication 说明：木马Master Paradise、Hackers Paradise开放此端口。 端口：42 服务：WINS Replication 说明：WINS复制 端口：53 服务：Domain Name Server（DNS） 说明：DNS服务器所开放的端口，入侵者可能是试图进行区域传递（TCP），欺骗DNS（UDP）或隐藏其他的通信。因此防火墙常常过滤或记录此端口。 端口：67 服务：Bootstrap Protocol Server 说明：通过DSL和Cable modem的防火墙常会看见大量发送到广播地址255.255.255.255的数据。这些机器在向DHCP服务器请求一个地址。HACKER常进入它们，分配一个地址把自己作为局部路由器而发起大量中间人（man-in-middle）攻击。客户端向68端口广播请求配置，服务器向67端口广播回应请求。这种回应使用广播是因为客户端还不知道可以发送的IP地址。 DHCP (UDP ports 67 and 68) 端口：69 服务：Trival File Transfer 说明：许多服务器与bootp一起提供这项服务，便于从系统下载启动代码。但是它们常常由于错误配置而使入侵者能从系统中窃取任何文件。它们也可用于系统写入文件。 端口：79 服务：Finger Server 说明：入侵者用于获得用户信息，查询操作系统，探测已知的缓冲区溢出错误，回应从自己机器到其他机器Finger扫描。 端口：80 服务：HTTP 说明：用于网页浏览。木马Executor开放此端口。 端口：99 服务：Metagram Relay 说明：后门程序ncx99开放此端口。 端口：102 服务：Message transfer agent(MTA)-X.400 over TCP/IP 说明：消息传输代理。 端口：109 服务：Post Office Protocol -Version3 说明：POP3服务器开放此端口，用于接收邮件，客户端访问服务器端的邮件服务。POP3服务有许多公认的弱点。关于用户名和密码交换缓冲区溢出的弱点至少有20个，这意味着入侵者可以在真正登陆前进入系统。成功登陆后还有其他缓冲区溢出错误。 端口：110 服务：SUN公司的RPC服务所有端口 说明：常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd等 端口：113 服务：Authentication Service 说明：这是一个许多计算机上运行的协议，用于鉴别TCP连接的用户。使用标准的这种服务可以获得许多计算机的信息。但是它可作为许多服务的记录器，尤其是FTP、POP、IMAP、SMTP和IRC等服务。通常如果有许多客户通过防火墙访问这些服务，将会看到许多这个端口的连接请求。记住，如果阻断这个端口客户端会感觉到在防火墙另一边与E-MAIL服务器的缓慢连接。许多防火墙支持TCP连接的阻断过程中发回RST。这将会停止缓慢的连接。 端口：119 服务：Network News Transfer Protocol 说明：NEWS新闻组传输协议，承载USENET通信。这个端口的连接通常是人们在寻找USENET服务器。多数ISP限制，只有他们的客户才能访问他们的新闻组服务器。打开新闻组服务器将允许发/读任何人的帖子，访问被限制的新闻组服务器，匿名发帖或发送SPAM。 端口：135 服务：Location Service 说明：Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和RPC的服务利用计算机上的end-point mapper注册它们的位置。远端客户连接到计算机时，它们查找end-point mapper找到服务的位置。HACKER扫描计算机的这个端口是为了找到这个计算机上运行Exchange Server吗？什么版本？还有些DOS攻击直接针对这个端口。 端口：137、138、139 服务：NETBIOS Name Service 说明：其中137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口通过这个端口进入的连接试图获得NetBIOS/SMB服务。这个协议被用于windows文件和打印机共享和SAMBA。还有WINS Regisrtation也用它。 端口：143 服务：Interim Mail Access Protocol v2 说明：和POP3的安全问题一样，许多IMAP服务器存在有缓冲区溢出漏洞。记住：一种Linux蠕虫（admv0rm）会通过这个端口繁殖，因此许多这个端口的扫描来自不知情的已经被感染的用户。当REDHAT在他们的LINUX发布版本中默认允许IMAP后，这些漏洞变的很流行。这一端口还被用于IMAP2，但并不流行。 端口：161 服务：SNMP 说明：SNMP允许远程管理设备。所有配置和运行信息的储存在数据库中，通过SNMP可获得这些信息。许多管理员的错误配置将被暴露在Internet。Cackers将试图使用默认的密码public、private访问系统。他们可能会试验所有可能的组合。SNMP包可能会被错误的指向用户的网络。 端口：177 服务：X Display Manager Control Protocol 说明：许多入侵者通过它访问X-windows操作台，它同时需要打开6000端口。 端口：389 服务：LDAP、ILS 说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。 端口：443 服务：Https 说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 端口：456 服务：[NULL] 说明：木马HACKERS PARADISE开放此端口。 端口：513 服务：Login,remote login 说明：是从使用cable modem或DSL登陆到子网中的UNIX计算机发出的广播。这些人为入侵者进入他们的系统提供了信息。 端口：544 服务：[NULL] 说明：kerberos kshell 端口：548 服务：Macintosh,File Services(AFP/IP) 说明：Macintosh,文件服务。 端口：553 服务：CORBA IIOP （UDP） 说明：使用cable modem、DSL或VLAN将会看到这个端口的广播。CORBA是一种面向对象的RPC系统。入侵者可以利用这些信息进入系统。 端口：555 服务：DSF 说明：木马PhAse1.0、Stealth Spy、IniKiller开放此端口。 端口：568 服务：Membership DPA 说明：成员资格 DPA。 端口：569 服务：Membership MSN 说明：成员资格 MSN。 端口：635 服务：mountd 说明：Linux的mountd Bug。这是扫描的一个流行BUG。大多数对这个端口的扫描是基于UDP的，但是基于TCP的mountd有所增加（mountd同时运行于两个端口）。记住mountd可运行于任何端口（到底是哪个端口，需要在端口111做portmap查询），只是Linux默认端口是635，就像NFS通常运行于2049端口。 端口：636 服务：LDAP 说明：SSL（Secure Sockets layer） 端口：666 服务：Doom Id Software 说明：木马Attack FTP、Satanz Backdoor开放此端口 端口：993 服务：IMAP 说明：SSL（Secure Sockets layer） 端口：1001、1011 服务：[NULL] 说明：木马Silencer、WebEx开放1001端口。木马Doly Trojan开放1011端口。 端口：1024 服务：Reserved 说明：它是动态端口的开始，许多程序并不在乎用哪个端口连接网络，它们请求系统为它们分配下一个闲置端口。基于这一点分配从端口1024开始。这就是说第一个向系统发出请求的会分配到1024端口。你可以重启机器，打开Telnet，再打开一个窗口运行natstat -a 将会看到Telnet被分配1024端口。还有SQL session也用此端口和5000端口。 端口：1025、1033 服务：1025：network blackjack 1033：[NULL] 说明：木马netspy开放这2个端口。 端口：1080 服务：SOCKS 说明：这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET。理论上它应该只允许内部的通信向外到达INTERNET。但是由于错误的配置，它会允许位于防火墙外部的攻击穿过防火墙。WinGate常会发生这种错误，在加入IRC聊天室时常会看到这种情况。 端口：1170 服务：[NULL] 说明：木马Streaming Audio Trojan、Psyber Stream Server、Voice开放此端口。 端口：1234、1243、6711、6776 服务：[NULL] 说明：木马SubSeven2.0、Ultors Trojan开放1234、6776端口。木马SubSeven1.0/1.9开放1243、6711、6776端口。 端口：1245 服务：[NULL] 说明：木马Vodoo开放此端口。 端口：1433 服务：SQL 说明：Microsoft的SQL服务开放的端口。 端口：1492 服务：stone-design-1 说明：木马FTP99CMP开放此端口。 端口：1500 服务：RPC client fixed port session queries 说明：RPC客户固定端口会话查询 端口：1503 服务：NetMeeting T.120 说明：NetMeeting T.120 端口：1524 服务：ingress 说明：许多攻击脚本将安装一个后门SHELL于这个端口，尤其是针对SUN系统中Sendmail和RPC服务漏洞的脚本。如果刚安装了防火墙就看到在这个端口上的连接企图，很可能是上述原因。可以试试Telnet到用户的计算机上的这个端口，看看它是否会给你一个SHELL。连接到600/pcserver也存在这个问题。 端口：1600 服务：issd 说明：木马Shivka-Burka开放此端口。 端口：1720 服务：NetMeeting 说明：NetMeeting H.233 call Setup。 端口：1731 服务：NetMeeting Audio Call Control 说明：NetMeeting音频调用控制。 端口：1807 服务：[NULL] 说明：木马SpySender开放此端口。 端口：1981 服务：[NULL] 说明：木马ShockRave开放此端口。 端口：1999 服务：cisco identification port 说明：木马BackDoor开放此端口。 端口：2000 服务：[NULL] 说明：木马GirlFriend 1.3、Millenium 1.0开放此端口。 端口：2001 服务：[NULL] 说明：木马Millenium 1.0、Trojan Cow开放此端口。 端口：2023 服务：xinuexpansion 4 说明：木马Pass Ripper开放此端口。 端口：2049 服务：NFS 说明：NFS程序常运行于这个端口。通常需要访问Portmapper查询这个服务运行于哪个端口。 端口：2115 服务：[NULL] 说明：木马Bugs开放此端口。 端口：2140、3150 服务：[NULL] 说明：木马Deep Throat 1.0/3.0开放此端口。 端口：2500 服务：RPC client using a fixed port session replication 说明：应用固定端口会话复制的RPC客户 端口：2583 服务：[NULL] 说明：木马Wincrash 2.0开放此端口。 端口：2801 服务：[NULL] 说明：木马Phineas Phucker开放此端口。 端口：3024、4092 服务：[NULL] 说明：木马WinCrash开放此端口。 端口：3128 服务：squid 说明：这是squid HTTP代理服务器的默认端口。攻击者扫描这个端口是为了搜寻一个代理服务器而匿名访问Internet。也会看到搜索其他代理服务器的端口8000、8001、8080、8888。扫描这个端口的另一个原因是用户正在进入聊天室。其他用户也会检验这个端口以确定用户的机器是否支持代理。 端口：3129 服务：[NULL] 说明：木马Master Paradise开放此端口。 端口：3150 服务：[NULL] 说明：木马The Invasor开放此端口。 端口：3210、4321 服务：[NULL] 说明：木马SchoolBus开放此端口 端口：3333 服务：dec-notes 说明：木马Prosiak开放此端口 端口：3389 服务：超级终端 说明：WINDOWS 2000终端开放此端口。 端口：3700 服务：[NULL] 说明：木马Portal of Doom开放此端口 端口：3996、4060 服务：[NULL] 说明：木马RemoteAnything开放此端口 端口：4000 服务：QQ客户端 说明：腾讯QQ客户端开放此端口。 端口：4092 服务：[NULL] 说明：木马WinCrash开放此端口。 端口：4590 服务：[NULL] 说明：木马ICQTrojan开放此端口。 端口：5000、5001、5321、50505 服务：[NULL] 说明：木马blazer5开放5000端口。木马Sockets de Troie开放5000、5001、5321、50505端口。 端口：5400、5401、5402 服务：[NULL] 说明：木马Blade Runner开放此端口。 端口：5550 服务：[NULL] 说明：木马xtcp开放此端口。 端口：5569 服务：[NULL] 说明：木马Robo-Hack开放此端口。 端口：5632 服务：pcAnywere 说明：有时会看到很多这个端口的扫描，这依赖于用户所在的位置。当用户打开pcAnywere时，它会自动扫描局域网C类网以寻找可能的代理（这里的代理是指agent而不是proxy）。入侵者也会寻找开放这种服务的计算机。，所以应该查看这种扫描的源地址。一些搜寻pcAnywere的扫描包常含端口22的UDP数据包。 端口：5742 服务：[NULL] 说明：木马WinCrash1.03开放此端口。 端口：6267 服务：[NULL] 说明：木马广外女生开放此端口。 端口：6400 服务：[NULL] 说明：木马The tHing开放此端口。 端口：6670、6671 服务：[NULL] 说明：木马Deep Throat开放6670端口。而Deep Throat 3.0开放6671端口。 端口：6883 服务：[NULL] 说明：木马DeltaSource开放此端口。 端口：6969 服务：[NULL] 说明：木马Gatecrasher、Priority开放此端口。 端口：6970 服务：RealAudio 说明：RealAudio客户将从服务器的6970-7170的UDP端口接收音频数据流。这是由TCP-7070端口外向控制连接设置的。 端口：7000 服务：[NULL] 说明：木马Remote Grab开放此端口。 端口：7300、7301、7306、7307、7308 服务：[NULL] 说明：木马NetMonitor开放此端口。另外NetSpy1.0也开放7306端口。 端口：7323 服务：[NULL] 说明：Sygate服务器端。 端口：7626 服务：[NULL] 说明：木马Giscier开放此端口。 端口：7789 服务：[NULL] 说明：木马ICKiller开放此端口。 端口：8000 服务：OICQ 说明：腾讯QQ服务器端开放此端口。 端口：8010 服务：Wingate 说明：Wingate代理开放此端口。 端口：8080 服务：代理端口 说明：WWW代理开放此端口。 端口：9400、9401、9402 服务：[NULL] 说明：木马Incommand 1.0开放此端口。 端口：9872、9873、9874、9875、10067、10167 服务：[NULL] 说明：木马Portal of Doom开放此端口。 端口：9989 服务：[NULL] 说明：木马iNi-Killer开放此端口。 端口：11000 服务：[NULL] 说明：木马SennaSpy开放此端口。 端口：11223 服务：[NULL] 说明：木马Progenic trojan开放此端口。 端口：12076、61466 服务：[NULL] 说明：木马Telecommando开放此端口。 端口：12223 服务：[NULL] 说明：木马Hack’99 KeyLogger开放此端口。 端口：12345、12346 服务：[NULL] 说明：木马NetBus1.60/1.70、GabanBus开放此端口。 端口：12361 服务：[NULL] 说明：木马Whack-a-mole开放此端口。 端口：13223 服务：PowWow 说明：PowWow是Tribal Voice的聊天程序。它允许用户在此端口打开私人聊天的连接。这一程序对于建立连接非常具有攻击性。它会驻扎在这个TCP端口等回应。造成类似心跳间隔的连接请求。如果一个拨号用户从另一个聊天者手中继承了IP地址就会发生好象有很多不同的人在测试这个端口的情况。这一协议使用OPNG作为其连接请求的前4个字节。 端口：16969 服务：[NULL] 说明：木马Priority开放此端口。 端口：17027 服务：Conducent 说明：这是一个外向连接。这是由于公司内部有人安装了带有Conducent”adbot”的共享软件。Conducent”adbot”是为共享软件显示广告服务的。使用这种服务的一种流行的软件是Pkware。 端口：19191 服务：[NULL] 说明：木马蓝色火焰开放此端口。 端口：20000、20001 服务：[NULL] 说明：木马Millennium开放此端口。 端口：20034 服务：[NULL] 说明：木马NetBus Pro开放此端口。 端口：21554 服务：[NULL] 说明：木马GirlFriend开放此端口。 端口：22222 服务：[NULL] 说明：木马Prosiak开放此端口。 端口：23456 服务：[NULL] 说明：木马Evil FTP、Ugly FTP开放此端口。 端口：26274、47262 服务：[NULL] 说明：木马Delta开放此端口。 端口：27374 服务：[NULL] 说明：木马Subseven 2.1开放此端口。 端口：30100 服务：[NULL] 说明：木马NetSphere开放此端口。 端口：30303 服务：[NULL] 说明：木马Socket23开放此端口。 端口：30999 服务：[NULL] 说明：木马Kuang开放此端口。 端口：31337、31338 服务：[NULL] 说明：木马BO(Back Orifice)开放此端口。另外木马DeepBO也开放31338端口。 端口：31339 服务：[NULL] 说明：木马NetSpy DK开放此端口。 端口：31666 服务：[NULL] 说明：木马BOWhack开放此端口。 端口：33333 服务：[NULL] 说明：木马Prosiak开放此端口。 端口：34324 服务：[NULL] 说明：木马Tiny Telnet Server、BigGluck、TN开放此端口。 端口：40412 服务：[NULL] 说明：木马The Spy开放此端口。 端口：40421、40422、40423、40426、 服务：[NULL] 说明：木马Masters Paradise开放此端口。 端口：43210、54321 服务：[NULL] 说明：木马SchoolBus 1.0/2.0开放此端口。 端口：44445 服务：[NULL] 说明：木马Happypig开放此端口。 端口：50766 服务：[NULL] 说明：木马Fore开放此端口。 端口：53001 服务：[NULL] 说明：木马Remote Windows Shutdown开放此端口。 端口：65000 服务：[NULL] 说明：木马Devil 1.03开放此端口。 端口：88 说明：Kerberos krb5。另外TCP的88端口也是这个用途。 端口：137 说明：SQL Named Pipes encryption over other protocols name lookup(其他协议名称查找上的SQL命名管道加密技术)和SQL RPC encryption over other protocols name lookup(其他协议名称查找上的SQL RPC加密技术)和Wins NetBT name service(WINS NetBT名称服务)和Wins Proxy都用这个端口。 端口：161 说明：Simple Network Management Protocol(SMTP)（简单网络管理协议）。 端口：162 说明：SNMP Trap（SNMP陷阱） 端口：445 说明：Common Internet File System(CIFS)（公共Internet文件系统） 端口：464 说明：Kerberos kpasswd(v5)。另外TCP的464端口也是这个用途。 端口：500 说明：Internet Key Exchange(IKE)（Internet密钥交换） 端口：1645、1812 说明：Remot Authentication Dial-In User Service(RADIUS)authentication(Routing and Remote Access)(远程认证拨号用户服务) 端口：1646、1813 说明：RADIUS accounting(Routing and Remote Access)(RADIUS记帐（路由和远程访问）) 端口：1701 说明：Layer Two Tunneling Protocol(L2TP)(第2层隧道协议) 端口：1801、3527 说明：Microsoft Message Queue Server(Microsoft消息队列服务器)。还有TCP的135、1801、2101、2103、2105也是同样的用途。 端口：2504 说明：Network Load Balancing(网络平衡负荷) 网络层—数据包的包格式里面有个很重要的字段叫做协议号。比如在传输层如果是TCP连接，那么在网络层IP包里面的协议号就将会有个值是6，如果是UDP的话那个值就是17—传输层。 传输层—通过接口关联(端口的字段叫做端口)—应用层。 用netstat –an 可以查看本机开放的端口号。 代理服务器常用端口 （1）. HTTP协议代理服务器常用端口号：80/8080/3128/8081/9080 （2）. SOCKS代理协议服务器常用端口号：1080 （3）. FTP（文件传输）协议代理服务器常用端口号：21 （4）. Telnet（远程登录）协议代理服务器常用端口：23 HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）； HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp； Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）； FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp； SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp； SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp； WebLogic，默认的端口号为7001； Webshpere应用程序，默认的端口号为9080； webshpere管理工具，默认的端口号为9090； JBOSS，默认的端口号为8080； TOMCAT，默认的端口号为8080； WIN2003远程登陆，默认的端口号为3389； Symantec AV/Filter for MSE ,默认端口号为 8081； Oracle 数据库，默认的端口号为1521； ORACLE EMCTL，默认的端口号为1158； Oracle XDB（ XML 数据库），默认的端口号为8080； Oracle XDB FTP服务，默认的端口号为2100； MS SQL*SERVER数据库server，默认的端口号为1433/tcp 1433/udp； MS SQL*SERVER数据库monitor，默认的端口号为1434/tcp 1434/udp； QQ，默认的端口号为1080/udp TcpMux0 1 Tcp端口服务多路复用器 Echo 1 7 回送(echo回送所有的接收数据) Discard2 9 删除(静态删除所有接受的数据) Systat3 11 当前用户 Daytime 13 白天 Quotd 17 每天的引用 Chargen 19 产生字符 Ftp-data 20 文件传送(默认数据) Ftp 21 文件传送(控制端口) Telnet 23 远程通信网 Smtp 25 简单邮件传输协议 Time 37 时间 Nicname 43 谁 Domain 53 域名服务器 Bootps 67 引导程序协议服务器 Bootpc 68 引导程序协议客户 Tftp 69 普通文件传输协议 Gopher 70 Gopher Finger 79 拨号 WWW-http 80 WWW-Http Kerberos 88 Kerberos Pop2 109 邮政协议版本2 Pop3 110 邮政协议版本3 Sunrpc 111 Sun运端程序呼叫 nntp 119 网络新闻传输协议 Ntp 123 网络时间协议 Netbios-ns 137 网络基本输入输出系统命名服务 Netbios-ns 138 网络基本输入输出系统数据报服务 Netbios-ssn 139 网络基本输入输出系统期间服务 Imap2 143 中间邮件访问协议V2 Snmp 161 简单网络管理协议 Bgp 179 边界网关协议 Syslog 514 系统登陆器 本文来自：http://mageedu.blog.51cto.com/4265610/1921073]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十大企业级Linux服务器安全防护要点]]></title>
      <url>%2F2017%2F03%2F27%2F%E5%8D%81%E5%A4%A7%E4%BC%81%E4%B8%9A%E7%BA%A7Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E8%A6%81%E7%82%B9%2F</url>
      <content type="text"><![CDATA[随着开源系统Linux的盛行，其在大中型企业的应用也在逐渐普及，很多企业的应用服务都是构筑在其之上，例如Web服务、数据库服务、集群服务等等。 因此，Linux的安全性就成为了企业构筑安全应用的一个基础，是重中之重，如何对其进行安全防护是企业需要解决的一个基础性问题，基于此，本文将给出十大企业级Linux服务器安全防护的要点。 强化：密码管理设定登录密码是一项非常重要的安全措施，如果用户的密码设定不合适，就很容易被破译，尤其是拥有超级用户使用权限的用户，如果没有良好的密码，将给系统造成很大的安全漏洞。 目前密码破解程序大多采用字典攻击以及暴力攻击手段，而其中用户密码设定不当，则极易受到字典攻击的威胁。很多用户喜欢用自己的英文名、生日或者账户等信息来设定密码，这样，黑客可能通过字典攻击或者是社会工程的手段来破解密码。所以建议用户在设定密码的过程中，应尽量使用非字典中出现的组合字符，并且采用数字与字符相结合、大小写相结合的密码设置方式，增加密码被黑客破解的难度。而且，也可以使用定期修改密码、使密码定期作废的方式，来保护自己的登录密码。 在多用户系统中，如果强迫每个用户选择不易猜出的密码，将大大提高系统的安全性。但如果passwd程序无法强迫每个上机用户使用恰当的密码，要确保密码的安全度，就只能依靠密码破解程序了。实际上，密码破解程序是黑客工具箱中的一种工具，它将常用的密码或者是英文字典中所有可能用来作密码的字都用程序加密成密码字，然后将其与Linux系统的/etc/passwd密码文件或/etc/shadow影子文件相比较，如果发现有吻合的密码，就可以求得明码了。在网络上可以找到很多密码破解程序，比较有名的程序是crack和john the ripper.用户可以自己先执行密码破解程序，找出容易被黑客破解的密码，先行改正总比被黑客破解要有利。 限定：网络服务管理早期的Linux版本中，每一个不同的网络服务都有一个服务程序(守护进程，Daemon)在后台运行，后来的版本用统一的/etc/inetd服务器程序担此重任。Inetd是Internetdaemon的缩写，它同时监视多个网络端口，一旦接收到外界传来的连接信息，就执行相应的TCP或UDP网络服务。由于受inetd的统一指挥，因此Linux中的大部分TCP或UDP服务都是在/etc/inetd.conf文件中设定。所以取消不必要服务的第一步就是检查/etc/inetd.conf文件，在不要的服务前加上“#”号。 一般来说，除了http、smtp、telnet和ftp之外，其他服务都应该取消，诸如简单文件传输协议tftp、网络邮件存储及接收所用的imap/ipop传输协议、寻找和搜索资料用的gopher以及用于时间同步的daytime和time等。还有一些报告系统状态的服务，如finger、efinger、systat和netstat等，虽然对系统查错和寻找用户非常有用，但也给黑客提供了方便之门。例如，黑客可以利用finger服务查找用户的电话、使用目录以及其他重要信息。因此，很多Linux系统将这些服务全部取消或部分取消，以增强系统的安全性。Inetd除了利用/etc/inetd.conf设置系统服务项之外，还利用/etc/services文件查找各项服务所使用的端口。因此，用户必须仔细检查该文件中各端口的设定，以免有安全上的漏洞。 在后继的Linux版本中(比如Red Hat Linux7.2之后)，取而代之的是采用xinetd进行网络服务的管理。 当然，具体取消哪些服务不能一概而论，需要根据实际的应用情况来定，但是系统管理员需要做到心中有数，因为一旦系统出现安全问题，才能做到有步骤、有条不紊地进行查漏和补救工作，这点比较重要。 严格审计：系统登录用户管理在进入Linux系统之前，所有用户都需要登录，也就是说，用户需要输入用户账号和密码，只有它们通过系统验证之后，用户才能进入系统。 与其他Unix操作系统一样，Linux一般将密码加密之后，存放在/etc/passwd文件中。Linux系统上的所有用户都可以读到/etc/passwd文件，虽然文件中保存的密码已经经过加密，但仍然不太安全。因为一般的用户可以利用现成的密码破译工具，以穷举法猜测出密码。比较安全的方法是设定影子文件/etc/shadow，只允许有特殊权限的用户阅读该文件。 在Linux系统中，如果要采用影子文件，必须将所有的公用程序重新编译，才能支持影子文件。这种方法比较麻烦，比较简便的方法是采用插入式验证模块(PAM)。很多Linux系统都带有Linux的工具程序PAM，它是一种身份验证机制，可以用来动态地改变身份验证的方法和要求，而不要求重新编译其他公用程序。这是因为PAM采用封闭包的方式，将所有与身份验证有关的逻辑全部隐藏在模块内，因此它是采用影子档案的最佳帮手。 此外，PAM还有很多安全功能：它可以将传统的DES加密方法改写为其他功能更强的加密方法，以确保用户密码不会轻易地遭人破译;它可以设定每个用户使用电脑资源的上限;它甚至可以设定用户的上机时间和地点。 Linux系统管理人员只需花费几小时去安装和设定PAM，就能大大提高Linux系统的安全性，把很多攻击阻挡在系统之外。 设定：用户账号安全等级管理除密码之外，用户账号也有安全等级，这是因为在Linux上每个账号可以被赋予不同的权限，因此在建立一个新用户ID时，系统管理员应该根据需要赋予该账号不同的权限，并且归并到不同的用户组中。 在Linux系统中的部分文件中，可以设定允许上机和不允许上机人员的名单。其中，允许上机人员名单在/etc/hosts.allow中设置，不允许上机人员名单在/etc/hosts.deny中设置。此外，Linux将自动把允许进入或不允许进入的结果记录到/var/log/secure文件中，系统管理员可以据此查出可疑的进入记录。 每个账号ID应该有专人负责。在企业中，如果负责某个ID的职员离职，管理员应立即从系统中删除该账号。很多入侵事件都是借用了那些很久不用的账号。 在用户账号之中，黑客最喜欢具有root权限的账号，这种超级用户有权修改或删除各种系统设置，可以在系统中畅行无阻。因此，在给任何账号赋予root权限之前，都必须仔细考虑。 Linux系统中的/etc/securetty文件包含了一组能够以root账号登录的终端机名称。例如，在RedHatLinux系统中，该文件的初始值仅允许本地虚拟控制台(rtys)以root权限登录，而不允许远程用户以root权限登录。最好不要修改该文件，如果一定要从远程登录为root权限，最好是先以普通账号登录，然后利用su命令升级为超级用户。 谨慎使用：“r系列”远程程序管理在Linux系统中有一系列r字头的公用程序，比如rlogin，rcp等等。它们非常容易被黑客用来入侵我们的系统，因而非常危险，因此绝对不要将root账号开放给这些公用程序。由于这些公用程序都是用。rhosts文件或者hosts.equiv文件核准进入的，因此一定要确保root账号不包括在这些文件之内。 由于r等远程指令是黑客们用来攻击系统的较好途径，因此很多安全工具都是针对这一安全漏洞而设计的。例如，PAM工具就可以用来将r字头公用程序有效地禁止掉，它在/etc/pam.d/rlogin文件中加上登录必须先核准的指令，使整个系统的用户都不能使用自己home目录下的。rhosts文件。 限制：root用户权限管理Root一直是Linux保护的重点，由于它权力无限，因此最好不要轻易将超级用户授权出去。但是，有些程序的安装和维护工作必须要求有超级用户的权限，在这种情况下，可以利用其他工具让这类用户有部分超级用户的权限。sudo就是这样的工具。 sudo程序允许一般用户经过组态设定后，以用户自己的密码再登录一次，取得超级用户的权限，但只能执行有限的几个指令。例如，应用sudo后，可以让管理磁带备份的管理人员每天按时登录到系统中，取得超级用户权限去执行文档备份工作，但却没有特权去作其他只有超级用户才能作的工作。 sudo不但限制了用户的权限，而且还将每次使用sudo所执行的指令记录下来，不管该指令的执行是成功还是失败。在大型企业中，有时候有许多人同时管理Linux系统的各个不同部分，每个管理人员都有用sudo授权给某些用户超级用户权限的能力，从sudo的日志中，可以追踪到谁做了什么以及改动了系统的哪些部分。 值得注意的是，sudo并不能限制所有的用户行为，尤其是当某些简单的指令没有设置限定时，就有可能被黑客滥用。例如，一般用来显示文件内容的/etc/cat指令，如果有了超级用户的权限，黑客就可以用它修改或删除一些重要的文件。 追踪黑客踪迹：日志管理当用户仔细设定了各种与Linux相关的配置(最常用日志管理选项)，并且安装了必要的安全防护工具之后，Linux操作系统的安全性的确大为提高，但是却并不能保证防止那些比较熟练的网络黑客的入侵。 在平时，网络管理人员要经常提高警惕，随时注意各种可疑状况，并且按时检查各种系统日志文件，包括一般信息日志、网络连接日志、文件传输日志以及用户登录日志等。在检查这些日志时，要注意是否有不合常理的时间记载。例如： 正常用户在半夜三更登录; 不正常的日志记录，比如日志只记录了一半就切断了，或者整个日志文件被删除了; 用户从陌生的网址进入系统; 因密码错误或用户账号错误被摈弃在外的日志记录，尤其是那些一再连续尝试进入失败，但却有一定模式的试错法; 非法使用或不正当使用超级用户权限su的指令; 重新开机或重新启动各项服务的记录。 上述这些问题都需要系统管理员随时留意系统登录的用户状况以及查看相应日志文件，许多背离正常行为的蛛丝马迹都应当引起高度注意。 横向扩展：综合防御管理防火墙、IDS等防护技术已经成功地应用到网络安全的各个领域，而且都有非常成熟的产品。 在Linux系统来说，有一个自带的Netfilter/Iptables防火墙框架，通过合理地配置其也能起到主机防火墙的功效。在Linux系统中也有相应的轻量级的网络入侵检测系统Snort以及主机入侵检测系统LIDS(Linux Intrusion Detection System)，使用它们可以快速、高效地进行防护。 需要提醒注意的是：在大多数的应用情境下，我们需要综合使用这两项技术，因为防火墙相当于安全防护的第一层，它仅仅通过简单地比较IP地址/端口对来过滤网络流量，而IDS更加具体，它需要通过具体的数据包(部分或者全部)来过滤网络流量，是安全防护的第二层。综合使用它们，能够做到互补，并且发挥各自的优势，最终实现综合防御。 评测：漏洞追踪及管理Linux作为一种优秀的开源软件，其自身的发展也日新月异，同时，其存在的问题也会在日后的应用中慢慢暴露出来。黑客对新技术的关注从一定程度上来说要高于我们防护人员，所以要想在网络攻防的战争中处于有利地位，保护Linux系统的安全，就要求我们要保持高度的警惕性和对新技术的高度关注。用户特别是使用Linux作为关键业务系统的系统管理员们，需要通过Linux的一些权威网站和论坛上尽快地获取有关该系统的一些新技术以及一些新的系统漏洞的信息，进行漏洞扫描、渗透测试等系统化的相关配套工作，做到防范于未然，提早行动，在漏洞出现后甚至是出现前的最短时间内封堵系统的漏洞，并且在实践中不断地提高安全防护的技能，这样才是一个比较的解决办法和出路。 保持更新：补丁管理Linux作为一种优秀的开源软件，其稳定性、安全性和可用性有极为可靠的保证，世界上的Linux高手共同维护着个优秀的产品，因而起流通渠道很多，而且经常有更新的程序和系统补丁出现，因此，为了加强系统安全，一定要经常更新系统内核。 Kernel是Linux操作系统的核心，它常驻内存，用于加载操作系统的其他部分，并实现操作系统的基本功能。由于Kernel控制计算机和网络的各种功能，因此，它的安全性对整个系统安全至关重要。早期的Kernel版本存在许多众所周知的安全漏洞，而且也不太稳定，只有2.0.x以上的版本才比较稳定和安全(一般说来，内核版本号为偶数的相对稳定，而为奇数的则一般为测试版本，用户们使用时要多留意)，新版本的运行效率也有很大改观。在设定Kernel的功能时，只选择必要的功能，千万不要所有功能照单全收，否则会使Kernel变得很大，既占用系统资源，也给黑客留下可乘之机。 在Internet上常常有最新的安全修补程序，Linux系统管理员应该消息灵通，经常光顾安全新闻组，查阅新的修补程序。 本文来自：http://mageedu.blog.51cto.com/4265610/1910600]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker高级（1）--架构总览]]></title>
      <url>%2F2017%2F03%2F12%2FDocker%E9%AB%98%E7%BA%A7%EF%BC%881%EF%BC%89--%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%2F</url>
      <content type="text"><![CDATA[背景Docker简介&#8194;&#8194;&#8194;&#8194;Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。 &#8194;&#8194;&#8194;&#8194;目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。&#8194;&#8194;&#8194;&#8194;由于众多新颖的特性以及项目本身的开放性，Docker在不到两年的时间里迅速获得诸多厂商的青睐，其中更是包括Google、Microsoft、VMware等业界行业领导者。Google在今年六月份推出了Kubernetes，提供Docker容器的调度服务，而今年8月Microsoft宣布Azure上支持Kubernetes，随后传统虚拟化巨头VMware宣布与Docker强强合作。今年9月中旬，Docker更是获得4000万美元的C轮融资，以推动分布式应用方面的发展。&#8194;&#8194;&#8194;&#8194;从目前的形势来看，Docker的前景一片大好。本系列文章从源码的角度出发，详细介绍Docker的架构、Docker的运行以及Docker的卓越特性。本文是Docker源码分析系列的第一篇­­­——Docker架构篇。 Docker版本信息&#8194;&#8194;&#8194;&#8194;本文关于Docker架构的分析都是基于Docker的源码与Docker相应版本的运行结果，其中Docker为最新的1.2版本。 Docker架构分析内容安排&#8194;&#8194;&#8194;&#8194;本文的目的是：在理解Docker源代码的基础上，分析Docker架构。分析过程中主要按照以下三个步骤进行： ● Docker的总架构图展示 ● Docker架构图内部各模块功能与实现分析 ● 以Docker命令的执行为例，进行Docker运行流程阐述 Docker总架构图&#8194;&#8194;&#8194;&#8194;学习Docker的源码并不是一个枯燥的过程，反而可以从中理解Docker架构的设计原理。Docker对使用者来讲是一个C/S模式的架构，而Docker的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑Docker的运行。在此，先附上Docker总架构，如图3.1。&#8194;&#8194;&#8194;&#8194;如图3.1，不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。&#8194;&#8194;&#8194;&#8194;而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。&#8194;&#8194;&#8194;&#8194;Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。&#8194;&#8194;&#8194;&#8194;而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。&#8194;&#8194;&#8194;&#8194;当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。 Docker架构内各模块的功能与实现分析&#8194;&#8194;&#8194;&#8194;接下来，我们将从Docker总架构图入手，抽离出架构内各个模块，并对各个模块进行更为细化的架构分析与功能阐述。主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。 Docker Client&#8194;&#8194;&#8194;&#8194;Docker Client是Docker架构中用户用来和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。&#8194;&#8194;&#8194;&#8194;Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。为了简单起见，本文一律使用第一种方式作为讲述两者通信的原型。与此同时，与Docker &#8194;&#8194;&#8194;&#8194;Daemon建立连接并传输请求的时候，Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。&#8194;&#8194;&#8194;&#8194;Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。 Docker Daemon&#8194;&#8194;&#8194;&#8194;Docker Daemon是Docker架构中一个常驻在后台的系统进程，功能是：接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker &#8194;&#8194;&#8194;&#8194;Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。&#8194;&#8194;&#8194;&#8194;Docker Daemon启动所使用的可执行文件也为docker，与Docker Client启动所使用的可执行文件docker相同。在docker命令执行时，通过传入的参数来判别Docker Daemon与Docker Client。&#8194;&#8194;&#8194;&#8194;Docker Daemon的架构，大致可以分为以下三部分：Docker Server、Engine和Job。Daemon架构如图4.1。 &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.1 Docker Daemon架构示意图 Docker Server &#8194;&#8194;&#8194;&#8194; Docker Server在Docker架构中是专门服务于Docker Client的server。该server的功能是：接受并调度分发Docker Client发送的请求。Docker Server的架构如图4.2。 &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.2 Docker Server架构示意图 &#8194;&#8194;&#8194;&#8194;在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。&#8194;&#8194;&#8194;&#8194;若Docker Client通过HTTP的形式访问Docker &#8194;&#8194;&#8194;&#8194;Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。&#8194;&#8194;&#8194;&#8194;在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。&#8194;&#8194;&#8194;&#8194;需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。 Engine&#8194;&#8194;&#8194;&#8194;Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。&#8194;&#8194;&#8194;&#8194;在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler Job&#8194;&#8194;&#8194;&#8194;一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。&#8194;&#8194;&#8194;&#8194;Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等 Docker Registry&#8194;&#8194;&#8194;&#8194;Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。&#8194;&#8194;&#8194;&#8194;在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。&#8194;&#8194;&#8194;&#8194;其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成 Graph&#8194;&#8194;&#8194;&#8194;Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如图4.3。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;图4.3 Graph架构示意图&#8194;&#8194;&#8194;&#8194;其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。&#8194;&#8194;&#8194;&#8194;同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs Driver&#8194;&#8194;&#8194;&#8194;Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。&#8194;&#8194;&#8194;&#8194;因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。&#8194;&#8194;&#8194;&#8194;在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。&#8194;&#8194;&#8194;&#8194;graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。&#8194;&#8194;&#8194;&#8194;在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。graphdriver的架构如图4.4： &#8194;&#8194;&#8194;&#8194;networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如图4.5： &#8194;&#8194;&#8194;&#8194;execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如图4.6： libcontainer&#8194;&#8194;&#8194;&#8194;libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如图4.7 &#8194;&#8194;&#8194;&#8194;另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。&#8194;&#8194;&#8194;&#8194;暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。 Docker container&#8194;&#8194;&#8194;&#8194;Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。Docker按照用户的需求与指令，订制相应的Docker容器： ● 用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统； ● 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源； ● 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境； ● 用户通过指定运行的命令，使得Docker容器执行指定的工作。Docker容器示意图如图4.8： Docker运行案例分析上一章节着重于Docker架构中各个部分的介绍。本章的内容，将以串联Docker各模块来简要分析，分析原型为Docker中的docker pull与docker run两个命令。 docker pull&#8194;&#8194;&#8194;&amp;#8194docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。docker pull命令执行流程如图5.1。 如图，图中标记的红色箭头表示docker pull命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。(1) Docker Client接受docker pull命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/images/create? “+”xxx”；(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(3) mux.Router将请求路由分发至相应的handler，具体为PostImagesCreate；(4) 在PostImageCreate这个handler之中，一个名为”pull”的job被创建，并开始执行；(5) 名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；(6) 名为”pull”的job将下载的image交给graphdriver；(7) graphdriver负责将image进行存储，一方创建graph对象，另一方面在GraphDB中记录image之间的关系。 docker run&#8194;&#8194;&#8194;docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client给Docker Server发送了两次HTTP请求，第二次请求的发起取决于第一次请求的返回状态。Docker run命令执行流程如图5.2。如图，图中标记的红色箭头表示docker run命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。(1) Docker Client接受docker run命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/containers/create? “+”xxx”；(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(3) mux.Router将请求路由分发至相应的handler，具体为PostContainersCreate；(4) 在PostImageCreate这个handler之中，一个名为”create”的job被创建，并开始让该job运行；(5) 名为”create”的job在运行过程中，执行Container.Create操作，该操作需要获取容器镜像来为Docker容器创建rootfs，即调用graphdriver；(6) graphdriver从Graph中获取创建Docker容器rootfs所需要的所有的镜像；(7) graphdriver将rootfs所有镜像，加载安装至Docker容器指定的文件目录下；(8) 若以上操作全部正常执行，没有返回错误或异常，则Docker Client收到Docker Server返回状态之后，发起第二次HTTP请求。请求方法为”POST”，请求URL为”/containers/“+container_ID+”/start”；(9) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(10)mux.Router将请求路由分发至相应的handler，具体为PostContainersStart；(11)在PostContainersStart这个handler之中，名为”start”的job被创建，并开始执行；(12)名为”start”的job执行完初步的配置工作后，开始配置与创建网络环境，调用networkdriver；(13)networkdriver需要为指定的Docker容器创建网络接口设备，并为其分配IP，port，以及设置防火墙规则，相应的操作转交至libcontainer中的netlink包来完成；(14)netlink完成Docker容器的网络环境配置与创建；(15)返回至名为”start”的job，执行完一些辅助性操作后，job开始执行用户指令，调用execdriver；(16)execdriver被调用，初始化Docker容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至libcontainer来完成；(17)libcontainer被调用，完成Docker容器内部的运行环境初始化，并最终执行用户要求启动的命令。 总结本文从Docker 1.2的源码入手，分析抽象出Docker的架构图，并对该架构图中的各个模块进行功能与实现的分析，最后通过两个docker命令展示了Docker内部的运行。通过对Docker架构的学习，可以全面深化对Docker设计、功能与价值的理解。同时在借助Docker实现用户定制的分布式系统时，也能更好地找到已有平台与Docker较为理想的契合点。另外，熟悉Docker现有架构以及设计思想，也能对云计算PaaS领域带来更多的启发，催生出更多实践与创新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（9）--Dockerfile]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89--Dockerfile%2F</url>
      <content type="text"><![CDATA[使用Dockerfile构建nginxDockerfile是由一行命令和语句组成的 Dockerfile构建步骤： [root@tang /]# mkdir /dockerfile/nginx -p 我们要在nginx目录上自动化创建一个nginx镜像 注意：D需要大写，当我们构建dockerfile的时候，docker默认会在我们当前目录读取一个名为Dockerfile的文件。这时候的D必须大写 [root@tang nginx]# cat Dockerfile # This Dockerfile # My Name is TangXiaoyue # Base image FROM centos # Maintainer MAINTAINE tang 1060336375@qq.com #Commands RUN rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm RUN yum install -y nginx &amp;&amp; yum clean all RUN echo &quot;daemon off;&quot; &gt;&gt;/etc/nginx/nginx.conf ADD index.html /usr/share/nginx/html/index.html EXPOSE 80 CMD [&quot;nginx&quot;] #井号代表注释 #Base image 除了注释的第一行，必须是FROM，意思就是我们需要告诉dockerfile基础镜像是什么 #Maintainer 维护信息 #Commands 命令 #ADD index.html 这个文件需要我们在当前目录下有才可以，我们配置我们可以准备好，然后使用ADD命令进行添加或修改 EXPOSE 对外端口号 CMD [“nginx”] 它要启动的命令是nginx （就算是nginx服务） 我们写好dockerfile还需要一个index.html [root@tang nginx]# echo TangXiaoyue &gt;index.html [root@tang nginx]# ll total 8 -rw-r--r-- 1 root root 364 Apr 2 20:50 Dockerfile -rw-r--r-- 1 root root 12 Apr 2 20:52 index.html 使用docker build进行构建 [root@tang ~]# docker build -t nginx_test:v1 /dockerfile/nginx/ [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx_test v1 bc69ee414a0f 17 seconds ago 280.7 MB 启动镜像 [root@tang ~]# docker run --name nginx_test -d -p 82:80 nginx_test:v1 7a02c27a0a04d34eec8f858e35848416b95572dbb1f485310caee5c185d2e426 [root@tang ~]# curl 127.0.0.1:82 TangXiaoyue Dockerfile参数解释FROM格式：FROM&lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;。 解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。 然后后面的其它指令FROM的镜像中执行。 MAINTAINER格式：MAINTAINER &lt;name&gt; 解释：指定维护者信息。 RUN格式：RUN &lt;command&gt;或 RUN[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。 解释：运行命令，命令较长使可以使用\来换行。推荐使用上面数组的格式 CMD格式： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式； CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用； CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT的默认参数； 解释： CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。 如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。 ENTRYPOINT格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;] ENTRYPOINT command param1 param2（shell中执行）。 解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。 ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。 所以生产实践中我们可以同时使用ENTRYPOINT和CMD， 例如： ENTRYPOINT [&quot;/usr/bin/rethinkdb&quot;] CMD [&quot;--help&quot;] USER格式：USER daemon 解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。 EXPOSE格式：EXPOSE&lt;port&gt; [&lt;port&gt;...] 解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。 ENV格式：ENV&lt;key&gt; &lt;value&gt; ENV &lt;key&gt;=&lt;value&gt; ... 解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定 ADD格式： ADD &lt;src&gt;... &lt;dest&gt; ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 解释： 将指定的&lt;src&gt;复制到容器文件系统中的&lt;dest&gt; 所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0 如果文件是可识别的压缩格式，则docker会帮忙解压缩 VOLUME格式：VOLUME [&quot;/data&quot;] 解释：可以将本地文件夹或者其他container的文件夹挂载到container中。 WORKDIR格式：WORKDIR/path/to/workdir 解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。 可以多次切换(相当于cd命令)， 也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如: WORKDIR /a WORKDIR b WORKDIR c RUN pwd 则最终路径为 /a/b/c。 ONBUILDONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行 ARG格式：ARG&lt;name&gt;[=&lt;default value&gt;] 解释：ARG指定了一个变量在docker build的时候使用， 可以使用--build-arg &lt;varname&gt;=&lt;value&gt;来指定参数的值，不过如果构建的时候不指定就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker问题梳理--持续更新]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于systemctl无法启动服务的问题处理问题： 使用systemctl启动服务的时候出现以下异常： Failed to get D-Bus connection: Operation not permitted 解决： docker run --privileged -itd -h node1 --name node1 centos /sbin/init]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（6）--仓库管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89--%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker的仓库是DockerHub，类似于github，github有一个开源的软件叫gitlab。Docker也有一个开源软件docker registry [root@tang ~]# docker pull registry [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 默认占用5000端口，我们查看是否存在5000端口 [root@tang ~]# netstat -lntup | grep 5000 运行容器 [root@tang ~]# docker run -d -p 5000:5000 registry f002089ab95474290853a2a24b86cb0adbb5848c4a468175304b59b27d6e3b0e 提示：docker比较老的版本运行起来就可以运行，1.7之后都不可以]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（3）--容器登入]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[docker-enter登入容器 强烈推荐使用此种方法：简单、方便 下载.bashrc_docker，并将内容放到.bashrc中。 这个文件中定义了很多方便使用Docker的命令，比如docker-pid可以获取某个容器的 PID； 而 docker-enter 可以进入容器或直接在容器内执行命令 [root@tang ~]# wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker [root@tang ~]# echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc [root@tang ~]# docker- docker-containerd docker-ctr-current docker-pid docker-containerd-current docker-current docker-storage-setup docker-containerd-shim docker-enter docker-containerd-shim-current docker-ip [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 24 minutes ago Up 23 minutes tang [root@tang ~]# docker-pid tang 19271 [root@tang ~]# nsenter --target 19271 --mount --uts --ipc --net --pid #此种方法进入容器以下会讲到 [root@test /]# exit logout [root@tang ~]# docker-ip tang 172.18.0.2 直接使用docker-enter命令进入容器，非常方便！ [root@tang ~]# docker-enter tang Last login: Sun Apr 2 06:38:47 UTC 2017 [root@test ~]# exit logout [root@tang ~]# docker ps #退出登陆窗口后，容器还在 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 26 minutes ago Up 9 seconds tang 注意：以在容器的上下文中运行任意命令！即在宿主机上执行容器里的命令 [root@tang ~]# docker-enter tang uptime 07:06:28 up 1 day, 22:44, 0 users, load average: 0.00, 0.01, 0.05 注意：在宿主机上使用docker-enter命令执行容器中的命令时，最好后面加上--符号，这样容器里的所有存在的命令都可以正常执行。 [root@tang ~]# docker-enter tang -- uptime 07:06:59 up 1 day, 22:45, 0 users, load average: 0.00, 0.01, 0.05 [root@tang ~]# docker-enter tang -- df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/docker-253:1-2024335-661487685eb1f6a356157463d60db20caa2c1fb3ac273de680c367e3b12dabab 10G 238M 9.8G 3% / tmpfs 920M 0 920M 0% /dev tmpfs 920M 0 920M 0% /sys/fs/cgroup /dev/vda1 99G 4.7G 89G 5% /etc/hosts shm 64M 0 64M 0% /dev/shm [root@tang ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@tang ~]# docker-enter tang -- cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) nsenter登入容器使用外部工具nsenter登陆容器，该工具和docker exec命令的效果差不多。 使用nsenter或dockerexec，都可以在容器的上下文（严格地说，是命名空间）中运行任意命令！ ==nsenter安装： [root@tang ~]# yum install util-linux -y ==nsenter使用： [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 50 minutes ago Up 24 minutes tang [root@tang ~]# docker inspect -f &quot;{{ .State.Pid }}&quot; tang 19271 [root@tang ~]# nsenter -t 19271 -m -u -i -n -p 解释nsenter指令中进程id之后的参数的含义： –mount参数是进去到mount namespace中 –uts参数是进入到uts namespace中 –ipc参数是进入到System V IPC namaspace中 –net参数是进入到network namespace中 –pid参数是进入到pid namespace中 –user参数是进入到user namespace中 [root@tang ~]# nsenter --help Usage: nsenter [options] &lt;program&gt; [&lt;argument&gt;...] Run a program with namespaces of other processes. Options: -t, --target &lt;pid&gt; target process to get namespaces from -m, --mount[=&lt;file&gt;] enter mount namespace -u, --uts[=&lt;file&gt;] enter UTS namespace (hostname etc) -i, --ipc[=&lt;file&gt;] enter System V IPC namespace -n, --net[=&lt;file&gt;] enter network namespace -p, --pid[=&lt;file&gt;] enter pid namespace -U, --user[=&lt;file&gt;] enter user namespace -S, --setuid &lt;uid&gt; set uid in entered namespace -G, --setgid &lt;gid&gt; set gid in entered namespace --preserve-credentials do not touch uids or gids -r, --root[=&lt;dir&gt;] set the root directory -w, --wd[=&lt;dir&gt;] set the working directory -F, --no-fork do not fork before exec ing &lt;program&gt; -Z, --follow-context set SELinux context according to --target PID -h, --help display this help and exit -V, --version output version information and exit 我们进入容器中查看进程 以下是以nsenter启动的进程 [root@test /]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 11768 1684 ? Ss+ 07:03 0:00 /bin/bash root 77 0.0 0.1 15200 1988 ? S 07:31 0:00 -bash root 90 0.0 0.0 50872 1816 ? R+ 07:31 0:00 ps aux /bin/bash是我们运行容器产生的进程 -bash 是我们使用nsenter产生的，这样如果我们退出容器，容器就不会退出，因为-bash还在运行 [root@test /]# exit logout [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 55 minutes ago Up 29 minutes tang 因为每次进入容器都需要输入那两条命令，所以我们可以写一个脚本来获取。 ==脚本内容如下： [root@tang opt]# cat docker_in.sh #!/bin/bash # Use nsenter to access docker docker_in(){ NAME_ID=$1 PID=$(docker inspect -f &quot;{{ .State.Pid }}&quot; $NAME_ID) nsenter -t $PID -m -u -i -n -p } docker_in $1 [root@tang opt]# chmod +x docker_in.sh [root@tang opt]# ./docker_in.sh tang [root@test /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 91 0 0 07:34 ? 00:00:00 -bash root 104 91 0 07:34 ? 00:00:00 ps -ef [root@test /]# exit logout [root@tang opt]# docker exec tang ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 105 0 0 07:35 ? 00:00:00 ps -ef 我们还可以使用exec进入docker容器中 [root@tang opt]# docker exec -it tang /bin/bash start -ai登入容器对于一个已关闭的容器的登陆，可以使用&quot;docker start -ai container&quot;登陆。这种其实就是先启动容器，然后再进入容器内。 [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Exited (0) 53 seconds ago tang [root@tang ~]# docker start -ai tang #-a -i 都可以 [root@test /]# exit exit [root@tang ~]# docker start -i tang [root@tang ~]# docker start -a tang docker exec登入容器使用自带命令docker exec登陆容器 命令格式：docker exec -ti container_id /bin/bash [root@tang ~]# docker ps #前提是容器已经启动 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 2 minutes tang [root@tang ~]# docker exec -it tang /bin/bash [root@test /]# exit docker attach登入容器使用自带命令docker attach登陆容器。 命令格式：docker attach container_id [root@tang ~]# docker ps #前提容器已经启动了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 5 minutes tang [root@tang ~]# docker attach tang [root@test /]# exit ssh登入容器使用ssh登陆容器。这种方法需要在容器中启动sshd，存在开销和攻击面增大的问题。同时也违反了Docker所倡导的一个容器一个进程的原则 ssh登入会专门写一篇文章介绍。这里就不叙述了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（8）--网络管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89--%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker四种网络模式第一种网络模式hosthost模式: 使用--net=host指定docker使用的网络实际上和宿主机一样,在容器内看到的网卡ip是宿主机上的ip. [root@docker ~]# docker run -itd -h node1 --name node1 --net=host centos bash 406cdb306f3c350b6f5344048ae25426f1df3f6863162c0b3a91e3dcd48eba [root@docker ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 [root@docker ~]# docker-enter node1 #进去之后修改主机名，因为主机名个宿主机一样，貌似-h也指定不了主机名 [root@node1 ~]# yum install -y net-tools [root@node1 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 第二种网络模式containercontainer模式: 使用--net=container:container_id/container_name多个容器使用共同的网络,看到的ip是一样的. [root@docker ~]# docker run -itd -h node2 --name node2 --net=container:node1 centos bash #此处不能指定主机名创建，否则失败 /usr/bin/docker-current: Error response from daemon: Conflicting options: hostname and the network mode. See &apos;/usr/bin/docker-current run --help&apos; [root@docker ~]# docker run -itd --name node2 --net=container:node1 centos bash 0fc16c4a055cf0035c1241ba6cce6c5ad0c711f2ef13e0589c3254f19a96b271 [root@docker ~]# docker-enter node2 [root@node2 ~]# yum install -y net-tools [root@node2 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; #和node1的ip一样，也和宿主机的ip一样（node1使用的是--net=host模式） 172.17.82.185 第三种网络模式nonenone模式: 使用--net=none, 这种模式下,不会配置任何网络 [root@docker ~]# docker run -itd -h node3 --name node3 --net=none centos c1f4bd859566f11517248718a94456066d16ad66748a2c78743881e450d4ca09 [root@docker ~]# docker-enter node3 [root@node3 ~]# ping www.baidu.com ping: www.baidu.com: Name or service not known 第四种网络模式bridgebridge模式: 使用--net=bridge.创建完容器默认为这种网络模式.类似与vmware的nat网络模式. [root@docker ~]# docker run -itd -h node4 --name node4 --net=bridge centos bash fc4f817e741f22615d0cdbab6608877d268ea15be6ba790cae5706d03871ac41 外部访问容器[root@docker ~]# docker run -itd -h node1 --name node1 centos bash 27df97f0e77e745660ee7b9c8b318c64f63e6aa632db3d3b0c44c4e0f4006124 [root@docker ~]# docker-enter node1 [root@node1 ~]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@node1 ~]# yum install -y nginx [root@docker ~]# docker commit -m &quot;nginx&quot; -a &quot;tang&quot; 27df97f0e77e nginx:v1 #此处仅容器做为镜像，主要是减少以后重复性的工作，不需要新建一个容器在部署nginx [root@docker ~]# docker run -itd -h nginx --name nginx -p 81:80 nginx:v1 bash #-p 端口映射，射到宿主机81端口上 a5dd375e829d05734a935d5f41723841568b543822a64a4ec277480f5f552e41 [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# /usr/sbin/nginx [root@nginx ~]# echo &quot;TangXiaoyue&quot; &gt; /usr/share/nginx/html/1.html [root@nginx ~]# curl 127.0.0.1/1.html TangXiaoyue [root@nginx ~]# exit logout [root@docker ~]# curl 127.0.0.1:81/1.html TangXiaoyue 容器互联1.安装mysql [root@docker ~]# docker run --privileged -itd -h node1 --name node1 centos /sbin/init fd547b535ff3af19bf36b219f542864962d60480a8d56836db30c20f079ec43f [root@docker ~]# docker-enter node1 [root@node1 ~]# yum install -y wget [root@node1 ~]# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# rpm -ivh mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# yum install mysql-community-server [root@node1 ~]# systemctl start mysql.service [root@node1 ~]# mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); 2.制作mysql镜像 [root@docker ~]# docker commit -m &quot;mysql&quot; -a &quot;tang&quot; fd547b535ff3 mysql:v1 sha256:21af416e70b0302163e4aa279118afdd96a0c8590487268a3d26920caf6c5d1a [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql v1 21af416e70b0 4 seconds ago 797.3 MB [root@docker ~]# docker run --privileged -itd -h mysql --name mysql mysql:v1 /sbin/init 8d71a34516a2c05a7ea63fde5773785360d1301509d687797eec5ead62a01d55 3.以mysql、nginx镜像分别创建两个容器并端口映射 [root@docker ~]# docker run -itd -h nginx --name nginx -p 10080:80 --link mysql:db nginx:v1 bash 8aea6116f67c9760b8f4d3de08251b28af839b9e2195860ad4b24d54833c286a [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# yum install -y telnet [root@nginx ~]# telnet db 3306 Trying 172.18.0.3... Connected to db. Escape character is &apos;^]&apos;. CHost &apos;172.18.0.4&apos; is not allowed to connect to this MySQL serverConnection closed by foreign host. [root@nginx ~]# cat /etc/hosts 172.18.0.3 db mysql mysql 172.18.0.4 nginx 配置网桥(centos7)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（2）--命令]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89--%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[安装下载yum install -y docker #下载 systemctl start docker #启动 systemctl enable docker #自启动 镜像操作docker search images #搜索镜像 docker pull images #下载镜像 docker images #查看镜像 docker tag centos6 centos6_x86 #镜像改名 docker save image&gt;/opt/images.tar.gz #导出镜像 docker load&lt;/opt/images.tar.gz #导入镜像 docker load --input /opt/images.tar.gz #导入镜像 docker rmi images_id #删除镜像 docker rmi $(docker images -q) #删除所有镜像 容器操作docker ps -a #查看容器 docker run centos /bin/echo &quot;hehe&quot; #首次创建一个容器 docekr run -h tang --name tang -t -i centos /bin/bah #创建一个以tang为名的容器； --name：指定容器名 -t：分配一个tty终端 -i：容器的标准输出保持打开状态 -h:指定主机名 docker create -it --name centos1 centos #使用create创建容器 docekr stop ID（name） #停止容器 docker start ID（name） #启动容器 docker attach ID（name） #进入容器 docker exec -it ID(name) /bin/bash docker rm ID（name） #删除容器 -f：强制删除容器，包括在运行的 #exec和attach总结: attach登陆容器后,退出时容器会关闭. 推荐使用exec进入容器 docker rm $(docker ps -a -q) #删除所有容器 映射docker run --name nginx -d -P nginx #随机映射 docker run --name nginx -d -p 81:80 nginx #指定映射 docker run -it --name nginx -p 80:80 nginx /bin/bash #指定映射 日志docker logs ID（name） #查看日志 数据管理docker run -it --name tang -v /data centos #默认挂载目录 docekr inspect ID(name) #查看容器信息 ==查看mounts模块 docekr run -it --name tang -v /data:/data centos #指定挂载目录 docker run -it --name tang -v /data:/data:rw centos #指定权限挂载 ==rw：读写 docker run -it --name tang -v /data:/data:ro centos #指定权限挂载 ==ro：只读 docker run -it --name tang ~/.bash_history:/.bash_history centos #记录历史记录 数据卷容器docker run -d --name nfs -v /data:/data centos #启动nfs容器，挂在一个卷， -d：直接在后台执行 docker run -it --name test1 --volumes-from nfs centos #启动test1容器，挂载到nfs的数据卷容器上 docker run -it --name test2 --volumes-from nfs centos #启动test2容器，挂载到nfs的数据卷容器上 #test1和test2的/data数据可以共享 手动制作镜像docker run -it --name mynginx centos #基础centos进行创建容器mynginx 在mynginx容器内安装nginxrpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm yum install -y nginx docker commit -m &quot;my nginx&quot; f9c7dfb6f552 tang/mynginx:v1 #提交镜像， ==同时打一个标签叫mynginx:v1 ==tang相当于你向github上提交的用户名 docker run -it --anme nginxv1 tang/mynginx:v1 #基于镜像tang/mynginx:v1创建容器nginxv1 ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（4）--镜像管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89--%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[使用容器生成镜像[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker run -it -h nginx --name nginx centos /bin/bash [root@nginx /]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@nginx /]# yum install -y nginx [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e46c71171306 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 40 seconds ago nginx [root@tang ~]# docker commit -m &quot;my nginx&quot; -a &quot;tang&quot; e46c71171306 new_nginx:v1 sha256:c15ceb0a6871e3a56e3b22d67254d09b2e03a8ae909719a6dea0daaf937940ef -m: 改动信息 -a: 作者信息 e46c71171306: 这一串为容器ID new_nginx:01 新镜像的名字 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE new_nginx v1 c15ceb0a6871 About a minute ago 355 MB docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 基于本地模块创建镜像模版获取,直接到openva官网下载(https://openvz.org/Download/template/precreated) [root@tang opt]# wget http://download.openvz.org/template/precreated/centos-6-x86_64-minimal.tar.gz [root@tang opt]# cat centos-6-x86_64-minimal.tar.gz |docker import - centos6 sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c [root@tang opt]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos6 镜像导出/导入[root@tang opt]# docker save centos6 &gt;/opt/centos6.tar.gz #导出 [root@tang opt]# ll total 1539880 -rw-r--r-- 1 root root 565194752 Apr 2 16:19 centos6.tar.gz [root@tang opt]# docker rmi centos6 Untagged: centos6:latest Deleted: sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c Deleted: sha256:dbcc6b3893af5f0b45e06f2934f73f5dc34f2e9e54fc4d50a51cc47195f19089 [root@tang opt]# docker load &lt; /opt/centos6.tar.gz #导入 [root@tang opt]# docker load --input /opt/centos6.tar.gz #导入 #以上两种导入方法都可以 [root@tang opt]# docker tag centos6 centos6_x86 #改名 将镜像上传到dockerhub官网需要提前注册dockerhub账号 1. docker hub 帐号在本地验证登陆: [root@tang opt]# docker login Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one. Username: tangxiaoyue Password: Login Succeeded 2. docker push 镜像到docker hub 的仓库 docker push &lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt; [root@tang ~]# docker tag centos tangxiaoyue/centos_tang:latest [root@tang ~]# docker push tangxiaoyue/centos_tang The push refers to a repository [docker.io/tangxiaoyue/centos_tang] 9b198ff9ff5b: Mounted from library/centos latest: digest: sha256:be5b4a93f116a57ab3fd454ada72421eac892a3a4925627ac9a44f65fcd69cf8 size: 529]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（7）--数据管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89--%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[挂载本地目录到容器里[root@tang /]# mkdir /data/docker -p root@tang docker]# mkdir docker_01 [root@tang docker]# docker run -it -h docker_01 --name docker_01 -v /data/docker/docker_01/:/docker_01 centos bash [root@docker_01 /]# cd /docker_01/ [root@docker_01 docker_01]# touch docker_01.txt [root@docker_01 docker_01]# exit exit [root@tang docker]# cd /data/docker/docker_01/ [root@tang docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 08:03 docker_01.txt [root@tang docker_01]# cd .. [root@tang docker]# mkdir docker_02 [root@tang docker]# docker run -it -h docker_02 --name docker_02 -v /data/docker/docker_02/:/docker_02 centos bash [root@docker_02 /]# cd /docker_02/ [root@docker_02 docker_02]# mkdir docker_02.txt [root@docker_02 docker_02]# exit exit [root@tang docker]# cd docker_02/ [root@tang docker_02]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 08:05 docker_02.txt 提示： -v: 指定挂载目录 : : 前面的为本地目录 : : 后面到为容器里的目录 即使将删除这个容器,文件也不会丢失. 挂载数据卷(多个容器挂载宿主机的同一个目录)[root@tang data]# docker run -it -h docker_03 --name docker_03 --volumes-from docker_01 centos bash [root@docker_03 /]# cd /docker_01/ [root@docker_03 docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@docker_03 docker_01]# df -h|grep docker_01 /dev/vda1 99G 5.4G 88G 6% /docker_01 [root@docker_03 docker_01]# echo &quot;This is Doceker_3&quot; &gt; /docker_01/3.txt [root@docker_03 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@tang ~]# docker start docker_01 docker_01 [root@tang ~]# docker-enter docker_01 [root@docker_01 ~]# cd /docker_01/ [root@docker_01 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt 自定义数据卷容器[root@tang ~]# docker run -itd -h node --name node -v /data centos bash 056ac10e28855c3d29a94fe552711e6a712a5670e6e9c43c4b79270cbc6b0a0f #这里的/data是容器node的/data目录,而不是宿主机的/data目录 [root@tang ~]# docker-enter node [root@node ~]# touch /data/1 /data/2 /data/3 [root@node ~]# cd /data/ [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node data]# exit logout [root@tang ~]# docker run -itd -h node1 --name node1 --volumes-from node centos bash 2965a8f1184a7a1cbd26ef07e4b3d201fa17e5b68a52c619d6292da75c85d117 [root@tang ~]# docker-enter node1 [root@node1 ~]# cd /data/ [root@node1 data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node1 data]# touch 4 [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 -rw-r--r-- 1 root root 0 Apr 3 01:02 4 数据卷的备份[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 250da7a47222e52c5a5d387ff8ce816a72b221ffb8d481739c4c68073507fe [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /data [root@tang ~]# touch /data/{1,2,3,4} [root@tang ~]# tar cvf /backup/data.tar /data/ [root@tang ~]# cd /backup/ [root@tang backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 01:30 data.tar [root@tang backup]# exit logout [root@docker ~]# cd /docker_data_backup/ [root@docker docker_data_backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 09:30 data.tar 数据卷的恢复[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 3728f6b0a6e5b47f904de0474db7d4479f33e87740906e1539eca385c3fab04d [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /tools/ [root@tang ~]# touch /tools/{1,2,3,4} [root@tang ~]# tar zcvf /backup/tools.tar /tools/ /tools/ /tools/1 /tools/2 /tools/3 /tools/4 [root@tang ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang ~]# exit logout [root@docker ~]# docker run -itd -h tang1 --name tang1 -v /tang1 centos bash 7ec371bb67f136234878771c227c4245a0ccf6c986e8c94a412d6c4111852a2b [root@docker ~]# docker run -itd -h tang2 --name tang2 --volumes-from tang1 -v /docker_data_backup/:/backup centos bash 53e4cea1c45f3c081a6dd95b935f906aa037e6ed2170b6249a913ccd6fb4c119 [root@docker ~]# docker-enter tang2 [root@tang2 ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang2 tang1]# tar xvf /backup/tools.tar -C /tang1 [root@tang2 tang1]# exit logout [root@docker ~]# docker-enter tang1 [root@tang1 ~]# cd /tang1/ [root@tang1 tang1]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 02:07 tools]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XtraBackup主从复制及备份]]></title>
      <url>%2F2017%2F03%2F11%2FXtraBackup%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A4%87%E4%BB%BD%2F</url>
      <content type="text"><![CDATA[XtraBackup备份1、yum安装mysql（以centos7为例） ###主从操作一致 #查看操作系统版本： [root@node2 ~]# cat /etc/redhat-release CentOS Linux release 7.0.1406 (Core) #关闭防火墙和seLinux [root@node2 ~]# systemctl stop firewalld [root@node2 ~]# sed -i &quot;s#SELINUX=enforcing#SELINUX=disabled#g&quot; /etc/selinux/config [root@node2 ~]# setenforce 0 #yum安装mysql wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server systemctl start mysql.service mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); ###配置主从 主： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=1 从： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=2 2、安装xtrabackup备份软件（主从进行安装） wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.3.4/binary/redhat/6/x86_64/percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y epel-release yum localinstall percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y perl-Time-HiRes #查看版本 &gt;select version(); #查看前默认的存储引擎 &gt;show variables like &apos;%storage_engine%&apos;; 3、导入数据（为了模拟比较真实可以往主库导入数据）（主库操作） #导入bubi_api数据库 [root@node2 opt]# mysql -uroot -ppassword &lt; bubi_api.sql # 查看数据大小 &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed &gt; select concat(round(sum(data_length/1024/1024),2),&apos;MB&apos;) as data from tables; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.04 sec) 4、数据库备份（主操作） ###备份 [root@node2 opt]# mkdir /extrabackup [root@node2 opt]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=bubi --parallel=4 /mnt/resource/extrabackup ###出现completed OK! 表示备份成功 语法解释：–user=数据库用户 –password=数据库密码 –socket=指定socket –default-file=指定配置文件 - 最后面是存放位 ###保持事务一致（主操作） [root@node2 2017-02-17_14-45-11]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --parallel=4 --apply-log /extrabackup/2017-02-17_14-45-11/ ###出现completed OK!表示事务保持了一致，可以用于恢复 二、mysql主从同步操作 1、传输数据、将/extrabackup/2017-02-17_14-45-11/拷贝到从库 [root@node2 extrabackup]# scp -r 2017-02-17_14-45-11 root@192.168.1.13:/extrabackup/ 2、从库恢复数据 [root@node3 extrabackup]# ll 总用量 0 drwx------. 4 root root 47 2月 17 14:47 2017-02-17_14-45-11 #停止mysql [root@node3 extrabackup]# systemctl stop mysql #清空mysql data目录 [root@node3 extrabackup]# cd /var/lib/mysql [root@node3 mysql]# mv * /opt/mysqlbak/ #数据恢复 innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --copy-back /extrabackup/2017-02-17_11-49-35/ ###出现completed OK! 表示恢复成功 #还原权限 [root@node3 mysql]# cd .. [root@node3 lib]# chown mysql:mysql mysql -R #重启mysql并查看数据的大小 [root@node3 lib]# systemctl start mysql [root@node3 lib]# ps -ef | grep mysql mysql 8173 1 0 14:59 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe --basedir=/usr mysql 8338 8173 3 14:59 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sock root 8364 5840 0 15:00 pts/0 00:00:00 grep --color=auto mysql &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.26 sec) ###数据主从大小都一样 3、mysql主从同步操作 ###主库授权 &gt; GRANT REPLICATION SLAVE ON *.* TO &apos;rep&apos;@&apos;192.168.1.13&apos; IDENTIFIED BY &apos;123456&apos;; &gt;FLUSH PRIVILEGES; ###从库开启同步 [root@node3 mysql]# cat /extrabackup/2017-02-17_14-45-11/xtrabackup_binlog_info mysql-bin.000001 171510867 CHANGE MASTER TO MASTER_HOST=&apos;10.25.159.23&apos;, MASTER_USER=&apos;rep&apos;, MASTER_PASSWORD=&apos;db0226&apos;, MASTER_PORT=3306, MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;, MASTER_LOG_POS=982559769; ####在还没同步之前我们可以在主库继续增加入一个库，验证不锁表是否可以同步 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) #####开启主从同步 &gt;flush logs; &gt; start slave; ###从库操作 &gt; show slave status\G Slave_IO_Running: Yes Slave_SQL_Running: Yes ##查看从库数据 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) 注意： 1、当从库停掉了（宕机还没测试）。主库继续写入数据，从库开启时，会自动同步 ##########mysql命令 #查看binlog是否开启 &gt;show binary logs; #查看serverid &gt;show variables like &apos;server_id&apos;; #查看binlog模式 &gt;show variables like &apos;%log%&apos;; &gt;/dev/null 2&gt;&amp;1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（5）--容器管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[查看启动的容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f8c14f16e03 centos &quot;/bin/bash&quot; 5 minutes ago Up 2 minutes tang 查看所有的容器(包括启动、停止)[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e5d7ccb9522c centos &quot;/bin/bash&quot; 15 seconds ago Exited (0) 12 seconds ago tang1 2f8c14f16e03 centos &quot;/bin/bash&quot; 3 minutes ago Up 1 seconds tang Exited:表示该容器已经退出。没有启动 创建容器(create、run)、进入容器[root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB [root@tang ~]# docker create -it --name tang_create centos /bin/bash #使用create创建容器 3b316839ea357a3fe47fcae3488d6f491882ecb8c954412c502cbd6dcf9e2478 [root@tang ~]# docker run -it --name tang_run centos /bin/bash #使用run创建容器 [root@b5dbba42703a /]# exit exit 启动停止容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker start tang_run #start启动容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b5dbba42703a centos &quot;/bin/bash&quot; 4 minutes ago Up 14 seconds tang_run [root@tang ~]# docker stop tang_run #stop停止容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 创建容器,指定容器名[root@tang ~]# docker run -itd -h tang_run --name tang centos /bin/bash 8afe717f82718214056a61e3881552338d5c911d272a80342edec063b5048 -d: 容器退出后不关闭容器. -h:指定主机名 删除容器/镜像[root@tang ~]# docker rm tang #删除容器 [root@tang ~]# docker rm -f tang #强制删除容器，不管是否在运行 [root@tang ~]# docker rm $(docker ps -a -q) #删除所有容器 导出容器(可迁移到其它机器)/导入容器[root@tang ~]# docker export tang &gt;/opt/tang.tar #导出容器 [root@tang ~]# docker rm tang tang [root@tang ~]# cat /opt/tang.tar |docker import - tang #恢复的只是一个镜像，需要通过镜像创建容器 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tang latest 393d449b1ed4 44 seconds ago 192.5 MB 提示：如果在之前那个容器内创建的文件，导出，导入之后容器内的文件是不变的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法大全]]></title>
      <url>%2F2017%2F03%2F11%2FMarkdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[题记：随着Markdown语言的热度不断提升，越来越多的人喜欢使用Markdown这种简洁、便宜的语言来编辑自己的blog、文章。下面笔者就一些简单常用的Markdown语句进行介绍，希望对大家在进行Markdown语言编辑自己的文章时有所帮助。 1.斜体和粗体 代码： 1. *斜体*或_斜体_ 2. **粗体** 3. ***加粗斜体*** 显示效果： 这是一段斜体 这是一段粗体 这是一段加粗斜体 2.分级标题 第一种写法： 1.这是一个一级标题 2.================ 3. 4. 这是一个一级标题 5. -------------------------- 第二种写法： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3.超链接行内式 代码： 1.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk) 2. 3.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk &quot;梵居闹市&quot;) 显示效果： 欢迎来到梵居闹市欢迎来到梵居闹市 参考式 代码： 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]: http://www. google.com &quot;Google&quot; [2]:http://www. leanote.com &quot;Leanote&quot; [3]:http://http:/ /blog.leanote.com/freewalk &quot;梵居闹市&quot; [网站]:http: //http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 自动链接 代码： &lt;http://example.com/&gt; &lt;address@example.com&gt; 显示效果： http://example.com/&#97;&#100;&#x64;&#x72;&#101;&#x73;&#115;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#109; 4.锚点 代码： 跳转到[目录](#index) 显示效果： 跳转到目录 5.列表无序列表 使用 *，+，- 表示无序列表。 代码： 无序列表项 一 无序列表项 二 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表 代码： 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 列表缩进 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 包含段落的列表 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表 代码： * 阅读的方法:（一个空格） &gt; 打开书本。 &gt; 打开电灯。 显示效果： 阅读的方法: 打开书本。打开电灯。 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 一列表项包含一个列表区块： &lt;代码写在这&gt; 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 会显示成： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 1986\. What a great season. 会显示成：1986. What a great season. 6. 引用 代码： &gt; 这是一个有两段文字的引用, &gt; 无意义的占行文字1. &gt; 无意义的占行文字2. &gt; &gt; 无意义的占行文字3. &gt; 无意义的占行文字4 显示效果： 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4. 引用的多层嵌套 代码： &gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白 &gt;&gt; 自己看教程！ - 愤青 &gt; 教程在哪？ - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 引用其它要素 代码： &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 显示效果： 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像行内式 代码： 高圆圆： ![高圆圆](ht tp://pic2016.5442.com:82/2015/1117/16/7.jpg%21960.jpg &quot;高圆圆&quot;) 显示效果 高圆圆： 8. 内容目录 markdownpad居然不支持该语法，我就呵呵了. 代码： [TOC]0.目录 [TOC]1. 斜体和粗体 [TOC]2. 分级标题 [TOC]3. 超链接 [TOC] 行内式 [TOC] 参考式 [TOC] 自动链接 [TOC]4. 锚点 9. 注脚 代码： 使用 Markdown[1]可以效率的书写文档,你可以使用 Leanote[Le] 编辑器进行书写。 [1]:Markdown是一种纯文本标记语言 [Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果： 使用 Markdown1可以效率的书写文档,你可以使用 LeanoteLe 编辑器进行书写。 原文链接：http://blog.leanote.com/post/freewalk/Markdown-语法手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo常用命令]]></title>
      <url>%2F2017%2F03%2F11%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Hexo部署步骤 npm install npm install hexo-deployer-git --save hexo new &quot;新页面&quot; hexo clean hexo generate hexo deploy Hexo常用命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令的简写为： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB（1）--简介]]></title>
      <url>%2F2017%2F01%2F02%2FMongoDB%EF%BC%881%EF%BC%89--%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[简介MongoDB 是一个跨平台的，面向文档的开源数据库，并领先的 NoSQL 数据库。 MongoDB是由c++语言编写。提供高性能，高可用性和可扩展性方便。 MongoDB 工作在收集和文件的概念。 数据库数据库是一个物理容器集合。每个数据库都有自己的一套文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库。 集合集合是一组MongoDB的文档。它相当于一个RDBMS表。收集存在于一个单一的数据库。集合不执行模式。集合内的文档可以有不同的领域。通常情况下，一个集合中的所有文件是相同或相关的目的。 文档文档是一组键 - 值对。文件动态模式。动态模式是指，在相同集合中的文档不需要具有相同的字段或结构组的公共字段的集合的文档，可以容纳不同类型的数据。 下面给出的表显示RDBMS术语使用 MongoDB 的关系12345678910RDBMS MongoDBDatabase DatabaseTable CollectionTuple/Row Documentcolumn FieldTable Join Embedded DocumentsPrimary Key Primary Key (Default key _id provided by mongodb itself) 数据库服务器和客户端Mysqld/Oracle mongodmysql/sqlplus mongo 示例文档下面给出的示例显示了一个博客网站，这简直是一个逗号分隔的键值对文档结构。1234567891011121314151617181920212223&#123; _id: ObjectId(7df78ad8902c) title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by: &apos;yiibai.com&apos;, url: &apos;http://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100, comments: [ &#123; user:&apos;user1&apos;, message: &apos;My first comment&apos;, dateCreated: new Date(2011,1,20,2,15), like: 0 &#125;, &#123; user:&apos;user2&apos;, message: &apos;My second comments&apos;, dateCreated: new Date(2011,1,25,7,45), like: 5 &#125; ]&#125; _id是一个12字节的十六进制数，保证每一份文件的唯一性。您可以提供_id同时插入文档。如果没有提供，那么MongoDB的每个文档提供了一个独特的ID。这12个字节，前4个字节为当前时间戳，未来3个字节的机器ID，接下来的2个字节的进程id MongoDB的服务器及剩余3个字节是简单的增量值。 MongoDB比RDBMS的优势1.架构：MongoDB是文档型数据库，其中一个集合保存不同的不同的文件。字段的数量，内容和该文件的大小可以是不同于从一个文件复制到另一个。2.一个单一的对象，结构相对清晰3.没有复杂的连接4.深查询能力。 MongoDB支持动态查询使用基于文档的查询语言，如SQL几乎一样强大的文件5.调优6.易于规模化：MongoDB是易于扩展7.不需要数据库对象的应用程序对象转换/映射8.使用内部存储器存储（窗口）工作组，从而实现更快的数据存取 为什么要使用MongoDB1.JSON风格文件的形式，面向文档存储：数据存储2.对任何属性可索引3.复制和高可用性4.自动分片5.丰富的查询6.快速就地更新7.MongoDB的专业技术支持 MongoDB应用领域1.大数据2.内容管理和交付3.移动和社交基础设施5.用户数据管理6.数据平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运维与自动化发展(1)]]></title>
      <url>%2F2017%2F01%2F01%2F%E8%BF%90%E7%BB%B4%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B1%95%2F</url>
      <content type="text"><![CDATA[一、运维学习和发展的一个线路1.搭建服务（部署并运行起来） 2.用好服务（监控、管理、优化） 3.自动化（服务直接的关联和协同工作） 4.产品设计（如何设计一个监控系统） 云计算的核心竞争力是运维！ 系统架构师（还有偏管理系统架构师）：网络 系统 数据库 开发 云计算 自动化 运维管理 服务管理 项目管理 测试 业务 ==比较难学的开发和业务（相对于运维来说） 专注于某一领域：资深、科学家 二、运维知识体系赵班长运维知识体系：https://www.unixhot.com/page/ops 运维工作内容分类： 监控运维（7X24运维值班、故障处理） 应用运维（业务熟悉、服务部署、项目上线、业务部署、版本管理、灰度发布、日志收集、应用监控） 安全运维（整体的安全方案、规范、漏洞检测、安全防护等） 系统运维（架构层面的分布式缓存、分布式文件系统、环境规划（测试、开发、生产）、架构设计、性能优化） 基础服务运维（包含运维开发）（内部DNS、负载均衡、系统监控、资产管理、运维平台） 基础设施运维（系统初始化、网络维护） 机房运维（负责设备上下架、巡检、保修、硬件监控） 三、运维自动化发展发展层级： 智能化 服务化、api化 Web化、平台化 标准化、工具化 1.标准化物理设备层面： 1.服务器标签化、设备负责人、设备采购详情、设备摆放标准（例如：负载均衡两台机器不能放同一机柜）。 2.网络划分、远程控制卡、网卡端口 3.服务器机型、硬盘、内存统一。根据业务分类 4.资产命名规范、编号规范、类型规范 5.监控标准 操作系统层面： 1.操作系统版本 2.系统初始化（DNS、NTP、内存参数调优、rsyslog、主机名规范） 3.基础Agent配备（zabbix Agent、logstach Agent、saltstack monitor） 4.系统监控标准（cpu、内存、硬盘、网络、进程） 应用服务层面： 1.Web服务器选型（apache、nginx） 2.进程启动用户、端口监听规范、日志收集规范（访问日志、错误日志、运行日志） 3.配置管理（配置文件规范、脚本规范） 4.架构规范（nginx+keepalived、lvs+keepalived等等） 5.部署规范（位置、包命名等） 运维操作层面： 1.机房巡检流程（周期、内容、报修流程） 2.业务部署流程（先测试、后生成。回滚） 3.故障处理流程（紧急处理、故障升级） 4.工作日志标准（如何编写工作日志） 5.业务上线流程（1.项目发起人 2.系统安装 3.部署nginx 4.解析域名 5.测试 6.加监控 7.备份） 6.业务下线流程（1.谁发起 2.数据如何处理 3.服务器回收 4.系统是否重装） 7.运维安全规范（密码复杂度、更改周期、vpn使用规范、服务器登入规范） 标准化（规范化、流程化、文档化） 目标：文档化 2.工具化1.shell脚本（功能性（流程）、坚持性、报表性） 2.开源工具：Zabbix ELKstack SaltStack cobbler 目标： 1.促进标准化的实施 2.将重复的操作，简单化 3.将多次操作，流程化 4.减少人为操作的低效和降低故障率 工具化和标准化是好基友！！！ 痛点： 1.你至少要ssh到服务器执行，可能犯错 2.多个脚本有执行顺序的时候，可能犯错 3.权限不好管理，日志没法统计。 4.无法避免手工操作 例子：比如某天我们要对一台数据库从库进行版本升级。那么要求进行评估： 停机的影响：3:00晚上有定时任务链接该数据库，做数据报表统计。 1.凌晨3:00我们所有系统的定时任务有哪些 crontab 2.这些croneab哪些连接我们要停止的从库 3.哪些可以停，哪些不能停（修改到主库），哪些可以后补 4.这些需要后补的脚本哪个业务，谁加的，什么时候加的 3.Web化（运维操作平台）1.做成Web界面 2.权限控制 3.日志记录 4.弱化流程 5.不用ssh到服务器，减少人为操作造成的故障 4.服务化（API化）DNS Web管理 bind-DLZ dns-api 负载均衡Web管理 slb-api Job管理平台 job-api 监控Web管理 zabbix zabbix-api 操作系统安装平台 cobbler-api 部署平台 deploy-api 配置管理平台 saltstack-api 自动化测试平台 test-api 1.调用cobbler-api安装操作系统 2.调用saltstack-api进行系统初始化 3.调用dns-api解析主机名 4.调用zabbix-api将新上线机器加上监控 5.再次调用saltstack-api部署软件（安装Nginx+php） 6.调用deploy-api 将当前版本的代码部署到服务器上 7.调用test-api 测试当前服务器运行十分正常 8.调用slb-api 将该节点加入集群 5.智能化 智能化的自动化扩容、缩容、服务降级、故障自愈 触发机制--&gt;决策系统（决策树） 一、自动化扩容 1.zabbix触发Action 触发： 1.当某个集群的访问量超过最大的支撑量，比如10000 1.1.cpu使用率达到多少 2.并持续5分钟 3.不是攻击 4.资源池有可用资源 4.1.当前网络带宽使用率 4.2.如果公有云-钱够不够 5.当前后端服务支撑量是否超过阈值，如果超过应该后端先扩容 6.数据库是否可以支撑当前并发 7.当前自动化扩展队列，是否有正在扩容的节点 8.其它业务相关的 决策之前：先判断buffer是否有最近X小时，已经移除的之前创建的虚拟机。并查询软件版本是否和当前一致，如果一致，跳过2 3 4步骤。如果不一致，跳过2 3步骤 2.Openstack 创建虚拟机 3.Saltstack配置环境---监控 4.部署系统当前代码 5.测试服务是否可用（注意间隔和次数） 6.加入集群 7.通知（短信、邮件、花费时间） 二、自动化缩容 1.触发条件和决策 2.从集群中移除节点---先关闭监控--移除 3.通知 4.移除的节点存放在buffer里面 5.buffer里面超过一天的虚拟机，自动关闭，存放于某去 6.某区的虚拟机，每7天清理删除 1.部署openstack 2.在openstack上创建虚拟机 3.在虚拟机上部署Mesos+docker+Marathon 4.自动化创建Docker容器进行自动化扩容 四. 基于ITIL的运维管理体系1. ITIL 简介什么是服务： 服务是向客户提供的一种手段，使客户不用承担特定的成本和风险就可以获得所期望的结果。 什么是服务管理： 服务管理是一套特定的组织能力，以服务的形式为客户提供价值 ITSM 和ITIL 的关系： 1.现有ITSM，后有ITIL。 2.因为ITIL，ITSM得到关注和发扬 3.ITIL是ITIM的最佳时间.ITIL为ITSM创建了一组核心流程和专有名词 4.ITIL并不是ITSM的全部，ITIL只是告诉我们，什么该做，但没有说具体该怎么做。而对ITSM而言，这些都是ITSM的范围。 ITIL是： ITIL即IT基础架构库（Information Technology Infrastructure Library）。 英国商务办公司从20世纪80年代开始开发的一套IT管理方法。 已成为事实上的行业标准，并以其为中心在全球形成了完整的产业。 任何单位和个人都可以免费试用的“公共框架”。 实际上是一系由所谓“最佳实践”形成图书。 一个可以直接使用的标准。 ITIL的目的： 1.将IT管理工作标准化，模式化，减少人为误操作带来的隐患 2.通过服务目录，服务报告，告诉业务部门，我们可以做什么，做了什么 3.通过系列流程，只是库减轻对英雄式工程师的以来，把经验积累下来。 4.通过对流程的管控，减少成本，降低风险，提供客户满意度 ITIL和ISO 20000 ITIL自发布以来，一直被业界认为是IT服务管理领域事实上的管理标准，直到2000年11月，英国标准协会（BSI）正式发布了以ITIL为核心的国家标准BS15000； 随后，2005年5月，国际标准化组织（ISO）快速通道的方式批准通过了ISO2000的标准协议，并于12月15日正式发布了ISO20000标准。 ITIL和ISO20000区别 ITIL ISO2000 提供最佳实践指导 提供衡量ITSM的指标 没有固定的能力衡量指标 全球统一 对人员进行认证 对机构进行认证 咨询机构提供他们眼中的ITSM成熟度结果 关注于服务提供的独立认证，从IT服务管理体系的角度出发 ITSM内容 管什么（管理对象） 怎么管（管理方法） 管得咋样（成熟度） IT service CMM 初始级： 被动相应，没有文档记录，几乎没有过程，是经过定义的 ； 各项目经验无法重用，以来与个人的努力和永雄主义 可重复级： 建立了基本的服务管理过程； 所有项目有默认的规则，但未文档化，系统化； 产品或服务化无清晰的目标和策略； 定义级： 已将IT服务过程文档化，标准化，并综合成标准服务过程； 根据客户需求调整服务产品和服务战略； 适当的工具和信息报告； 管理级： 受监督、测量的IT服务体系； 根据业务战略调整服务体系； 优化级（PDCA）： 持续改进的IT服务体系； IT与业务指标建立关系； IT与业务协作改进流程； 成为运维经理： 1.技术，运维只是体系 2.服务管理ITIL 项目管理PMP 3.做人 五. ITIL 服务运营ITIL v3 将ITIL理论分成五部分： 1.服务战略 2.服务设计 3.服务转换 4.服务运营 5.持续服务改进 ITIL v3 核心模块 服务运营： SLA：服务级别协议 OLA：运营水平协议 CSF：关键成功因素 KPI：关键绩效指标 客户要求——SLA——OLA——CSF——KPI——月报 服务台： 作为IT服务支持团队的一线支持，其首要目标是为用户和IT组织之间建立沟通的纽带； 确保用户的故障请求和服务请求能够以最快的速度得到满足，并确保用户满意。 服务台作用： 1.路由器 2.监视器 3.单一联系点 4.客服窗口 5.广播台 6.过滤器 六. 服务运营-故障管理1.故障管理的目标： 故障管理的目标是尽可能快的恢复正常的服务运营，将故障对业务运营的负面影响减少到最低。 并确保到达最好的服务质量和可用性水平。 2.故障优先级： --紧急度 --影响度 3.故障输入输出： 故障管理流程输入 故障请求提交 故障单记录模板 故障单填写模板 故障分类规则 故障优先级确定规则 故障升级规则 故障处理时间规则 故障关闭规则 故障管理流程输出： 故障历史记录 故障分类汇总统计表 故障处理用户满意度 4.故障管理的绩效指标（KPI） 一线支持解决的事故百分比 无升级的平均呼叫时长 分配错误的事故百分比 在目标时间之内，按照优先级解决的事故百分比 二线支持平均响应时间 事故平均解决时间 重新分配的事故百分比 归类错误的事故百分比 绕过一线支持的呼叫百分比 客户满意度 服务请求呼叫百分比 一次解决正确的事故百分比 主动解决的事故百分比 5.服务运营-问题管理 问题管理的目标： 问题管理的主要目标是预防问题产生及由此引发的故障，消除重复的出现故障，并对不能预防的故障尽量减低其对业务的影响 问题管理对业务的价值： 提供IT服务的可用性 提高业务和IT人员的生成效率 减少无效的规避措施或修补措施的开支 减少在救火或解决重复故障方面的成本 有助于知识库的积累]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux下防御DDOS攻击的操作梳理]]></title>
      <url>%2F2016%2F12%2F11%2FLinux%E4%B8%8B%E9%98%B2%E5%BE%A1DDOS%E6%94%BB%E5%87%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[DDOS介绍DDOS的全称是Distributed Denial of Service，即”分布式拒绝服务攻击”，是指击者利用大量“肉鸡”对攻击目标发动大量的正常或非正常请求、耗尽目标主机资源或网络资源，从而使被攻击的主机不能为合法用户提供服务。 DDOS攻击的本质是：利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。 可以参考下面的例子理解下DDOS攻击。1）某饭店可以容纳100人同时就餐，某日有个商家恶意竞争，雇佣了200人来这个饭店坐着不吃不喝，导致饭店满满当当无法正常营业。（DDOS攻击成功）2）老板当即大怒，派人把不吃不喝影响正常营业的人全都轰了出去，且不再让他们进来捣乱，饭店恢复了正常营业。（添加规则和黑名单进行DDOS防御，防御成功）3）主动攻击的商家心存不满，这次请了五千人逐批次来捣乱，导致该饭店再次无法正常营业。（增加DDOS流量，改变攻击方式）4）饭店把那些捣乱的人轰出去只后，另一批接踵而来。此时老板将饭店营业规模扩大，该饭店可同时容纳1万人就餐，5000人同时来捣乱饭店营业也不会受到影响。（增加硬防与其抗衡） DDOS攻击只不过是一个概称，其下有各种攻击方式，比如:”CC攻击、SYN攻击、NTP攻击、TCP攻击、DNS攻击等等”，现在DDOS发展变得越来越可怕，NTP服务放大攻击渐渐成为主流了，这意味着可以将每秒的攻击流量放大几百倍，比如每秒1G的SYN碎片攻击换成NTP放大攻击，就成为了200G或者更多。 NTP放大攻击什么是NTP服务？网络时间协议NTP（Network Time Protocol）是用于互联网中时间同步的标准互联网协议。NTP服务器通过NTP服务向网络上的计算机或其他设备提供标准的授时服务，以保证这些服务系统的时钟能够同步。通常NTP服务使用UDP 123端口提供标准服务。 什么是NTP服务放大攻击？标准NTP 服务提供了一个 monlist查询功能，也被称为MON_GETLIST，该功能主要用于监控 NTP 服务器的服务状况，当用户端向NTP服务提交monlist查询时，NTP 服务器会向查询端返回与NTP 服务器进行过时间同步的最后 600 个客户端的 IP，响应包按照每 6 个 IP 进行分割，最多有 100 个响应包。由于NTP服务使用UDP协议，攻击者可以伪造源发地址向NTP服务进行monlist查询，这将导致NTP服务器向被伪造的目标发送大量的UDP数据包，理论上这种恶意导向的攻击流量可以放大到伪造查询流量的100倍。 NTP是用UDP传输的，所以可以伪造源地址。NTP协议中有一类查询指令，用短小的指令即可令服务器返回很长的信息，放大攻击就是基于这类指令的。比如：小明以吴一帆的名义问李雷”我们班有哪些人？” ,李雷就回答吴一帆说”有谁谁谁和谁谁谁……”””(几百字),那么小明就以8个字的成本，令吴一帆收到了几百字的信息，所以叫做放大攻击。(也就是说：对方服务器是个话唠，你以小明的身份问他一个问题，他回答小明一千句，结果小明崩溃了） 网络上一般NTP服务器都有很大的带宽，攻击者可能只需要1Mbps的上传带宽欺骗NTP服务器，即可给目标服务器带来几百上千Mbps的攻击流量，达到借刀杀人的效果。所以现在新的ntpd已经可以通过配置文件，关掉除时间同步以外的查询功能。而时间同步的查询和返回大小相同(没记错的话)，所以没办法用作放大攻击。 如何查看是否遭受NTP放大攻击？如果网络上检测到大流量的UDP 123端口的数据，就可以确认正在遭受此类攻击。 如何防范NTP放大攻击？1)升级服务程序版本将系统中的NTP服务升级到 ntpd 4.2.7p26 或之后的版本，因为 ntpd 4.2.7p26 版本后，服务默认是关闭monlist查询功能的。 2)关闭服务的monlist查询功能：首先查询问题主机的REQ_MON_GETLIST和REQ_MON_GETLIST_1请求是否可用。具体操作方法：123# ntpq -c rv&lt;localhost/remotehost&gt;# ntpdc -c sysinfo&lt;localhost/remotehost&gt;# ntpdc -n -c monlist&lt;localhost/remotehost&gt; 如果上述功能可用，可尝试通过修改ntp.conf文件解决问题，具体操作建议是在上述配置文件中增加下面的配置：12IPV4: restrict default kod nomodify notrap nopeer noqueryIPv6: restrict -6 default kod nomodify notrap nopeer noquery 允许发起时间同步的IP，与本服务器进行时间同步，但是不允许修改ntp服务信息，也不允许查询服务器的状态信息（如monlist）*/ 另外，还可以配置限制访问命令，如： restrict default noquery #允许普通的请求者进行时间同步，但是不允许查询ntp服务信息*/ 修改并保存配置文件之后，请重启ntpd服务。 重大的DDOS攻击案例）2000年2月，包括雅虎、CNN、亚马逊、eBay、http://Buy.com、ZDNet，以及E*Trade和Datek等网站均遭受到了DDOS攻击，并致使部分网站瘫痪。2）2007年5月，爱沙尼亚三周内遭遇三轮DDOS攻击,总统府、议会、几乎全部政府部门、主要政党、主要媒体和2家大银行和通讯公司的网站均陷入瘫痪，为此北约顶级反网络恐怖主义专家前往该国救援。3）2009年519断网事件导致南方六省运营商服务器全部崩溃，电信在南方六省的网络基本瘫痪。2009年7月，韩国主要网站三天内遭遇三轮猛烈的DDOS攻击，韩国宣布提前成立网络司令部。4）比较著名的案例还有有： 全球三大游戏平台：暴雪战网、Valve Steam和EA Origin遭到大规模DDoS攻击，致使大批玩家无法登录与进行游戏。随后名为DERP的黑客组织声称对此次大规模的DDoS攻击行动负责。 DDOS攻击的简单防护措施1）关闭不必要的服务和端口；2）限制同一时间内打开的syn半连接数目；3）缩短syn半连接的超时时间；4）及时安装系统补丁；5）禁止对主机非开放服务的访问；6）启用防火墙防DDOS属性。硬件防火墙价格比较昂贵，可以考虑利用Linux系统本身提供的防火墙功能来防御。7）另外也可以安装相应的防护软件，这里强烈建议安装安全狗软件,防护性能不错，并且免费。8）购买DDOS防御产品，比如阿里云盾的DDOS防御中的高防IP，这个使用起来，效果也很给力。 linux下预防DDOS攻击的操作Linux服务器在运行过程中可能会受到黑客攻击，常见的攻击方式有SYN，DDOS等。通过更换IP，查找被攻击的站点可能避开攻击，但是中断服务的时间比较长。比较彻底的解决方法是添置硬件防火墙，但是硬件防火墙价格比较昂贵。可以考虑利用Linux系统本身提供的防火墙功能来防御。SYN攻击是利用TCP/IP协议3次握手的原理，发送大量的建立连接的网络包，但不实际建立连接，最终导致被攻击服务器的网络队列被占满，无法被正常用户访问。Linux内核提供了若干SYN相关的配置，加大SYN队列长度可以容纳更多等待连接的网络连接数，打开SYN Cookie功能可以阻止部分SYN攻击，降低重试次数也有一定效果。而DDOS则是通过使网络过载来干扰甚至阻断正常的网络通讯，通过向服务器提交大量请求，使服务器超负荷，阻断某一用户访问服务器阻断某服务与特定系统或个人的通讯。可以通过配置防火墙或者使用脚本工具来防范DDOS攻击； 优化sysctl内核参数12345678910111213141516[root@test3-237 ~]# vim /etc/sysctl.conf......net.ipv4.tcp_max_syn_backlog = 4096 #表示SYN队列的长度，加大队列长度可以容纳更多等待连接的网络连接数net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies功能。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭，1表示打开；net.ipv4.tcp_synack_retries = 2 #下面这两行表示定义SYN重试次数net.ipv4.tcp_syn_retries = 2 #提高TCP连接能力net.ipv4.tcp_rmem = 32768net.ipv4.tcp_wmem = 32768net.ipv4.tcp_sack = 0 #打开tcp_sack功能，1表示&quot;关闭&quot;，0表示&quot;打开&quot; ...... [root@test3-237 ~]# sysctl -p #使上面配置生效 iptables防火墙预防12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364先查看服务器上连接web端口（比如80端口）的哪个ip是最多的，如果发现可疑ip，就果断将其断开与服务器连接 查看80端口的连接情况[root@test3-237 ~]# netstat -an | grep &quot;:80&quot; | grep ESTABLISHED 下面的命令表示获取服务器上ESTABLISHED连接数最多的前10个ip，排除了内部ip段192.168|127.0开头的。[root@test3-237 ~]# /bin/netstat -na|grep ESTABLISHED|awk &apos;&#123;print $5&#125;&apos;|awk -F: &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -rn|head -10|grep -v -E &apos;192.168|127.0&apos; 4001 140.205.140.205 2388 124.65.197.154 1807 111.205.224.15 18 10.51.58.16 ....... 将上面140.205.140.205、124.65.197.154、111.205.224.15的这三个ip的包丢弃[root@test3-237 ~]# iptables -A INPUT -s 140.205.140.205 -p tcp -j DROP[root@test3-237 ~]# iptables -A INPUT -s 124.65.197.154 -p tcp -j DROP[root@test3-237 ~]# iptables -A INPUT -s 111.205.224.15 -p tcp -j DROP[root@test3-237 ~]# service iptables save[root@test3-237 ~]# service iptables restart 不过上面的方法对于伪造源IP地址的SYN FLOOD攻击就无效了！ -------------------------------------其他预防攻击的设置-------------------------------------防止同步包洪水（Sync Flood），缩短SYN-Timeout时间：[root@test3-237 ~]# iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT[root@test3-237 ~]# iptables -A INPUT -i eth0 -m limit --limit 1/sec --limit-burst 5 -j ACCEPT 其中：--limit 1/s 限制syn并发数每秒1次，可以根据自己的需要修改防止各种端口扫描[root@test3-237 ~]# iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT Ping洪水攻击（Ping of Death）[root@test3-237 ~]# iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT 控制单个IP的最大并发连接数。如下设置表示：允许单个IP的最大连接数为 30[root@test3-237 ~]# iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT 控制单个IP在一定的时间（比如60秒）内允许新建立的连接数。如下设置表示：单个IP在60秒内只允许最多新建30个连接[root@test3-237 ~]# iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 30 -j REJECT[root@test3-237 ~]# iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT---------------------------------------------------------------------------------------------------如果出现报错：iptables: Invalid argument. Run `dmesg&apos; for more information. 解决办法：增加 xt_recent模块的参数值即可，默认是20[root@test3-237 ~]# cat /sys/module/xt_recent/parameters/ip_pkt_list_tot20[root@test3-237 ~]# echo 50 &gt; /sys/module/xt_recent/parameters/ip_pkt_list_tot[root@test3-237 ~]# cat /sys/module/xt_recent/parameters/ip_pkt_list_tot50--------------------------------------------------------------------------------------------------- 禁止ping（即禁止从外部ping这台服务器）：[root@test3-237 ~]# echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all 用iptables屏蔽IP（如下禁止213.8.166.237连接本机的80端口）[root@test3-237 ~]# iptables -A INPUT -s 213.8.166.227 -p tcp -m tcp -m state --state NEW --dport 80 --syn -j REJECT 允许某ip连接（如下允许13.78.66.27连接本机的80端口）[root@test3-237 ~]# iptables -A INPUT -s 13.78.66.27 -p tcp -m tcp -m state --state NEW --dport 80 --syn -j ACCEPT 使用DDoS deflate脚本自动屏蔽攻击ip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过预设的限制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.DDoS deflate其实是一个Shell脚本，使用netstat和iptables工具，对那些链接数过多的IP进行封锁，能有效防止通用的恶意扫描器，但它并不是真正有效的DDoS防御工具。 DDoS deflate工作过程描述：同一个IP链接到服务器的连接数到达设置的伐值后，所有超过伐值的IP将被屏蔽，同时把屏蔽的IP写入ignore.ip.list文件中，与此同时会在tmp中生成一个脚本文件，这个脚本文件马上被执行，但是一运行就遇到sleep预设的秒，当睡眠了这么多的时间后，解除被屏蔽的IP，同时把之前写入ignore.ip.list文件中的这个被封锁的IP删除，然后删除临时生成的文件。一个事实：如果被屏蔽的IP手工解屏蔽，那么如果这个IP继续产生攻击，那么脚本将不会再次屏蔽它（因为加入到了ignore.ip.list），直到在预设的时间之后才能起作用，加入到了ignore.ip.list中的IP是检测的时候忽略的IP。可以把IP写入到这个文件以避免这些IP被堵塞，已经堵塞了的IP也会加入到ignore.ip.list中，但堵塞了预定时间后会从它之中删除。 如何确认是否受到DDOS攻击？[root@test3-237 ~]# netstat -ntu | awk &apos;&#123;print $5&#125;&apos; | cut -d: -f1 | sort | uniq -c | sort -n 1 Address 1 servers) 2 103.10.86.5 4 117.36.231.253 4 19.62.46.24 6 29.140.22.18 8 220.181.161.131 2911 167.215.42.88 每个IP几个、十几个或几十个连接数都还算比较正常，如果像上面成百上千肯定就不正常了。比如上面的167.215.42.88，这个ip的连接有2911个！这个看起来就很像是被攻击了！ 下面就说下通过DDoS deflate脚本来自动屏蔽DDOS攻击的ip1）下载DDoS deflate安装脚本，并执行安装。[root@test3-237 ~]# wget http://www.inetbase.com/scripts/ddos/install.sh[root@test3-237 ~]# chmod 0700 install.sh[root@test3-237 ~]# ./install.sh --------------------------------------------------------------------------卸载DDos default的操作如下：# wget http://www.inetbase.com/scripts/ddos/uninstall.ddos# chmod 0700 uninstall.ddos# ./uninstall.ddos-------------------------------------------------------------------------- 2）配置DDoS deflate下面是DDoS deflate的默认配置位于/usr/local/ddos/ddos.conf ，内容如下：[root@test3-237 ~]# cat /usr/local/ddos/ddos.conf##### Paths of the script and other filesPROGDIR=&quot;/usr/local/ddos&quot;PROG=&quot;/usr/local/ddos/ddos.sh&quot;IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot; //IP地址白名单CRON=&quot;/etc/cron.d/ddos.cron&quot; //定时执行程序APF=&quot;/etc/apf/apf&quot;IPT=&quot;/sbin/iptables&quot; ##### frequency in minutes for running the script##### Caution: Every time this setting is changed, run the script with --cron##### option so that the new frequency takes effectFREQ=1 //检查时间间隔，默认1分钟。设置检测时间间隔，默认是分钟，由于系统使用crontab功能，最小单位是分钟 ##### How many connections define a bad IP? Indicate that below.NO_OF_CONNECTIONS=150 //最大连接数，超过这个数IP就会被屏蔽，一般默认即可。默认是150，这是一个经验值，如果服务器性能比较高，可以设置200以上，以避免误杀 ##### APF_BAN=1 (Make sure your APF version is atleast 0.96)##### APF_BAN=0 (Uses iptables for banning ips instead of APF)APF_BAN=0 //使用APF还是iptables屏蔽IP。推荐使用iptables,将APF_BAN的值改为0即可。设置为1表示使用APF，如果使用APF则需要先安装，centos中默认就没有安装 ##### KILL=0 (Bad IPs are&apos;nt banned, good for interactive execution of script)##### KILL=1 (Recommended setting)KILL=1 //是否屏蔽IP，默认即可 ##### An email is sent to the following address when an IP is banned.##### Blank would suppress sending of mailsEMAIL_TO=&quot;root&quot; //当IP被屏蔽时给指定邮箱发送邮件，推荐使用，换成自己的邮箱即可。如果不希望发送邮件，设置为空，即EMAIL_TO=&quot;&quot; ##### Number of seconds the banned ip should remain in blacklist.BAN_PERIOD=600 //禁用IP时间（锁定ip的时间），默认600秒，可根据情况调整 需要注意的是：DDos default安装完成后在/usr/local/ddos目录下产生了ddos.conf、ddos.sh、ignore.ip.list和LICENSE这四个文件，其中：ddos.conf是配置文件，ddos.sh是一个Shell文件，ignore.ip.list是存放忽略IP的文件，LICENSE是版权声明文件，安装完成后还在/etc/cron.d/下生产了ddos.cron文件，内容如下： [root@test3-237 ~]# cat /etc/cron.d/ddos.cronSHELL=/bin/sh0-59/1 * * * * root /usr/local/ddos/ddos.sh &gt;/dev/null 2&gt;&amp;1 意思是每隔一分钟执行一下/usr/local/ddos/ddos.sh，这个脚本是关键！这个cron任务是依赖ddos.conf文件中的NO_OF_CONNECTIONS变量产生的，如果修改了此值，可以通过运行如下命令更新（实际也是在安装是运行了如下命令）：[root@test3-237 ~]# /usr/local/ddos/ddos.sh -cStopping crond: [ OK ]Starting crond: [ OK ]Stopping crond: [ OK ]Starting crond: [ OK ] 或者[root@test3-237 ~]# /usr/local/ddos/ddos.sh --cronStopping crond: [ OK ]Starting crond: [ OK ]Stopping crond: [ OK ]Starting crond: [ OK ] 3）DDos default选项# /usr/local/ddos/ddos.sh -h #查看选项# /usr/local/ddos/ddos.sh -k n #杀掉连接数大于n的连接。n默认为配置文件的NO_OF_CONNECTIONS 比如： [root@test3-237 ~]# /usr/local/ddos/ddos.sh -k 150 2 103.110.186.75 1 servers) 1 Address# /usr/local/ddos/ddos.sh -c #按照配置文件创建一个执行计划。使得ddos.conf文件配置后生效 防御DDOS攻击的shell脚本1234567891011121314151617181920212223242526272829303132Linux服务器中一旦受到DDOS的攻击（比如IDC机房服务器被攻击了，关机，拔网线，降流量），目前只能通过封IP来源来暂时解决。然而IP来源变化多端，光靠手工来添加简直是恶梦，所以还是想办法写个shell脚本来定时处理，这才是比较靠谱的办法。 [root@test3-237 ~]# mkdir /root/bin[root@test1-237 ~]# cat /root/bin/dropip.sh //此脚本自动提取攻击ip，然后自动屏蔽#!/bin/bash/bin/netstat -na|grep ESTABLISHED|awk &apos;&#123;print $5&#125;&apos;|awk -F: &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -rn|head -10|grep -v -E &apos;192.168|127.0&apos;|awk &apos;&#123;if ($2!=null &amp;&amp; $1&gt;4) &#123;print $2&#125;&#125;&apos;&gt;/tmp/dropipfor i in $(cat /tmp/dropip)do/sbin/iptables -A INPUT -s $i -j DROPecho “$i kill at `date`”&gt;&gt;/var/log/ddosdone 以上脚本中最重要的是第二行，即：获取ESTABLISHED连接数最多的前10个ip并写入临时文件/tmp/dropip,排除了内部ip段192.168|127.0开头的.通过for循环将dropip里面的ip通过iptables全部drop掉，然后写到日志文件/var/log/ddos。 给脚本添加执行权限[root@test1-237 ~]# chmod +x /root/bin/dropip.sh 添加到计划任务，每分钟执行一次[root@test1-237 ~]#crontab -e*/1 * * * * /root/bin/dropip.sh ----------------------------------------------------------------------------------------下面是针对连接数屏蔽IP#!/bin/sh /bin/netstat -ant |grep 80 |awk &apos;&#123;print $5&#125;&apos; |awk -F&quot;:&quot; &apos;&#123;print $1&#125;&apos; |sort |uniq -c |sort -rn |grep -v -E &apos;192.168|127.0&apos; |awk &apos;&#123;if ($2!=null &amp;&amp; $1&gt;50)&#125;&apos; &gt; /root/drop_ip.txt for i in `cat /root/drop_ip.txt` do /sbin/iptables -I INPUT -s $i -j DROP; done 使用safedog（安全狗）软件防御DDOS攻击123456789101112131415161718192021222324252627[root@test3-237 ~]# setenforce 0 //关闭selinux，否则不能安装成功[root@test3-237 ~]# getenforce //永久关闭selinux需要配置/etc/sysconfig/selinux文件，并重启机器生效！！Permissive 安装（nginx版）安全狗（safedog）[root@test3-237 ~]# wget http://safedog.cn/safedogwz_linux_Nginx64.tar.gz[root@test3-237 ~]# tar -zvxf safedogwz_linux_Nginx64.tar.gz[root@test3-237 ~]# cd safedogwz_linux_Nginx64[root@test3-237 safedogwz_linux_Nginx64]# chmod 755 install.py[root@bastion-IDC safedogwz_linux_Nginx64]# lsinstall_files install.py uninstall.py[root@test3-237 safedogwz_linux_Nginx64]# ./install.py -A //卸载安全狗就用uninstall.py....... step 3.5, start service... [ok] step 3.6, save safedog install info... [ok] Tips: (1)Run the command to setup Server Defense Module: sdui (2)Explore more features by tapping the command to join Cloud Management Center (fuyun.safedog.cn) with your account: sdcloud -h If you need any help about installation,please tap the command: ./install.py -hInstall Completely! 温馨提示：1）安装完成后，记得一定要重新启动Nginx服务，网站安全狗软件即可生效。2）运行时,安装脚本默认将自动获取Nginx服务的安装路径；若自动获取失败则将提示输入Nginx服务的安装路径（绝对路径），需要根据所安装的Nginx的目录，填写真实的安装路径。3）当出现提示：Are you sure to uninstall?[y/n]时，输入y]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Postgresql（1）--简介]]></title>
      <url>%2F2016%2F12%2F02%2FPostgresql%EF%BC%881%EF%BC%89--%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[何为PostgreSQLPostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES,Version4.2为基础的对象关系型数据库管理系统(ORDBMS)。POSTGRES开创的许多概念在很久以后才出现在商业数据库中。PostgreSQL是最初伯克利代码的一个开放源码的继承者。它支持大部分SQL标准并且提供了许多其它现代特性： 1.复杂查询2.外键3.触发器4.可更新的视图5.事务完整性6.多版本并发控制 另外，PostgreSQL可以用许多方法进行扩展，比如通过增加新的：1.数据类型2.函数3.操作符4.聚合函数5.索引方法6.过程语言 并且，因为许可证的灵活，任何人都可以以任何目的免费使用、修改、分发PostgreSQL，不管是私用、商用、还是学术研究使用。 选用理由(1)PostgreSQL支持用多种编程语言编写存程过程和函数(2)PostgreSQL支持非常强大的用户自定义数据类型功能 PostgreSQL资源（1）Plantet PostgreSQL （http://planet.postgresql.org）是PostgreSQL技术博客文章的汇聚站点，其中包含从PostgreSQL核心开发人员到普通用户编写的各类文章，包括新特性演汉及对现有功能的使用说明（2）PostgreSQL Wiki（https://wiki.postgresql.org）提供对PostgreSQL各个方面的使用技巧说明，以及从其他数据库移值到PostgreSQL的方法（3）PostgreSQL Books(https://www.postgresql.org/docs/books/)提供有关PostgreSQL的书箱列表信息； PostgreSQL管理工具postgresql常用管理工具有四种：psql、pgAdmin,phpPgAdmin和Adminer。PostgreSQL的核心开发团队维护着前三种。 （1）psql是一种用于执行查询的命令行工具（2）pgAdmin是一种广泛使用的开源PostgreSQL图形界面管理工具（3）phpPgAdmin基于Web页面的管理工具 PostgreSQL默认侦听端口 5432 PostgreSQL数据库对象(1)服务在大多数操作系统上，PostgreSQL是作为一种服务（或者叫守护进程）安装的。多个PostgreSQL服务可以运行于同一台物理服务器上，但它们的侦听端口不能重复，也不能共享一个数据存储目录。 (2)database每个PostgreSQL服务可以包含多个独立的database (3)schemadatabase的下一层逻辑结构就是schema (4)catalogcatalog是系统级的schema,用于存储系统函数和系统元数据。每个database创建好以后默认都会含有两个catalog：一个名为pg_catalog,用于存储PostgreSQL系统自带的函数，表，系统视图，数据类型转换器以及数据类型定义等元数据另一个是information_schema,用于存储ANSI标准中所要求提供的元数据查询视图，这些视图遵从ANSI SQL标准的要求，以提定的格式向外界提供PostgreSQL 元数据信息PostgreSQL information_schema中最常用的视图一般有以下几个：columns视图：列出了数据库中的所有表列tables视图：列出数据库中的所有表（包括视图）view视图：列出所有视图以及用于构建或重新构建该视图的关联SQL （5）变量（6）扩展包（7）表在Postgresql中，表首先属于某个schema,而schema又属于某个database,这样就构成了一种三级存储结构Postgresql的表支持两种强大的功能，第一种是表继承，即一张表可以有父表和子表第二种是创建一张表的同时，系统会自动为此表创建一种对应的自定义数据类型（8）外部表和外部数据封装器通过外部表可以直接在本地数据库中访问来自外部数据源的数据外部表映射关系的建立是通过配置外部数据封装器（Foreign Data Wrapper，FDW）实现的。FDW是PostgreSQL和外部数据源之间的一架魔法桥，可实现两边数据的互联互通。（9）表空间表空间是用于存储数据的物理空间（10）视图（11）函数（12）内置编程语言（13）运算符（14）数据类型（15）数据类型转换器（16）序列（1）行或记录（17）触发器（18）规则]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细说firewalld和iptables]]></title>
      <url>%2F2016%2F11%2F10%2F%E7%BB%86%E8%AF%B4firewalld%E5%92%8Ciptables%2F</url>
      <content type="text"><![CDATA[在CentOS7里有几种防火墙共存：firewalld、iptables、ebtables，默认是使用firewalld来管理netfilter子系统，不过底层调用的命令仍然是iptables等。 firewalld跟iptables对比firewalld跟iptables比起来至少有两大好处：1、firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效；2、firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。firewalld跟iptables比起来，不好的地方是每个服务都需要去设置才能放行，因为默认是拒绝。而iptables里默认是每个服务是允许，需要拒绝的才去限制。 firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和 iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样罢了。 一个重要的概念：区域管理通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同程序区域间传送的数据流。例如，互联网是不可信任的区域，而内部网络是高度信任的区域。网络安全模型可以在安装，初次启动和首次建立网络连接时选择初始化。该模型描述了主机所连接的整个网络环境的可信级别，并定义了新连接的处理方式。有如下几种不同的初始化区域：阻塞区域（block）：任何传入的网络数据包都将被阻止。工作区域（work）：相信网络上的其他计算机，不会损害你的计算机。家庭区域（home）：相信网络上的其他计算机，不会损害你的计算机。公共区域（public）：不相信网络上的任何计算机，只有选择接受传入的网络连接。隔离区域（DMZ）：隔离区域也称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用。对于隔离区域，只有选择接受传入的网络连接。信任区域（trusted）：所有的网络连接都可以接受。丢弃区域（drop）：任何传入的网络连接都被拒绝。内部区域（internal）：信任网络上的其他计算机，不会损害你的计算机。只有选择接受传入的网络连接。外部区域（external）：不相信网络上的其他计算机，不会损害你的计算机。只有选择接受传入的网络连接。 注：FirewallD的默认区域是public。firewalld默认提供了九个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，他们都保存在“/usr/lib /firewalld/zones/”目录下。配置方法 firewalld的配置方法主要有三种：firewall-config、firewall-cmd和直接编辑xml文件，其中firewall-config是图形化工具，firewall-cmd是命令行工具，而对于linux来说大家应该更习惯使用命令行方式的操作，所以 firewall-config我们就不给大家介绍了。 firewalld使用：安装yum install firewalld firewall-config 运行、停止、禁用启动： systemctl start firewalld 查看状态： systemctl status firewalld 或者 firewall-cmd --state 停止： systemctl disable firewalld 禁用： systemctl stop firewalld systemctl mask firewalld systemctl unmask firewalld 配置查看版本：firewall-cmd --version 查看帮助：firewall-cmd --help 显示状态：firewall-cmd --state 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域：firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态：firewall-cmd --panic-off 查看是否拒绝：firewall-cmd --query-panic 更新防火墙规则#firewall-cmd --reload #firewall-cmd --complete-reload 两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务 将接口添加到区域，默认接口都在public #firewall-cmd --zone=public --add-interface=eth0 永久生效再加上 --permanent 然后reload防火墙 设置默认接口区域 #firewall-cmd --set-default-zone=public 立即生效无需重启 打开端口查看所有打开的端口： # firewall-cmd --zone=dmz --list-ports 加入一个端口到区域： # firewall-cmd --zone=dmz --add-port=8080/tcp 若要永久生效方法同上 打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档 # firewall-cmd --zone=work --add-service=smtp 移除服务 # firewall-cmd --zone=work --remove-service=smtp 还有端口转发功能、自定义复杂规则功能、lockdown iptables 是与最新的 3.5 版本 Linux 内核集成的 IP 信息包过滤系统。如果 Linux 系统连接到因特网或 LAN、服务器或连接 LAN 和因特网的代理服务器， 则该系统有利于在 Linux 系统上更好地控制 IP 信息包过滤和防火墙配置。 iptables 基本命令使用举例链及NAT的基本操作清除所有的规则。1）清除预设表filter中所有规则链中的规则。 iptables -F 2）清除预设表filter中使用者自定链中的规则。 iptables -X iptables -Z 3)清除NAT表规则 #iptables -F -t nat 4)NAT表的显示 iptables -t nat -nL 设置链的默认策略。一般有两种方法。1）首先允许所有的包，然后再禁止有危险的包通过放火墙。 iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT 2）首先禁止所有的包，然后根据需要的服务允许特定的包通过防火墙。 iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP 列出表/链中的所有规则。默认只列出filter表。iptables -L ####向链中添加规则。下面的语句用于开放网络接口： iptables -A INPUT -i lo -j ACCEPT iptables -A OUTPUT -o lo -j ACCEPT iptables -A INPUT -i eth0 -j ACEPT iptables -A OUTPUT -o eth1 -j ACCEPT iptables -A FORWARD -i eth1 -j ACCEPT iptables -A FORWARD -0 eth1 -j ACCEPT 注意:由于本地进程不会经过FORWARD链，因此回环接口lo只在INPUT和OUTPUT两个链上作用。 使用者自定义链。iptables -N custom iptables -A custom -s 0/0 -d 0/0 -p icmp -j DROP iptables -A INPUT -s 0/0 -d 0/0 -j DROP 设置基本的规则匹配指定协议匹配。1）匹配指定协议。 iptables -A INPUT -p tcp 2）匹配指定协议之外的所有协议。 iptables -A INPUT -p !tcp 指定地址匹配。1）指定匹配的主机。 iptables -A INPUT -s 192.168.0.18 2）指定匹配的网络。 iptables -A INPUT -s 192.168.2.0/24 3）匹配指定主机之外的地址。 iptables -A FORWARD -s !192.168.0.19 4）匹配指定网络之外的网络。 iptables -A FORWARD -s ! 192.168.3.0/24 指定网络接口匹配。1）指定单一的网络接口匹配。 iptables -A INPUT -i eth0 iptables -A FORWARD -o eth0 2）指定同类型的网络接口匹配。 iptables -A FORWARD -o ppp+ 指定端口匹配。1）指定单一端口匹配。 iptables -A INPUT -p tcp --sport www iptables -A INPUT -p udp –dport 53 2）匹配指定端口之外的端口。 iptables -A INPUT -p tcp –dport !22 3）匹配端口范围。 iptables -A INPUT -p tcp –sport 22:80 4）匹配ICMP端口和ICMP类型。 iptables -A INOUT -p icmp –icimp-type 8 5）指定ip碎片。 每个网络接口都有一个MTU（最大传输单元），这个参数定义了可以通过的数据包的最大尺寸。如果一个数据包大于这个参数值时，系统会将其划分成更小的数据包 （称为ip碎片）来传输，而接受方则对这些ip碎片再进行重组以还原整个包。这样会导致一个问题：当系统将大数据包划分成ip碎片传输时，第一个碎片含有 完整的包头信息（IP+TCP、UDP和ICMP），但是后续的碎片只有包头的部分信息（如源地址、目的地址）。因此，检查后面的ip碎片的头部（象有 TCP、UDP和ICMP一样）是不可能的。假如有这样的一条规则： iptables -A FORWARD -p tcp -s 192.168.1.0/24 -d 192.168.2.100 –dport 80 -j ACCEPT 并且这时的FORWARD的policy为DROP时，系统只会让第一个ip碎片通过，而余下的碎片因为包头信息不完整而无法通过。可以通过—fragment/-f 选项来指定第二个及以后的ip碎片解决上述问题。 iptables -A FORWARD -f -s 192.168.1.0/24 -d 192.168.2.100 -j ACCEPT 注意现在有许多进行ip碎片攻击的实例，如DoS攻击，因此允许ip碎片通过是有安全隐患的，对于这一点可以采用iptables的匹配扩展来进行限制。 设置扩展的规则匹配（举例已忽略目标动作）多端口匹配。1）匹配多个源端口。 iptables -A INPUT -p tcp -m multiport –sport 22,53,80,110 2）匹配多个目的端口。 iptables -A INPUT -p tcp -m multiport –dpoort 22,53,80 3）匹配多端口(无论是源端口还是目的端口） iptables -A INPUT -p tcp -m multiport –port 22,53,80,110 指定TCP匹配扩展使用 –tcp-flags 选项可以根据tcp包的标志位进行过滤。 iptables -A INPUT -p tcp –tcp-flags SYN,FIN,ACK SYN iptables -A FROWARD -p tcp –tcp-flags ALL SYN,ACK 上实例中第一个表示SYN、ACK、FIN的标志都检查，但是只有SYN匹配。第二个表示ALL（SYN，ACK，FIN，RST，URG，PSH）的标志都检查，但是只有设置了SYN和ACK的匹配。 iptables -A FORWARD -p tcp --syn 选项—syn相当于”--tcp-flags SYN,RST,ACK SYN”的简写。 limit速率匹配扩展。1）指定单位时间内允许通过的数据包个数，单位时间可以是/second、/minute、/hour、/day或使用第一个子母。 iptables -A INPUT -m limit --limit 300/hour 2 )指定触发事件的阀值。 iptables -A INPUT -m limit –limit-burst 10 用来比对一次同时涌入的封包是否超过10个，超过此上限的包将直接丢弃。 3）同时指定速率限制和触发阀值。 iptables -A INPUT -p icmp -m limit –-limit 3/m –limit-burst 3 表示每分钟允许的最大包数量为限制速率（本例为3）加上当前的触发阀值burst数。任何情况下，都可保证3个数据包通过，触发阀值burst相当于允许额外的包数量。 4）基于状态的匹配扩展（连接跟踪） 每个网络连接包括以下信息：源地址、目标地址、源端口、目的端口，称为套接字对（socket pairs）；协议类型、连接状态（TCP协议） 和超时时间等。防火墙把这些信息称为状态（stateful）。状态包过滤防火墙能在内存中维护一个跟踪状态的表，比简单包过滤防火墙具有更大的安全性，命令格式如下： iptables -m state –-state [!]state [,state,state,state] 其中，state表是一个逗号分割的列表，用来指定连接状态，4种： &gt;NEW: 该包想要开始一个新的连接（重新连接或连接重定向） &gt;RELATED:该包是属于某个已经建立的连接所建立的新连接。举例： FTP的数据传输连接和控制连接之间就是RELATED关系。 &gt;ESTABLISHED：该包属于某个已经建立的连接。 &gt;INVALID:该包不匹配于任何连接，通常这些包被DROP。 例如： （1）在INPUT链添加一条规则，匹配已经建立的连接或由已经建立的连接所建立的新连接。即匹配所有的TCP回应包。 iptables -A INPUT -m state –state RELATED,ESTABLISHED （2）在INPUT链链添加一条规则，匹配所有从非eth0接口来的连接请求包。 iptables -A INPUT -m state -–state NEW -i !eth0 又如，对于ftp连接可以使用下面的连接跟踪： （1）被动（Passive）ftp连接模式。 iptables -A INPUT -p tcp --sport 1024: --dport 1024: -m state –-state ESTABLISHED -j ACCEPT iptables -A OUTPUT -p tcp --sport 1024: --dport 1024: -m state -–state ESTABLISHED,RELATED -j ACCEPT （2）主动（Active）ftp连接模式 iptables -A INNPUT -p tcp --sport 20 -m state –-state ESTABLISHED,RELATED -j ACCEPT iptables -A OUTPUT -p tcp –OUTPUT -p tcp –dport 20 -m state --state ESTABLISHED -j ACCEPT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx域名访问的白名单配置梳理]]></title>
      <url>%2F2016%2F10%2F11%2FNginx%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95%E9%85%8D%E7%BD%AE%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[在日常运维工作中，会碰到这样的需求：设置网站访问只对某些ip开放，其他ip的客户端都不能访问。可以通过下面四种方法来达到这种效果：1）针对nginx域名配置所启用的端口(比如80端口)在iptables里做白名单，比如只允许100.110.15.16、100.110.15.17、100.110.15.18访问.但是这样就把nginx的所有80端口的域名访问都做了限制，范围比较大！ 12345[root@china ~]# vim /etc/sysconfig/iptables......-A INPUT -s 100.110.15.16 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -s 100.110.15.17 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -s 100.110.15.18 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT 2）如果只是针对nginx下的某一个域名进行访问的白名单限制，那么可以在nginx的配置文件里进行设置，利用$remote_addr参数进行访问的分发限制，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@china vhosts]# cat testwww.wangshibo.com.confserver &#123; listen 80; server_name testwww.wangshibo.com; root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main; access_log /var/www/vhosts/testwww.wangshibo.com/logs/access.log main; error_log /var/www/vhosts/testwww.wangshibo.com/logs/error.log; ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。主要是下面这三行 if ($remote_addr !~ ^(100.110.15.16|100.110.15.17|100.110.15.18|127.0.0.1)) &#123; rewrite ^.*$ /maintence.php last; &#125; location / &#123; try_files $uri $uri/ @router; index index.php; &#125; error_page 500 502 503 504 /50x.html; location @router &#123; rewrite ^.*$ /index.php last; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9001; fastcgi_read_timeout 30; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #include fastcgi_params; include fastcgi.conf; &#125; &#125; 错误页面内容设置：[root@china vhosts]# cat /var/www/vhosts/testwww.wangshibo.com/main/maintence.html&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;&lt;/head&gt;&lt;body&gt;网站临时维护中，请稍后访问...&lt;/body&gt;&lt;/html&gt; 3）也可以使用$http_x_forwarded_for参数进行访问的分发限制，如下：123456789101112131415161718192021222324252627282930313233343536373839server &#123; listen 80; server_name testwww.wangshibo.com; root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main; access_log /var/www/vhosts/testwww.wangshibo.com/logs/access.log main; error_log /var/www/vhosts/testwww.wangshibo.com/logs/error.log; ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。 if ($http_x_forwarded_for !~ ^(100.110.15.16|100.110.15.17|100.110.15.18|127.0.0.1)) &#123; rewrite ^.*$ /maintence.php last; &#125; location / &#123; try_files $uri $uri/ @router; index index.php; &#125; error_page 500 502 503 504 /50x.html; location @router &#123; rewrite ^.*$ /index.php last; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9001; fastcgi_read_timeout 30; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #include fastcgi_params; include fastcgi.conf; &#125; &#125; 4）还可以利用nginx的allow、deny参数进行访问限制12345678910111213141516171819202122232425262728293031323334353637383940[root@china vhosts]# cat testwww.wangshibo.com.confserver &#123; listen 80; server_name testwww.wangshibo.com; root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main; access_log /var/www/vhosts/testwww.wangshibo.com/logs/access.log main; error_log /var/www/vhosts/testwww.wangshibo.com/logs/error.log; ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。 allow 100.110.15.16; allow 100.110.15.17; allow 100.110.15.18; allow 127.0.0.1; deny all; location / &#123; try_files $uri $uri/ @router; index index.php; &#125; error_page 500 502 503 504 /50x.html; location @router &#123; rewrite ^.*$ /index.php last; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9001; fastcgi_read_timeout 30; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #include fastcgi_params; include fastcgi.conf; &#125; &#125; nginx中remote_addr和x_forwarded_for参数使用说明做网站时经常会用到remote_addr和x_forwarded_for这两个头信息来获取客户端的IP，然而当有反向代理或者CDN的情况下，这两个值就不够准确了，需要调整一些配置。1）什么是remote_addrremote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP。 2）什么是x_forwarded_for正如上面所述，当你使用了代理时，web服务器就不知道你的真实IP了，为了避免这个情况，代理服务器通常会增加一个叫做x_forwarded_for的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP 使用HAProxy做反向代理通常网站为了支撑更大的访问量，会增加很多web服务器，并在这些服务器前面增加一个反向代理（如HAProxy），它可以把负载均匀的分布到这些机器上。你的浏览器访问的首先是这台反向代理，它再把你的请求转发到后面的web服务器，这就使得web服务器会把remote_addr设为这台反向代理的IP，为了能让你的程序获取到真实的客户端IP，你需要给HAProxy增加以下配置： option forwardfor它的作用就像上面说的，增加一个x_forwarded_for的头信息，把你上网机器的ip添加进去 使用Nginx的realip模块当Nginx处在HAProxy后面时，就会把remote_addr设为HAProxy的IP，这个值其实是毫无意义的，你可以通过nginx的realip模块，让它使用x_forwarded_for里的值。使用这个模块需要重新编译Nginx，增加–with-http_realip_module参数 set_real_ip_from 10.1.10.0/24;real_ip_header X-Forwarded-For;上面的配置就是把从10.1.10这一网段过来的请求全部使用X-Forwarded-For里的头信息作为remote_addr 将Nginx架在HAProxy前面做HTTPS代理网站为了安全考虑通常会使用https连接来传输敏感信息，https使用了ssl加密，HAProxy没法直接解析，所以要在HAProxy前面先架台Nginx解密，再转发到HAProxy做负载均衡。这样在Web服务器前面就存在了两个代理，为了能让它获取到真实的客户端IP，需要做以下配置。 首先要在Nginx的代理规则里设定：proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;这样会让Nginx的https代理增加x_forwarded_for头信息，保存客户的真实IP。 其次修改HAProxy的配置：option forwardfor except 10.1.10.0/24这个配置和之前设定的差不多，只是多了个内网的IP段，表示如果HAProxy收到的请求是由内网传过来的话（https代理机器），就不会设定x_forwarded_for的值，保证后面的web服务器拿到的就是前面https代理传过来的。 为什么PHP里的HTTP_X_FORWARDED_FOR和Nginx的不一样当你的网站使用了CDN后，用户会先访问CDN，如果CDN没有缓存，则回源站（即你的反向代理）取数据。CDN在回源站时，会先添加x_forwarded_for头信息，保存用户的真实IP，而你的反向代理也会设定这个值，不过它不会覆盖，而是把CDN服务器的IP（即当前remote_addr）添加到x_forwarded_for的后面，这样x_forwarded_for里就会存在两个值。Nginx会使用这些值里的第一个，即客户的真实IP，而PHP则会使用第二个，即CDN的地址。为了能让PHP也使用第一个值，你需要添加以下fastcgi的配置。 fastcgi_param HTTP_X_FORWARDED_FOR $http_x_forwarded_for;它会把nginx使用的值（即第一个IP）传给PHP，这样PHP拿到的x_forwarded_for里其实就只有一个值了，也就不会用第二个CDN的IP了。 忽略x_forwarded_for 其实，当你使用了Nginx的realip模块后，就已经保证了remote_addr里设定的就是客户端的真实IP，再看下这个配置 set_real_ip_from 10.1.10.0/24;real_ip_header X-Forwarded-For;它就是把x_forwarded_for设为remote_addr，而nginx里的x_forwarded_for取的就是其中第一个IP。 使用这些设置就能保证你的remote_addr里设定的一直都是客户端的真实IP，而x_forwarded_for则可以忽略了:) nginx location匹配规则location匹配命令~ 表示执行一个正则匹配，区分大小写~* 表示执行一个正则匹配，不区分大小写^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录= 进行普通字符精确匹配@ 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files =前缀的指令严格匹配这个查询。如果找到，停止搜索。所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。正则表达式，在配置文件中定义的顺序。如果第3条规则产生匹配的话，结果被使用。否则，如同从第2条规则被使用。 location 匹配的优先级(与location在配置文件中的顺序无关)= 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。 普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。^~` 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。最后匹配理带有”~”和”~*”的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。123456789101112131415location = / &#123; # 只匹配&quot;/&quot;.[ configuration A ]&#125;location / &#123; # 匹配任何请求，因为所有请求都是以&quot;/&quot;开始，但是更长字符匹配或者正则表达式匹配会优先匹配[ configuration B ]&#125; location ^~ /images/ &#123; # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location[ configuration C ]&#125; location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配以 gif, jpg, or jpeg结尾的请求. 但是所有 /images/ 目录的请求将由 [Configuration C]处理.[ configuration D ]&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[区块链技术(1)--区块链概念]]></title>
      <url>%2F2016%2F10%2F10%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF(1)--%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[区块链是目前一个比较热门的新概念，蕴含了技术与金融两层概念。从技术角度来看，这是一个牺牲一致性效率且保证最终一致性的的分布式的数据库，当然这是比较片面的。从经济学的角度来看，这种容错能力很强的点对点网络，恰恰满足了共享经济的一个必须要求——低成本的可信环境 区块链定义区块链技术到底是什么？很少有人能够解释清楚。现在市面上有很多关于区块链的书籍，内容基本都是，区块链能做什么，区块链的未来前景等。总的来说，区块链是一套协议，一组规范，而不是具体代码、项目。 理解了这套协议，你可以基于现有的技术，以不同的语言去实现它。我们也无法用一句简单的话去概况什么是区块链，站的角度不同，得到的结论也不一样。 金融业的人会说区块链是一个分布式的账本，是一个分布式的银行记账系统。 密码学者的会说区块链是使用密码学构建的去信任网络。 码农可能会说区块链就是一个确保最终一致性的分布式数据库。（ps：基于对IBM的超级账本Hyperledger项目fabric的认识。） 吃瓜群众可以从网络获取定义：区块链（Blockchain）是一种分布式数据库，起源自比特币。区块链是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。该概念在中本聪的白皮书中提出，中本聪创造第一个区块，即“创世区块”（摘自维基百科）。 但无论怎么定义，只要理解了其技术要点，每个人都会有自己的认识。 区块链技术三要素首先，我们回顾一下软件系统架构。 中心化在互联网技术飞速发展的前半程，client与server的角色基本上是分工明确，1个server提供服务，n个client调用服务，这即所谓的中心化，系统的可靠性依赖server的可靠性。 分布式随着业务复杂度上升、业务量激增，传统的中心化已经不能满足需要。这时候，服务分拆，横向纵向拓展变得理所应当，这就是我们现在所处的分布式系统架构，系统的可靠性依赖于分布式系统的容灾恢复能力。 去中心化分布式架构给我们带来的便利性很容易让我们觉得这就是“完美无缺”的架构，但服务提供方还是只依赖某一机构。如果机构作恶，宕机，篡改数据，那么造成的后果我想大家都清楚。（如果不清楚，请脑补机构==支付宝）。 区块链使用的p2p网络通信技术或许给了我们另外一种选择：人皆生而平等，没有谁生来就是server，就是client。每个节点都是平等的，既是生产者也是消费者。 注：今天所说的去中心化是一个理想化的状态，就如同共产主义理想。现阶段来说区块链去中心化本质上是相对去中心化。 有人可能会问，p2p网络就能保证不作恶，不宕机，数据不被篡改么？别急，p2p网络只是为所有节点提供了信息交换的方式。做事的还是共识算法和加密算法。 共识算法一提到区块链，所有懂的人都会说到共识算法，拜占庭将军问题，然后拽出一大堆高端大气上档次的英文缩写：POW,POS,DPOS,PBFT，等等。听众一脸懵逼，而如果你让他详细解释，可能绝大部分人也解释不清楚，这就如同爱因斯坦的相对论。 但别担心，最简单的解释，共识算法就是保证少数服从多数！大多数人认定一件事，这件事就是事实，也就意味着如果你要去改变一个既定事实，那么你必须伙同大多数人陪你一起作假。 在电影电视剧中，这种情况很常见，弱者屈服于强者做伪证。但在基于p2p通信的数以千计的节点中，想要伙同其他节点一起作恶，除非“大多数节点”都被统一组织（人）控制，有共同的利益，且利益大于付出，否则不可达成。 这里“大多数节点”加了引号，因为有些算法并不是在大多数的临界点51%时就能达成共识。如PBFT，需要66%以上的确定节点才能达成共识。比如现在比特币网络有人就提出了这样的担心，因为大概有75%的算力被中国矿池掌控。 加密算法说到加密算法，大多数码农都会想到诸如对称加密，非对称加密，hash, md5，des，rsa等。加密的本质其实很简单，让信息真实、隐秘的交流及存储。真实性由数据签名保证，隐私性由数据加密实现。区块链平台现在广泛使用的算法有椭圆曲线签名算法（ECDSA）、SHA256以及ripemd160，三者的结合使用保证了区块链在密码学层面上达到高度隐私。 结合回到刚刚的问题：p2p网络就能保证不作恶，不宕机，数据不被篡改么？我们把区块链技术三要素结合起来探讨这个问题。 作恶：要在数以千计的平等节点之间寻找作恶同伙，通常作恶的收获还不如作恶的付出，这就从根本上杜绝了大量坏节点的出现。比如，比特币的POW共识算法，就算联合了比特币网络51%以上的算力去实现双花、硬分叉，得到的收益或许还不够交电费。 宕机：这个很好理解，所有的节点都是平等的，一个宕机了，不影响整个网络的持续运行。 数据篡改：这其实是作恶的子集，但是比较重要，拿出来说。区块链的一个重要特征就是时序性，前一时间产生的交易会影响后续所有交易（交易签名），如果想要篡改中间某一交易的数据，那么必须在此交易所在的区块开始分叉，产生一个新链，改变这之后的所有交易，而且还要比其他链的区块产生的速度更快，否则没有意义，因为区块链网络只认最长的那条链（基于比特币区块链）。 区块链应用四展望区块链金融比尔盖茨曾经讲过一句话：“传统银行如果不改变思路，就是21世纪要灭绝的恐龙”。之前，我们都只是当做一句笑谈。就像马云爸爸说他这辈子最大的错误就是建立阿里巴巴。 在区块链技术被挖掘出来以后，这句话被反复引用，无论是否炒作，必须看到区块链在应对金融业务时拥有的得天独厚的优势，如果银行不思求变，那么被时代抛弃是必然。因此，诸如花旗银行、汇丰银行、摩根斯坦利等42家巨头银行加入由一家区块链创业公司创建的R3区块链联盟也就不难理解了。 未来世界是数字世界，数字资产会变成大家资产的主要凭证。金融的本质就是信用，如何在银行全面数字化过程中利用去信任的区块链技术，这必定是未来5-10年金融创业的黄金命题。 价值互联网过去20年，我们亲眼目睹了互联网技术如何改变我们的生活，信息化的巨大变革彻底的改变（便利）了我们的衣食住行。实现了信息传播与分享的解放，是信息的去中心化。但互联网并没有解决财富与价值在互联网上的交换与转移。 如果说现有的互联网已解决信息传播与分享的瓶颈，那么区块链要解决的就是资金、合约和数字化资产在互联网上交换、交易与转移的难题。未来20年，是信息互联网升级为价值互联网的创业潮。 共享经济近两年来，滴滴与uber之间的互联网租车争夺战，将“共享经济”推到了风口浪尖。这种个人与个人之间直接共享闲置资产的方式将通过区块链更加流行。因为区块链网络作为一个去信任去中心网络，让人们摆脱了个人与个人之间的信任危机以及中心化的非市场化运作。比如法国一个去中心化的叫车平台Arade City，司机与乘客直接交易。 而我们公司现在也正在做一个共享用户闲置磁盘空间的区块链应用平台。我们相信，唯数据与空间不可辜负，基于区块链技术，可让闲置的空间存储可被信任的加密数据。数据可以是用户自己的照片视频，也可以是某组织的业务数据。 而对大数据分析来说，现有的大数据应用，数据都是存在一个中心化的厂商手里，谁敢保证数据拥有者不会因为自身的利益修改数据内容？而用了区块链技术保管的数据才能保证数据被所有人共同管理，不可篡改。 智能合约智能合约也是现在很火热的一个概念。简单的说，智能合约类似于计算机语言的if语句，当一个预先编好的合约的某一条件被触发时，就自动在区块链网络中执行合约相应的合同条款，而不需人为干预。 按照这样的愿景，未来律师的职责可能会大变样，律师的职责不是裁定个人合约，而是生产智能合约模板。定制性如何，易用性如何将决定合约的价格或者律师的身价。所以才会有笑谈：不会写脚本的律师不是好的码农。 开源项目以前，重复造轮子是衡量一个公司技术能力的重要指标。但是随着开源精神的普及以及github平台的广泛使用，贡献开源项目已经是互联网公司的常态。这里介绍两个比较出名的区块链平台开源项目。 超级账本超级账本（hyperledger）是Linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）、IBM等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。 超级账本项目很适合联盟链，私有链的构建。现在超级账本的开源代码实现Fabric由IBM主持孵化，由go语言开发，现在版本为0.6， 坑还很多，需要时间来填，我们的项目也是基于Fabric。所以，现在开始学习Fabric，应该是比较好的选择。 以太坊以太坊（Ethereum）是一个运行智能合约的去中心化平台（Platform for Smart Contract），平台上的应用按程序设定运行，不存在停机、审查、欺诈、第三方人为干预的可能。以太坊平台由 Golang、C++、Python 等多种编程语言实现。 前段时间的The DAO事件让以太坊平台损失惨重，以太坊也分裂成ETC和ETH，平台的发展前景不明。 国内现状 布比布比区块链已经广泛应用于数字资产、股权债券、贸易金融、供应链溯源、商业积分、联合征信、公示公证、数据安全等领域，并正在与交易所、银行等主流金融机构开展应用试验和测试。以多中心化信任为核心，致力于打造新一代价值流通网络，让数字资产都自由流动起来。 小蚁小蚁是基于区块链技术，将实体世界的资产和权益进行数字化，通过点对点网络进行登记发行、转让交易、清算交割等金融业务的去中心化网络协议。 唯链以区块链技术为核心，VeChain提供一套面向全球的真假校验和透明供应链管理的解决方案以应对全球泛滥的假货问题，同时使得消费客户更加关注所购买的产品本身，包括产地，材料质地，设计理念，品牌故事等。 ASCHAsch 是一个去中心化的应用平台。它提供了一系列的 sdk 和 api 来帮助开发者构建基于 Javascript 和侧链技术的去中心化应用。Asch 通过提供定制侧链、智能合约、应用托管等一体化的行业解决方案，致力于打造一个易于使用、功能完备、即插即用的系统。 云象云象区块链为企业级的B端客户进行服务，提供身份验证、电子证据保全、供应链管理、产品追溯等商业智能合约应用，同时我们为行业私有链应用，提供不可篡改、安全、部署成本低的区块链数据库产品。 太一太一云科技，拥有全球最顶尖的区块链研发团队，已研发包括区块链征信，区块链资产登记流转，区块链安全，智能合约，区块链大数据，区块链物联网，区块链云计算中心等领域的数十项核心专利技术。 将立足中国市场，积极开展区块链技术的产业化应用，在金融，商业，个人及企业信用等社会活动中，植入区块链的基因，改变人们对传统信用机制的认知，重塑互联网的价值传输构架，为创造崭新的更合理更公平全球新经济和新金融生态环境提供普适化的基础设施和解决方案。 如何从技术角度理解区块链 作者 陈浩 我接触过一些工程师，初次接触区块链时，不约而同的表达了：都是成熟的技术，不就是分布式存储嘛。站在工程师的角度，第一反应将这种新概念映射到自己的知识框架中，是非常自然的。但是细究之下发现，这种片面的理解可能将对区块链的理解带入一个误区，那就是作为一个技术人员，忽略了区块链的经济学特性——一个权力分散且完全自治的系统。 区块链本质上是一个基于P2P的价值传输协议，我们不能只看到了P2P，而看不到价值传输。同样的，也不能只看到了价值传输，而看不到区块链的底层技术。 可以这么说，区块链更像是一门交叉学科，结合了P2P网络技术、非对称加密技术、宏观经济学、经济学博弈等等知识，构建的一个新领域——针对价值互联网的探索。 那什么是价值互联网？价值互联网可以是当下如日中天的电子商务所衍生的支付业务。但，真的只是支付领域吗？很显然这是不够的，一级资本市场，实体资产确权与转移，证券登记交割、征信与反欺诈。我们再仔细想想，我们的各大电商平台的专业差评师，恶意刷单还少吗？ 如今的金融领域，除了支付比较便利之外，在其他绝大部分的业务中，我们就像是被套着锁链走路一样，我们反复确认，反复审核，反复监督，我们反复构建一个又一个的大大小小的高可用集群，保证线上服务的可靠性与连续性，我们雇佣一个又一个的安全工程师，交付一个又一个的渗透测试项目。为什么？因为作弊的成本太低了，低到只要改数据库的一行记录就可以提取上百万的资金。 强大的互联网给了我们成本几乎为零的高速信息传输通道，却没有一个成本低廉可靠的高速价值传输通道，那么这也就是区块链即将带来的。 区块链是一个公共的分布式总账，下面从技术角度简单介绍一下。 想象有一个100台的分布式数据库集群，现在的情况是这100个节点实际上的拥有者是一个机构，并且所有节点处在该机构的内网当中，所以这个机构想让这100个数据库节点干嘛就干嘛，换句话说这100个节点之间是处于一个可信任的环境，并且受控于一个实体，这个实体具有绝对仲裁分配权。 另外的情况是这样的，想象这100个节点分别归不同的人所有，且每个人的节点数据都是一样的，即完全冗余，并且所有的节点是处在广域网当中，换句话说就是这100个节点之间是不信任的，且不存在一个实体，它拥有绝对仲裁权。 现在考虑第二种情况，采用什么样的算法（共识模型）能够提供一个可信任的环境，使： 每个节点交换数据过程不被篡改；交换历史记录不可被篡改； 每个节点的数据会同步到最新数据，且承认经过共识的最新数据； 基于少数服从多数的原则，整体节点维护的数据本身客观反映了交换历史。 区块链本质上就是要解决以上第二种情况的一种技术方案，更确切的说应该叫分布式的冗余的链式总帐本方案。有关区块链的一些要素，在我以往的文章里有总结过一些： 包含一个分布式数据库 分布式数据库是区块链的物理载体，区块链是交易的逻辑载体，所有核心节点都应包含该条区块链数据的全副本 区块链按时间序列化区块，且区块链是整个网络交易数据的唯一主体 区块链只对添加有效，对其他操作无效 基于非对称加密的公私钥验证 记账节点要求拜占庭将军问题可解/避免 共识过程（consensus progress）是演化稳定的，即面对一定量的不同节点的矛盾数据不会崩溃。 共识过程能够解决double-spending问题 所以作为一个技术人员，不应当只看到了区块链所依赖的技术，更应该关注区块链以外的点和面，综合来看，区块链将会有趣得多。 区块链的一般性架构介绍有关区块链技术的介绍，在各个区块链平台的社区是有详细资料的，但是针对这些资料的总结，以及抽象出一共通概念的介绍，还是凤毛麟角，本文尝试总结一下。 在介绍之前，我想稍微介绍一下公有链，联盟链的概念，这些概念是以太坊创始人Vitalik提出的，我在这些概念的基础上做了一些研究。 其实区分公有链、联盟链很简单，只要看这个区块链的访问权限就可以了，如果访问该区块链需要获得链上节点的许可，那么这是一个联盟链，否则是公有链。根据名称，我们也可以”望文生义“，公有表示一个完全开放的网络，联盟表示一个半开放的网络，成员之间是共享的，非成员身份是没有自由访问权限的，所以我们也称联盟链为许可链。 下面我们来看几个比较主流的区块链平台（公有链，皆开源）： 比特币 Bitcoin 以太坊 Ethereum/经典以太坊 Ethereum Classic 比特股 Bitshares 我一般戏称为”三巨头“，从生态上来看，比特币是最为成熟稳定的，以太坊更像是一个冲在前面的勇士，比特股相比前两位生态要小很多，但是从创新的角度，也不亚于前两位。其他的很多项目，是从这三个区块链上衍生出来的，所以以这三个为基础，基本上可以吃透区块链了。 不得不提的还有Linux基金会项目——HyperLedger项目（主打联盟链，开源），也是旨在打造一个通用的区块链技术，不过我认为目前尚在开发迭代当中，还没有具体的应用案例，按下不讲。 另外还有一些银行寡头间的联盟链项目——R3 CEV项目（联盟链，闭源），以及中国的R3项目——ChinaLedger（联盟链，闭源），当然这些不是开源的，我无法获得有用的资料进行分析，所以就不展开了。 从技术上来看，针对不同的业务场景，对区块链有不同需求，比如实时结算业务，要求区块链提供秒级的交割，相对应的就是出块速度的要求，而出块速度过快往往会导致区块链分叉（fork），形成孤儿链，孤儿链是无效的，那么交易也就作废了，影响了区块链的最终一致性。如果频繁产生分叉造成相当比例的用户交易失效，那么可以认为系统是不可靠的。 如果我们将这种实时性要求比较高的业务安插到联盟链中，就可以控制风险，通过调整共识算法，利用快速一致共识模型（Consensus Model）来避免上述问题，虽然不如公有链那么健壮，但对某些特殊场景足够了。所以架构层面，对公有链和联盟链的技术也要差异化对待。 不过客户端整体的设计还是有一些通用的概念的，如下图： 一个区块链至少分为三层，最底层是一些通用的基础模块，比如基础加密算法，网络通讯库，流处理，线程封装，消息封装与解码，系统时间等； 中间一层是区块链的核心模块，一般包含了区块链的主要逻辑，如P2P网络协议，共识模块，交易处理模块，交易池模块，简单合约或者智能合约模块，嵌入式数据库处理模块，钱包模块等； 最上面一层，往往都是基于Json Standard RPC的交互模块，基于Json-RPC，我们还可以做出更好的UI界面，也可以是一个web-service。 如果区块链 支持智能合约，可能还要分更多的层，比如增加BaaS层，区块链上的智能合约提供自治的服务，比如下面这张以太坊的架构图（来自Google，仅作参考）： 这种分层更加关注的是区块链本身的分层，即业务上的视角，而不完全是技术的。 我们再转向比特币的设计： 比特币几个模块之间的耦合度其实比较高，而且有不少历史包袱，比特币的发明者——中本聪在开发比特币的时候，使用VC++开发，而VC++的标准库中的sstream流处理性能非常感人，不得不放弃，自行实现了了基于vector的流处理容器。而随着c++11的推出以及标准库的更新迭代，性能不可同日而语。 从整张图我们可以看出，比特币的模块比较少，也比较简单。chain-paramters描述了整个区块链的参数设置，wallet是与地址/加密还有存储相关的，mem-pool是未确认的交易池。得益于比特币核心开发者的不朽贡献，相比中本聪时代的比特币代码，现在的比特币代码质量已经相当不错了。 以上无论哪种设计，一般都要从P2P网络协议作为切入，作为一个P2P钱包，既要提供Service也要提供Client，作为Service依赖P2P网络协议，作为Client依赖Json-RPC。 需要指出的是，目前”三巨头”所使用的账户模型是不同的（所谓账户模型是指账户记账方法），比特币使用UXTO模型，以太坊和比特股使用账户余额模型。 UXTO模型（Unspent Transaction Outputs (UTXOs) ）：此模型表达了一种转移的概念，即任何产生的新币，在以后的生命周期中，只有转移，没有消亡，转移实质上是由加密算法的签名与验证控制的： 共识算法与分布式终于来到重点了，本文每节其实都可以展开成为独立的文章，内容所限，简单讲。 所谓区块链共识过程，在上文有所提及，是指如何将全网交易数据客观记录并且不可篡改的过程。目前”三巨头”分别使用不同的共识算法（Consensus Algorithm）, 比特币使用工作量证明PoW（Proof of Work），以太坊即将转换为权益证明PoS（Proof of Stake），比特股使用授权权益证明DPoS（Delegated Proof of Stake）。 以上这些算法我称之为“经济学”的算法，所谓经济学的算法，是指让作弊成本可计算，且让作弊成本往往远大于作弊带来的收益，即作弊无利可图，通过这种思想构造一个用于节点之间博弈的算法，并使之趋向一个稳定的平衡。相对应的我们还有计算机领域的分布式一致性算法，例如Paxos、Raft，我也称之为传统分布式一致性算法。 它们之间的最大区别是：系统在拜占庭将军（Byzantine Generals Problem）情景下的可靠性，即拜占庭容错（PBFT算法支持拜占庭容错）。然而无论是Paxos还是Raft算法，理论上都可能会进入无法表决通过的死循环(尽管这个概率其实是非常非常低的)，但是他们都是满足safety的，只是放松了liveness的要求, PBFT也是这样。 下面是一些传统分布式一致性算法和区块链共识过程的异同点。先来看相同点： Append only 强调序列化 少数服从多数原则 分离覆盖的问题：即长链覆盖短链区块，多节点覆盖少数节点日志 不同点: 传统分布式一致性算法大多不考虑拜占庭容错（Byzanetine Paxos除外），即假设所有节点只发生宕机、网络故障等非人为问题，并不考虑恶意节点篡改数据的问题； 传统分布式一致性算法是面向日志（数据库）的，即更通用的情况，而区块链共识模型面向交易的，所以严格来说，传统分布式一致性算法应该处于区块链共识模型的下面一层。 考虑上面的不同点，结合公有链和联盟链的特征，我们有： 联盟链：半封闭生态的价值网络，存在对等的不信任节点，如某某协会成员之间。 公有链：开放生态的价值网络，这层主要是为行业链和私有链提供全球交易网络。 由于联盟行业链其半封闭半开放特性，使用Delegated Proof of XXX 是可行的，可以考虑以传统一致性算法作为基础加入拜占庭容错/安全防护机制进行改进也是可以的。 而针对公有链，PoW/Pos/DPos等“经济学”的算法可能是最优算法。技术上，以上不同的共识算法，我们很多新开发区块链都相应的支持一个特性：共识模块可插拔，以应对不同场景下的要求。 下图是一张未来区块链生态示意图： 公有链提供可信可靠的价值传输网络，上面可以继续组建去中心化应用（DAPP）或者部署联盟链，甚至传统数据库都行，在上层搭建C端应用。 数字资产与价值流通网络 这里有张未来区块链发展的示意图： ref: Metaverse元界白皮书-CN(概要) “三巨头”中，比特币在“数字货币”处，比特股在“去中心化交易所”附近，以太坊在“去中心化组织”处。而实际上，区块链和现实的接触点，还在图示位置。所以区块链仍是一个正在成长的事物，结合图5，我们希望构建一个基础设施完善的价值传输网络，上层应用丰富的区块链生态，仍然需要付出巨大的努力。 下一步目标，是将资产数字化（类比资产证券化），例如我们可以将珍稀物品（艺术品/古董）数字化、知识产权数字化、票据基金等收益权数字化，将极大的提升市场运作效率，配备智能合约，甚至人工智能，可编程社会不再是梦想。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 分布式监控]]></title>
      <url>%2F2016%2F10%2F04%2Fzabbix%203.0%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[Zabbix Proxy是一个类似于代理的服务，可以代替Zabbix-server获取 zabbix-agent信息。其中数据存到本地（Proxy有自己的数据库）然后在发送给Server，这样可以保证数据不丢失 Zabbix-server —–&gt;Zabbix-Proxy —–&gt;Zabbix-agent 地址：https://www.zabbix.com/documentation/3.0/manual/distributed_monitoring/proxies Zabbix Proxy 使用场景常用于多机房情况或者监控主机特别多，几千台左右。这时候使用Zabbix Proxy 可以减轻服务器server的压力，还可以减轻Zabbix的维护。 最常用的特点是适用于多机房、网络不稳定的时候，因为如果直接由Zabbix-server发送信息可能agent没有收到，但是直接使用Zabbix-Proxy就不会遇到这个问题。 Zabbix官方说明（分布式监控）地址： https://www.zabbix.com/documentation/3.0/manual/distributed_monitoringNO - 中文解释1.没有Web界面2.本身不做任何告警通知（告警通知都是Server做） 小结： Zabbix Proxy 可以有多个，用来代理Zabbix server来运行。Proxy会将所有数据暂存于本地,然后同一转发到Zabbix Server上 Proxy只需要一条TCP链接，可以连接到Zabbix-server上即可。所以防火墙只需要添加一条Zabbix Proxy即可 我们可以参考上面的Zabbix Proxy图 Proxy是需要使用单独的数据库，所以不能将Server和Agent放在一起Proxy说明：https://www.zabbix.com/documentation/3.0/manual/distributed_monitoring/proxies安装文档：https://www.zabbix.com/documentation/3.0/manual/installation/install 官方文档使用的是源码安装，因为方便我们使用yum安装，因为我们只有2台，所以就用agent当做Proxy zabbix-proxy安装123456[root@node-12 ~]# rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm[root@node-12 ~]# yum install -y zabbix-proxy zabbix-proxy-mysql mariadb-server我们需要启动MySQL[root@node-12 ~]# systemctl start mariadb.service 我们还需要创建一个库12&gt;create database zabbix_proxy character set utf8;&gt;grant all on zabbix_proxy.* to zabbix_proxy@localhost identified by &apos;zabbix_proxy&apos;; 我们需要导入数据12345[root@node-12 ~]# cd /usr/share/doc/zabbix-proxy-mysql-3.0.9/[root@node-12 zabbix-proxy-mysql-3.0.9]# zcat schema.sql.gz | mysql -uzabbix_proxy -p zabbix_proxyEnter password: #密码是：zabbix_proxy 是我们数据库授权的密码 检查数据库12345&gt;show databases;&gt;use zabbix_proxy;&gt;show tables;#查看是否含有数据 我们需要修改proxy的配置文件12345678910111213141516171819202122232425262728[root@node-12 ~]# vim /etc/zabbix/zabbix_proxy.confServer=192.168.10.10（zabbixserver端IP）Hostname=Zabbix proxyDBName=zabbix_proxy#数据库名称DBUser=zabbix_proxy#用户名DBPassword=zabbix_proxy#用户密码配置文件中没有配置的内容如下：（有需要可以配置）# ProxyLocalBuffer=0#数据保留的时间（小时为单位）# ProxyOfflineBuffer=1#连不上Server，数据要保留多久（小时为单位，默认1小时）# DataSenderFrequency=1#数据的发送时间间隔（默认是1秒）# StartPollers=5#启动的线程数# StartIPMIPollers=0#启动IPMI的线程数从这往下都是性能的监控，就不一次说明了。 上面都有中文注释 过滤修改过的配置如下：123456789101112[root@node-12 ~]# grep &apos;^[a-Z]&apos; /etc/zabbix/zabbix_proxy.confServer=192.168.10.10Hostname=Zabbix proxyLogFile=/var/log/zabbix/zabbix_proxy.logLogFileSize=0PidFile=/var/run/zabbix/zabbix_proxy.pidDBName=zabbix_proxyDBUser=zabbix_proxySNMPTrapperFile=/var/log/snmptrap/snmptrap.logTimeout=4ExternalScripts=/usr/lib/zabbix/externalscriptsLogSlowQueries=3000 启动：12345678910111213141516171819202122[root@node-12 ~]# systemctl start zabbix-proxy (坑：需要被seLinux关闭，不然起不来)[root@node-12 ~]# netstat -lntupActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2558/master tcp 0 0 0.0.0.0:5050 0.0.0.0:* LISTEN 1483/mesos-master tcp 0 0 0.0.0.0:5051 0.0.0.0:* LISTEN 2997/mesos-slave tcp 0 0 0.0.0.0:10051 0.0.0.0:* LISTEN 7992/zabbix_proxy tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1501/sshd tcp6 0 0 ::1:25 :::* LISTEN 2558/master tcp6 0 0 :::10051 :::* LISTEN 7992/zabbix_proxy tcp6 0 0 :::3306 :::* LISTEN 2949/mysqld tcp6 0 0 :::22 :::* LISTEN 1501/sshd udp 0 0 192.168.10.12:123 0.0.0.0:* 823/ntpd udp 0 0 172.17.0.1:123 0.0.0.0:* 823/ntpd udp 0 0 127.0.0.1:123 0.0.0.0:* 823/ntpd udp 0 0 0.0.0.0:123 0.0.0.0:* 823/ntpd udp 0 0 0.0.0.0:33999 0.0.0.0:* 780/avahi-daemon: r udp 0 0 0.0.0.0:5353 0.0.0.0:* 780/avahi-daemon: r udp6 0 0 fe80::20c:29ff:fe81:123 :::* 823/ntpd udp6 0 0 ::1:123 :::* 823/ntpd udp6 0 0 :::123 :::* 823/ntpd Zabbix-proxy 监控10051端口，因为是代理就必须跟Server的端口相同，对于Agent Proxy就是Server ##Zabbix Web 添加## 修改agent主机 我们需要将这代理端的数据发送给给Proxy编辑agent端（192.168.10.11）这台主机，需要将Server的IP地址修改成自己的1234[root@node-11 ~]# vim /etc/zabbix/zabbix_agentd.conf ServerActive=192.168.10.11#配置文件修改完需要重启[root@node-11 ~]# systemctl restart zabbix-agent 这时候我们就可以看到那个proxy都管理了那些机器,做到方便管理的机制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 主动式监控]]></title>
      <url>%2F2016%2F10%2F04%2Fzabbix%203.0%20%E4%B8%BB%E5%8A%A8%E5%BC%8F%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[监控常遇到的问题？ 1.监控主机多，性能跟不上，延迟大 2.多机房，防火墙因素Zabbix轻松解决以上问题，Nagios不太好解决的问题。 Zabbix 模式介绍：1、被动模式2、主动模式 默认是被动模式，我们可以通过以下方式查看监控项是什么模式 因为我们使用的是模板，无法进行修改。我们可以修改配置文件或者新建item的时候设置。 注意： 1、当监控主机超过300+，建议使用主动模式（此处是一个经验值，要根据服务器的硬件来进行考虑） 2、还需要保证Queue对列里面没有延迟的主机 Queue 对列介绍如果此处的延迟主机有点多的话，我们就需要将被动模式修改为主动模式. 主动模式设置将原来的agent端192.168.10.11监控设置为主动模式 ### 修改配置文件为了方便模拟，我们将node-11(192.168.10.11)从Zabbix删除从新添加 配置zabbix_agentd.conf文件123456789101112131415[root@node-11 ~]# vim /etc/zabbix/zabbix_agentd.conf#Server=192.168.10.10#servr端IP,我们需要注释Server，因为这个是被动模式用的StartAgents=0#设置为0之后就不会TCP端口，之前监听TCP端口是因为Server要去问agent信息所以需要开启ServerActive=192.168.10.10#server端IP，此处可以是IP或者是域名，他会连接10051端口Hostname=node-11#agent端主机名，唯一识别符，我们需要修改成我们本机的主机名。如果我们不设置，它默认会通过item来获取[root@node-11 ~]# systemctl restart zabbix-agent.service 保存重启 保存重启之后我们可以查看我们监听的一些端口，因为我们关闭的被动模式所以不会在监听zabbix端口了 12345678910[root@node-11 ~]# netstat -lntupActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2435/master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1416/sshd tcp6 0 0 ::1:25 :::* LISTEN 2435/master tcp6 0 0 :::3306 :::* LISTEN 2606/mysqld tcp6 0 0 :::22 :::* LISTEN 1416/sshd udp 0 0 0.0.0.0:51218 0.0.0.0:* 757/avahi-daemon: r udp 0 0 0.0.0.0:5353 0.0.0.0:* 757/avahi-daemon: r Zabbix-web设置我们需要添加zabbix-agent active(也就是主动模式)添加模板，zabbix没有提供主动模式的模板。所以我们需要克隆一下OS Linux 找到OS Linux 模板，移动到最下面 点击复制 我们从新进行设置名称 修改我们刚刚添加的模板名为OS Linux Active 我们点击刚刚创建模板的item 进行批量更新然后选择最下方Update 结果如下： 添加主机 最终结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 自定义监控--磁盘读写]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7--%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%2F</url>
      <content type="text"><![CDATA[zabbix 客户端修改zabbix_agentd.conf文件在zabbix_agentd.conf最后添加以下内容1234[root@node-11 ~]# vim /etc/zabbix/zabbix_agentd.confUserParameter=check_disk_status,mount | awk &apos;&#123;print $NF&#125;&apos;|cut -c 2-3|awk &apos;&#123;if($1~/ro/) &#123;print 1&#125;&#125;&apos;|wc -l|awk &apos;&#123;if($1&lt;=0) &#123;print 0 &#125; else &#123;print 1&#125;&#125;&apos;[root@node-11 ~]# systemctl restart zabbix-agent zabbix 服务端新增监控项 新增图形结果如果返回值0代表磁盘都是rw状态可以正常读写，返回值1的话，代表磁盘是ro状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 自定义监控--磁盘IO]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7--%E7%A3%81%E7%9B%98IO%2F</url>
      <content type="text"><![CDATA[对于我们的服务器来说，性能瓶颈往往就是磁盘，针对这种情况，我觉得我们有必要监控磁盘的IO情况，这里我们使用iostat命令取得的结果，然后图形化的展示到zabbix中。zabbix的安装配置叫简单这么不做过多的描述 zabbix中自定义监控的key12345678[root@node-11 ~]# yum install -y sysstat[root@node-11 ~]# vim /etc/zabbix/zabbix_agentd.conf ##disk_ioUserParameter=io_sda_idle,iostat -x /dev/mapper/centos-root | sed -n &apos;4p&apos; | awk &apos;&#123;print $NF&#125;&apos;UserParameter=io_sda_iowait,iostat -x /dev/mapper/centos-root | sed -n &apos;4p&apos; | awk &apos;&#123;print $4&#125;&apos;UserParameter=io_sda_tps,iostat -d /dev/mapper/centos-root | sed -n &apos;4p&apos; | awk &apos;&#123;print $2&#125;&apos;[root@node-11 ~]# systemctl restart zabbix-agent 添加监控项添加监控项添加图形最终结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 自定义监控--磁盘使用率]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7--%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87%2F</url>
      <content type="text"><![CDATA[磁盘监控脚本本次zabbix监控磁盘测试。只监控磁盘的/目录和mount挂载的home两个目录使用率情况。1234567891011磁盘情况[root@node-11 ~]# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 50G 2.1G 48G 5% /devtmpfs 911M 0 911M 0% /devtmpfs 918M 0 918M 0% /dev/shmtmpfs 918M 8.6M 909M 1% /runtmpfs 918M 0 918M 0% /sys/fs/cgroup/dev/mapper/centos-home 42G 33M 42G 1% /home/dev/sda1 497M 97M 400M 20% /boottmpfs 184M 0 184M 0% /run/user/0 磁盘监控脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@node-11 script]# pwd/etc/zabbix/script[root@node-11 script]# vim disk_use.sh#!/bin/bashsystem()&#123; df -m |awk &apos;&#123;if($1~&quot;/dev&quot;) print $2,$3,$4,$5,$NF&#125;&apos;|grep &quot;/$&quot;&#125;mount()&#123; df -m | awk &apos;&#123;if($1~&quot;/dev&quot;) print $2,$3,$4,$5,$NF&#125;&apos;|grep &quot;/home$&quot;&#125;system_inode()&#123; df -i | awk &apos;&#123;if($1~&quot;/dev&quot;) print $2,$3,$4,$5,$NF&#125;&apos;|grep &quot;/$&quot;&#125;mount_inode()&#123; df -i | awk &apos;&#123;if($1~&quot;/dev&quot;) print $2,$3,$4,$5,$NF&#125;&apos;|grep &quot;/home$&quot;&#125;case &quot;$1&quot; in system_size) #system | awk &apos;&#123;print$1&apos;&#125; | awk &apos;&#123;sub(/.$/,&quot;&quot;)&#125;1&apos; system | awk &apos;&#123;print$1&apos;&#125; ;; system_used) system | awk &apos;&#123;print$2&apos;&#125; ;; system_avail) system | awk &apos;&#123;print$3&apos;&#125; ;; system_use) system | awk &apos;&#123;print$4&apos;&#125; | awk &apos;&#123;sub(/.$/,&quot;&quot;)&#125;1&apos; ;; mount_size) mount | awk &apos;&#123;print $1&#125;&apos; ;; mount_used) mount | awk &apos;&#123;print $2&#125;&apos; ;; mount_avail) mount | awk &apos;&#123;print $3&#125;&apos; ;; mount_use) mount | awk &apos;&#123;print $4&#125;&apos; | awk &apos;&#123;sub(/.$/,&quot;&quot;)&#125;1&apos; ;; system_inode_use) system_inode | awk &apos;&#123;print$4&apos;&#125; | awk &apos;&#123;sub(/.$/,&quot;&quot;)&#125;1&apos; ;; mount_inode_use) mount_inode | awk &apos;&#123;print $4&#125;&apos; |awk &apos;&#123;sub(/.$/,&quot;&quot;)&#125;1&apos; ;;esac[root@node-11 script]# chmod +x disk_use.sh 添加磁盘自定义键值12345678910111213[root@node-11 script]# vim /etc/zabbix/zabbix_agentd.conf ##在末尾添加以下内容##disk_useUserParameter=system.size,/etc/zabbix/script/disk_use.sh system_sizeUserParameter=system.used,/etc/zabbix/script/disk_use.sh system_usedUserParameter=system.avail,/etc/zabbix/script/disk_use.sh system_availUserParameter=system.use,/etc/zabbix/script/disk_use.sh system_useUserParameter=mount.size,/etc/zabbix/script/disk_use.sh mount_sizeUserParameter=mount.used,/etc/zabbix/script/disk_use.sh mount_usedUserParameter=mount.avail,/etc/zabbix/script/disk_use.sh mount_availUserParameter=mount.use,/etc/zabbix/script/disk_use.sh mount_useUserParameter=system.inode.use,/etc/zabbix/script/disk_use.sh system_inode_useUserParameter=mount.inode.use,/etc/zabbix/script/disk_use.sh mount_inode_use 在zabbix-server端测试1234567891011121314151617181920[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k system.avail49049[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k system.use5[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.inode.use1[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.size42596[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.used33[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.avail[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.avail42564[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.use1[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k system.inode.use1[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k mount.inode.use1 zabbix web端配置添加监控项添加图形最终结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 自定义监控--内存、cpu、负载]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7--%E5%86%85%E5%AD%98%E3%80%81cpu%E3%80%81%E8%B4%9F%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[客户端编写监控内存脚本 12345678910111213141516171819202122232425bash-3.2# yum install -y zabbix zabbix-agentbash-3.2# cd /etc/zabbixbash-3.2 zabbix# mkdir scriptbash-3.2 zabbix# vim script/mem.sh#!/bin/bashMEMTotal()&#123;free -m | awk &apos;/Mem:/&#123;print $2&#125;&apos;&#125; MEMuser()&#123;free -m | awk &apos;/buffers\/cache:/&#123;print $3&#125;&apos;&#125; MEMfree()&#123;free -m | awk &apos;/buffers\/cache:/&#123;print $4&#125;&apos;&#125;$1bash-3.2 zabbix# vim zabbix_agentd.conf #末尾新增如下UnsafeUserParameters=1UserParameter=memtotal,/etc/zabbix/script/mem.sh MEMTotalUserParameter=memuse,/etc/zabbix/script/mem.sh MEMuserUserParameter=memfree,/etc/zabbix/script/mem.sh MEMfreebash-3.2 zabbix# /etc/init.d/zabbix-agent startbash-3.2 ~# zabbix_get -s zabbix_agent_ip -k memfree #zabbix服务端执行718 这里的键值是根据客户端脚本所定义的. 监控cpu使用率]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 自定义监控]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[为什么要自定义KEY有时候我们想让被监控端执行一个zabbix没有预定义的检测，zabbix的用户自定义参数功能提供了这个方法。我们可以在客户端配置文件zabbix_angentd.conf里面配置UserParameter.语法如下: UserParameter=key,command 用户自定义参数包含一个key和一个命令，key必须整个系统唯一，配置好之后，重启客户端。 然后配置item,在key的位置填上我们自定义的key即可。 用户自定义参数里指定的脚本由zabbix agent来执行，最大可以返回512KB的数据. 实例（以监控memory free为例）12[root@node-11 ~]# vim /etc/zabbix/zabbix_agentd.confUserParameter=memory.free,/usr/bin/free | awk &apos;/^Mem:/&#123;print $4&#125;&apos; 说明：UserParameter为语法，memory.free为key值， /usr/bin/free为free的全路径，awk ‘/^Men:/{print $4}’为用awk所执行的命令，同时这里也可以把脚本路径填写到这里。1[root@node-11 ~]# systemctl restart zabbix-agent 在服务器端模拟获取数据（如获取不到数据，仔细查看你的key或Ip是否对，等等）123456789[root@node-11 ~]# /usr/bin/free total used free shared buffers cachedMem: 1878212 1779704 98508 8908 64 1205268-/+ buffers/cache: 574372 1303840Swap: 8273916 0 8273916[root@node-10 ~]# zabbix_get -s 192.168.1.11 -k &quot;memory.free&quot;98360提示：因为内存正在使用，所以获取的值有一点相差，不影响 在服务端添加到监控项配置—–主机—–你的主机—–监控项监控项—-创建监控项—–添加配置–主机–图形–创建图形查看图形结果12345[root@node-11 ~]# free -m total used free shared buffers cachedMem: 1834 1735 98 8 0 1177-/+ buffers/cache: 558 1275Swap: 8079 0 8079]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 服务监控--Web监控]]></title>
      <url>%2F2016%2F10%2F03%2Fzabbix%203.0%20%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7--Web%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[检查1.查看进程123[root@node-11 ~]# ps -ef | grep javaroot 27297 1 3 18:43 pts/1 00:00:04 /usr/local/java/bin/java -Djava.util.logging.config.file=/usr/local/apache-tomcat-8.0.9/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/usr/local/apache-tomcat-8.0.9/endorsed -classpath /usr/local/apache-tomcat-8.0.9/bin/bootstrap.jar:/usr/local/apache-tomcat-8.0.9/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/apache-tomcat-8.0.9 -Dcatalina.home=/usr/local/apache-tomcat-8.0.9 -Djava.io.tmpdir=/usr/local/apache-tomcat-8.0.9/temp org.apache.catalina.startup.Bootstrap startroot 27993 2730 0 18:45 pts/1 00:00:00 grep --color=auto java 2.查看端口123[root@node-11 ~]# lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 27297 root 49u IPv6 148863 0t0 TCP *:webcache (LISTEN) 3.测试是否可以访问8080端口123456[root@node-11 ~]# curl -I 192.168.1.11:8080HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Type: text/html;charset=UTF-8Transfer-Encoding: chunkedDate: Sat, 29 Apr 2017 10:46:51 GMT Zabbix Web界面配置提示： 监控Web 不依赖于agent，是server直接发送请求的提示： 这里名字叫做Web场景，因为我们可以设置触发上面3个选项后，才进行报警提示： 字符串里面可以添加一些字符串，当请求下来有这个字符串就是正常，没有就是不正常。但是最常用的还是状态 新添加web监控，zabbix默认是没有给我们设置触发器的，需要我们自己设置 触发器添加 Web监控中默认不含有触发器，所以需要手动添加最终结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 服务监控--MySQL]]></title>
      <url>%2F2016%2F10%2F02%2Fzabbix%203.0%20%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7--MySQL%2F</url>
      <content type="text"><![CDATA[Mysql监控zabbix自带了一个监控mysql的模板，但是真正监控mysql的并不是zabbix自带的模板。而是percona公司的一个监控mysql模板 percona官网： www.percona.com*Percona组成介绍 1、php脚本 用来数据采集 2、shell脚本 用来调用采集信息 3、zabbix配置文件 4、zabbix模板文件 安装文档：https://www.percona.com/doc/percona-monitoring-plugins/LATEST/zabbix/index.html percona 利用的是php来获取mysql的相关信息，所以如果我们想使用percona插件监控mysql就需要在agent端安装php。在安装文档上有写哦~安装步骤： 查看上面的链接也可以进行安装我们安装在zabbix-agent上，因为上面有一个MySQL1234567891011121314[root@node-11 web]# yum install http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm[root@node-11 web]# yum install percona-zabbix-templates php php-mysql -y#percona插件是通过php去获取mysql的参数，所以我们要安装php和php-mysql我们可以查看它都安装了那些软件[root@node-11 web]# rpm -ql percona-zabbix-templates/var/lib/zabbix/percona/var/lib/zabbix/percona/scripts/var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh #shell脚本/var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php #php获取mysql信息/var/lib/zabbix/percona/templates/var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf #zabbix配置文件/var/lib/zabbix/percona/templates/zabbix_agent_template_percona_mysql_server_ht_2.0.9-sver1.1.6.xml #zabbix模板文件在percona组成我们已经说过了，此处只是略微介绍 我们将zabbix模板下载下来1[root@node-11 web]# sz /var/lib/zabbix/percona/templates/zabbix_agent_template_percona_mysql_server_ht_2.0.9-sver1.1.6.xml 然后我们需要将模板通过web界面导入到zabbix中 提示：如果出现错误，可能是zabbix 3.0版本的问题。我们这里提供了一个生产的模板下载链接：http://pan.baidu.com/s/1pLjKvxh 密码：75g0然后从新上传之后导入即可 复制配置文件123456[root@node-11 web]# cp /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf /etc/zabbix/zabbix_agentd.d/[root@node-11 web]# ls /etc/zabbix/zabbix_agentd.d/#安装完软件包后会在/var/lib/zabbix/percona/templates/目录下产生一个配置文件，我们将它拷贝，因为在前面的博文中，我们已经修改过zabbix的配置文件[Include=/etc/abbix/zabbix_agentd.d/] 所以将配置文件放在这个目录下，zabbix就会自己在这个目录下查找相关信息[root@node-11 web]# systemctl restart zabbix-agent.service 重启一下！ 下面就应该配置与MySQL的连接在/var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php.cnf创建一个文件12345[root@linux-node1 ~]# cat /var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php.cnf&lt;?php$mysql_user = &apos;root&apos;;$mysql_pass = &apos;&apos;;#用户名密码可以自己创建，有密码写密码，没密码为空就好了 提示： 正常这里的用户我们应该创建一个专门用来监控的，由于我这里是测试环境。就不浪费时间了 测试查看是否可以获取到值，随便找一个测试1234567891011[root@node-11 ~]# cat /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf选择一个肯定有值的key[root@node-11 ~]# cat /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf|grep gmUserParameter=MySQL.read-views,/var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh gm测试结果如下：[root@node-11 ~]# cd /var/lib/zabbix/percona/scripts/[root@node-11 scripts]# ./get_mysql_stats_wrapper.sh gm1[root@node-11 scripts]# ./get_mysql_stats_wrapper.sh gw468可以获取到值，说明没有问题 温馨提示： shell脚本中数据库的路径是localhost，如果我们没有授权localhost会获取不到值1234[root@node-11 scripts]# cat get_mysql_stats_wrapper.sh HOST=localhost RES=`HOME=~zabbix mysql -e &apos;SHOW SLAVE STATUS\G&apos; | egrep &apos;(Slave_IO_Running|Slave_SQL_Running):&apos; | awk -F: &apos;&#123;print $2&#125;&apos; | tr &apos;\n&apos; &apos;,&apos;`#mysql是通过命令来获取的，如果环境变量不一样 也可能造成影响 Zabbix_Web界面配置添加mysql监控模板（之前上传的模板） 结果如下图 思想： 如果出现错误我们需要先查看shell的脚本，因为shell是去调用php。 错误的因素有很多，最简单的方法就是用shell 后面加上key 看看是否可以有值。 其中报错最多的地方就是php和mysql连接的问题，还有我们mysql授权的一些问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 服务监控--nginx]]></title>
      <url>%2F2016%2F10%2F02%2Fzabbix%203.0%20%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7--nginx%2F</url>
      <content type="text"><![CDATA[在zabbix agentd客户端上，查看nginx是否加载了–with-http_stub_status_module。因为zabbix监控nginx是根据nginx的Stub Status模块，抓取Status模块所提供的数据。假如以前没开启，现在想启用StubStatus 模块，在编译nginx 的时候要加上参数 –with-http_stub_status_module，执行./configure &amp;&amp; make就可以了，不用make install。不过，一般情况下都是安装了的。 nginx安装1[root@node-11 ~]# yum install -y nginx 添加nginx_status模块1234567891011121314[root@node-11 ~]# cd /etc/nginx/conf.d/[root@node-11 conf.d]# vim nginx_status.conf server &#123; listen 80; location /nginx_status &#123; stub_status on; allow 127.0.0.1; allow 192.168.1.10; access_log off;&#125;&#125;提示：nginx必须要有--with-http_stub_status_module模块 nginx状态测试测试：http://192.168.1.11/nginx_status 解释说明：使用zabbix来监控nginx状态，通过status状态模块为前提我们现在命令取出我们想要的值，例如：123[root@node-11 conf.d]# curl -s http://192.168.1.11/nginx_status|grep Active|awk -F &quot;[ ]&quot; &apos;&#123;print $3&#125;&apos;1这里我们现在只是监控了nginx的一种最大连接数的状态，其实我们可以监控其他的状态 nginx自定义文件 自己编写一个nginx文件123456789101112[root@node-11 ~]# cd /etc/zabbix/zabbix_agentd.d/[root@node-11 zabbix_agentd.d]# ll总用量 12-rw-r--r--. 1 root root 469 4月 29 17:04 nginx_status.conf[root@node-11 zabbix_agentd.d]# cat nginx_status.conf UserParameter=nginx.active,/usr/local/src/nginx_status.sh activeUserParameter=nginx.accepts,/usr/local/src/nginx_status.sh acceptsUserParameter=nginx.handled,/usr/local/src/nginx_status.sh handledUserParameter=nginx.requests,/usr/local/src/nginx_status.sh requestsUserParameter=nginx.reading,/usr/local/src/nginx_status.sh readingUserParameter=nginx.writing,/usr/local/src/nginx_status.sh writingUserParameter=nginx.waiting,/usr/local/src/nginx_status.sh waiting 添加nginx监控脚本123456789101112131415161718192021222324[root@node-11 zabbix_agentd.d]# cd /usr/local/src/[root@node-11 src]# ll总用量 8-rwxr-xr-x. 1 root root 759 4月 29 17:05 nginx_status.sh[root@node-11 src]# cat nginx_status.sh#!/bin/bashcase $1 in active) curl -s http://127.0.0.1/nginx_status | awk &apos;/Active/ &#123;print $3&#125;&apos; ;; accepts) curl -s http://127.0.0.1/nginx_status | awk &apos;NR==3 &#123;print $1&#125;&apos; ;; handled) curl -s http://127.0.0.1/nginx_status | awk &apos;NR==3 &#123;print $2&#125;&apos; ;; requests) curl -s http://127.0.0.1/nginx_status | awk &apos;NR==3 &#123;print $3&#125;&apos; ;; reading) curl -s http://127.0.0.1/nginx_status | awk &apos;/Reading/ &#123;print $2&#125;&apos; ;; writing) curl -s http://127.0.0.1/nginx_status | awk &apos;/Writing/ &#123;print $4&#125;&apos; ;; waiting) curl -s http://127.0.0.1/nginx_status | awk &apos;/Waiting/ &#123;print $6&#125;&apos; ;; *) echo &quot;Usage: $0 &#123; active | accepts | handled | requests | reading | writing | waiting &#125;&quot; ;;esa 修改完配置文件都要重启zabbix-agent 在server端对nginx进行测试12345678910111213[root@node-10 ~]# yum install -y zabbix-get[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.active&quot;1[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.accepts&quot;4839[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.requests&quot;4841[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.reading&quot;0[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.writing&quot;1[root@node-10 ~]# zabbix_get -s 192.168.1.11 -p 10050 -k &quot;nginx.waiting&quot;0 以上测试正确，我们还需要在zabbix-web页面上进行设置 监控项添加在主机模板上新添一个监控项：现在一个监控项已经添加好，剩余的直接克隆模板，修改就行最终监控项结果 图形添加最终结果： 添加自定义监控项小结： * 1、添加用户自定义参数（在/etc/zabbix/zabbix.agent.d/定义了一个nginx_status.conf步骤如上）, 2.添加用户自定义获取nginx状态的脚本（/usr/local/src/nginx_status.sh） 2、重启zabbix-agent 3、在Server端使用zabbix_get测试获取（命令如上） 4、在web界面创建item（监控项） 5、在web界面创建图形]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zabbix 3.0 基础介绍]]></title>
      <url>%2F2016%2F10%2F01%2Fzabbix%203.0%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%20%5B%E4%B8%80%5D%2F</url>
      <content type="text"><![CDATA[Zabbix介绍zabbix 简介 Zabbix是一个高度集成的网络监控解决方案，可以提供企业级的开源分布式监控解决方案，由一个国外的团队持续维护更新，软件可以自由下载使用，运作团队靠提供收费的技术支持赢利 zabbix是一个基于Web界面的，提供分布式系统监控以及网络监视功能的企业级的开源解决方案。 zabbix能监视各种网络参数，保证服务器系统的安全运营，并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题 zabbix主要由2部分构成zabbixserver和zabbixagent，可选组建zabbix proxyzabbix。 server可以通过SNMP，zabbixagent，fping端口监视等方法对远程服务器或网络状态完成监视，数据收集等功能。同时支持Linux以及Unix平台，Windows平台只能安装客户端 zabbix功能 ①具备常见的商业监控软件所具备的功能（主机的性能监控、网络设备性能监控、数据库、性能监控、FTP 等通用协议监控、多种告警方式、详细的报表图表绘制） ②支持自动发现网络设备和服务器（可以通过配置自动发现服务器规则来实现） ③支持自动发现（low discovery）key 实现动态监控项的批量监控（需写脚本） ④支持分布式，能集中展示、管理分布式的监控点 ⑤扩展性强，server 提供通用接口（api 功能），可以自己开发完善各类监控（根据相关接口编写程序实现）编写插件容易，可以自定义监控项，报警级别的设置。 ⑥数据收集 可用和性能检测 支持snmp(包括trapping and polling)，IPMI，JMX，SSH，TELNET 自定义的检测 自定义收集数据的频率 服务器/代理和客户端模式 灵活的触发器 可以定义非常灵活的问题阈值，称为触发器，从后端数据库的参考值 高可定制的报警 发送通知，可定制的报警升级，收件人，媒体类型 通知可以使用宏变量有用的变量 自动操作包括远程命令 实时的绘图功能 监控项实时的将数据绘制在图形上面 WEB 监控能力 ZABBIX 可以模拟鼠标点击了一个网站，并检查返回值和响应时间 Api 功能应用api功能，可以方便的和其他系统结合，包括手机客户端的使用。更多功能请查看http://www.zabbix.com/documentation.php Zabbix版本Zabbix 3.0 ManualZabbix 2.4 ManualZabbix 2.2 ManualZabbix 2.0 Manual下载地址：http://www.zabbix.com/documentation.php本次采用yum安装，安装zabbix3.0.使用Centos7 Zabbix优缺点优点 1、开源，无软件成本投入 2、Server 对设备性能要求低 3、支持设备多，自带多种监控模板 4、支持分布式集中管理，有自动发现功能，可以实现自动化监控 5、开放式接口，扩展性强，插件编写容易 6、当监控的item 比较多服务器队列比较大时可以采用被动状态，被监控客户端主动从 7、server 端去下载需要监控的item 然后取数据上传到server 端。这种方式对服务器的负载比较小。 8、Api 的支持，方便与其他系统结合缺点 需在被监控主机上安装agent，所有数据都存在数据库里，产生的数据据很大,瓶颈主要在数据库。 Zabbix监控原理Server：Zabbix Server需运行在LAMP（Linux+Apache+Mysql+PHP）环境下（或者LNMP），对硬件要求低。Agent：目前已有的agent基本支持市面常见的OS，包含Linux、HPX、Solaris、Sun、 windowsSNMP：支持各类常见的网络设备 SNMP(Simple NetworkManagement Protocol,简单网络管理协议 Zabbix监控过程逻辑图 监控类型硬件监控: 适用于物理机、远程管理卡（iDRAC），IPMI（只能平台管理接口） ipmitools:，MegaCli（查看Raid磁盘）系统监控: 监控cpt：lscpu、uptime、top、vmstat 1 、mpstat 1、htop监控内存: free -m监控硬盘: df -h、iotop监控网络： iftop、netstat、ss应用服务监控： tomcat、MySQL、nginx、apache、php、redis更详细的监控类型可以参考:https://tangxiaoyue.github.io/2017/01/01/%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/ 引入zabbix所有监控范畴，都可以整合到Zabbix中 :硬件监控：Zabbix、IPMI、lnterface系统监控：Zabbix、Agent、InterfaceJava监控：Zabbix、JMX、lnterface网络设备监控：Zabbix、SNMP、lnterface应用服务监控：Zabbix、Agent、UserParameterMySQL数据库监控：percona-monitoring-plulginsURL监控：Zabbix Web监控 Zabbix 环境配置环境信息123456[root@node-10 ~]# cat /etc/redhat-release CentOS Linux release 7.0.1406 (Core) [root@localhost ~]# uname -r3.10.0-123.el7.x86_64[root@node-10 ~]# ifconfig|awk -F &apos; &apos; &apos;NR==2&#123;print $2&#125;&apos;192.168.1.10 yum安装zabbix-server阿里云yum源已经提供了zabbix3.0，因此我们需要使用官方yum源。官方yum源下载会比较慢1[root@node-10 ~]# rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm 问题：为什么要下载release版本的zabbix？因为下载这个版本会在yum.repos.d下面生成一个zabbix.repo的文件123456789[root@node-10 ~]# ll /etc/yum.repos.d/总用量 28-rw-r--r--. 1 root root 1612 7月 4 2014 CentOS-Base.repo-rw-r--r--. 1 root root 640 7月 4 2014 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 1331 7月 4 2014 CentOS-Sources.repo-rw-r--r--. 1 root root 156 7月 4 2014 CentOS-Vault.repo-rw-r--r--. 1 root root 957 12月 28 01:37 epel.repo-rw-r--r--. 1 root root 1056 12月 28 01:37 epel-testing.repo-rw-r--r--. 1 root root 401 2月 15 2016 zabbix.repo 安装zabbix-server相关软件包1[root@node-10 ~]# yum install zabbix-server zabbix-web zabbix-server-mysql zabbix-web-mysql mariadb-server mariadb -y 提示：在Centos7中，mysql改名为mariadb安装zabbix-agent12[root@node-10 ~]# rpm -ivh http://repo.zabbix.com/zabbix/2.4/rhel/7/x86_64/zabbix-release-2.4-1.el7.noarch.rpm[root@node-10 ~]# yum install -y zabbix-agent 修改PHP时区设置12[root@node-10 ~]# sed -i &apos;s@# php_value date.timezone Europe/Riga@php_value date.timezone Asia/Shanghai@g&apos; /etc/httpd/conf.d/zabbix.conf#要注意需要改的配置文件是/etc/httpd/conf.d/zabbix.conf而不是/etc/php.ini， 数据库设置启动数据库1[root@node-10 ~]# systemctl start mariadb 创建zabbix数据库及用户1234mysql&gt; create database zabbix character set utf8 collate utf8_bin;&gt; grant all on zabbix.* to zabbix@&apos;localhost&apos; identified by &apos;123456&apos;;&gt; exit 导入数据12345678910[root@node-10 ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.9/[root@node-10 zabbix-server-mysql-3.0.9]# ll总用量 1872-rw-r--r--. 1 root root 98 4月 20 20:05 AUTHORS-rw-r--r--. 1 root root 718465 4月 20 20:05 ChangeLog-rw-r--r--. 1 root root 17990 4月 20 20:05 COPYING-rw-r--r--. 1 root root 1159237 4月 24 02:04 create.sql.gz-rw-r--r--. 1 root root 52 4月 20 20:05 NEWS-rw-r--r--. 1 root root 188 4月 20 20:05 README[root@node-10 zabbix-server-mysql-3.0.4]# zcat create.sql.gz |mysql -uzabbix -p123456 zabbix 我们使用zcat，专门查看sql.gz包。和cat基本相似 修改zabbix配置文件12345[root@node-10 ~]# vim /etc/zabbix/zabbix_server.conf DBHost=localhost #数据库所在主机DBName=zabbix #数据库名DBUser=zabbix #数据库用户DBPassword=123456 #数据库密码 启动zabbix及apache123[root@localhost ~]# systemctl start zabbix-server[root@localhost ~]# systemctl start httpd注意：如果没有启动成功，要看一下是不是80端口被占用 Web界面安装master访问地址：http://192.168.1.11/zabbix/setup.php点击Next step进行安装…点击Finish 提示：上去之后请立即修改密码 配置zabbix-agent端1234[root@localhost ~]# vim /etc/zabbix/zabbix_agentd.conf Server=127.0.0.1 修改Server端的IP地址（被动模式IP地址）ServerActive=127.0.0.1 主动模式，主动向server端报告[root@localhost ~]# systemctl start zabbix-agent 12345678910111213[root@node-10 ~]# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2434/master tcp 0 0 0.0.0.0:10050 0.0.0.0:* LISTEN 4103/zabbix_agentd tcp 0 0 0.0.0.0:10051 0.0.0.0:* LISTEN 3887/zabbix_server tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 3800/mysqld tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1482/sshd tcp6 0 0 ::1:25 :::* LISTEN 2434/master tcp6 0 0 :::10050 :::* LISTEN 4103/zabbix_agentd tcp6 0 0 :::10051 :::* LISTEN 3887/zabbix_server tcp6 0 0 :::80 :::* LISTEN 3973/httpd tcp6 0 0 :::22 :::* LISTEN 1482/sshd Web界面配置修改密码语言界面风格 设置中文字符集语言设置成中文之后发现是图形下面的文字出现乱码，不能显示出中文 zabbix默认字体在/usr/share/zabbix/fonts目录下1234[root@node-10 fonts]# cd /usr/share/zabbix/fonts[root@node-10 fonts]# ll总用量 0lrwxrwxrwx. 1 root root 33 4月 29 15:49 graphfont.ttf -&gt; /etc/alternatives/zabbix-web-font 上传微软字体可以在Windows这个目录里面找字体12345678[root@node-10 fonts]# yum install -y lrzsz[root@node-10 fonts]# rz -y[root@node-10 fonts]# ll总用量 35524lrwxrwxrwx. 1 root root 33 4月 29 15:49 graphfont.ttf -&gt; /etc/alternatives/zabbix-web-font-rw-r--r--. 1 root root 14602860 6月 11 2009 msyhbd.ttf-rw-r--r--. 1 root root 21767952 6月 11 2009 msyh.ttf 修改zabbix的web页面文件/usr/share/zabbix/include/defines.inc.php1234[root@node-10 ~]# vim /usr/share/zabbix/include/defines.inc.phpdefine(&apos;ZBX_GRAPH_FONT_NAME&apos;, &apos;msyh&apos;); // font file namedefine(&apos;ZBX_FONT_NAME&apos;, &apos;msyh&apos;); 其中msyh为字体的前缀不包含ttf后缀。刷新页面后，完美的字体重新，不再是乱码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监控体系]]></title>
      <url>%2F2016%2F10%2F01%2F%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[监控对象1.监控对象的理解：CPU是怎么工作的,原理2.监控对象的指标：CPU使用率，CPU负载，CPU个数，上下文切换3.确定性能基准线：怎样才算故障？CPU负载多少才算高 监控范围1.硬件监控服务器的硬件故障2.操作系统监控CPU、内存、硬盘、IO、进程3.应用服务监控nginx、mysql等服务4.业务监控 硬件监控1.使用IPMI2.机房巡检 远程控制卡：DELL服务器：IDRACHP服务器：ILO—-Linux就可以使用IPMI（依赖于BMC控制器）IBM服务器：IMM Linux是管理IPMI工具ipmitools（监控和控制） 1.硬件要支持2.操作系统Linux IPMI ipmitool安装 [root@tang ~]# yum install OpenIPMI ipmitool -y [root@tang ~]# rpm -qa OpenIPMI ipmitool OpenIPMI-2.0.19-15.el7.x86_64 ipmitool-1.8.15-7.el7.x86_64 使用IPMI有两种方式 1.本地进行调用 2.远程调用（IP地址 用户名和密码） [root@tang ~]# systemctl start ipmi 启动（以centos7为例） IPMI相关命令 [root@tang ~]# ipmitool --help IPMI配置网络，有两种方式： 1.ipmi over lan（大体意识是通过网络来进行连接） 2.独立（给服务器单独查一根网线）Dell服务器可以在小面板中设置IPMI（云主机不需要考虑IPMI） SNMP监控对于路由器和交换机:SNMP（简单网络管理协议）监控配置SNMP：（可以参考监控宝来进行监控） [root@tang ~]# yum -y install net-snmp net-snmp-utils [root@tang ~]# rpm -qa net-snmp net-snmp-utils net-snmp-5.7.2-24.el7_3.2.x86_64 net-snmp-utils-5.7.2-24.el7_3.2.x86_64 如果不知道要安装什么软件包，可以使用yum list|grep snmp SNMP配置文件路径： [root@tang ~]# ll /etc/snmp/ total 8 -rw-r--r-- 1 root root 28 Apr 18 21:45 snmpd.conf -rw------- 1 root root 220 Apr 13 02:34 snmptrapd.conf 修改配置文件，备份修改： [root@tang snmp]# mv snmpd.conf snmpd.conf.org [root@tang snmp]# cat snmpd.conf.org rocommunity tang 172.18.0.1 第二个为团体名，IP是要监控的服务端 我们被发采集的服务器需要开启snmp被采集的服务器要允许snmp访问 开启服务 [root@tang snmp]# systemctl start snmpd [root@tang snmp]# netstat -lntup #snmp默认监听的是udp161端口 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:9133 0.0.0.0:* LISTEN 2478/bubi tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 771/sshd tcp 0 0 127.0.0.1:5432 0.0.0.0:* LISTEN 1594/postmaster tcp 0 0 0.0.0.0:19333 0.0.0.0:* LISTEN 2478/bubi tcp 0 0 127.0.0.1:199 0.0.0.0:* LISTEN 19346/snmpd tcp6 0 0 :::3306 :::* LISTEN 2383/mysqld udp 0 0 172.18.0.1:123 0.0.0.0:* 760/ntpd udp 0 0 172.17.82.185:123 0.0.0.0:* 760/ntpd udp 0 0 127.0.0.1:123 0.0.0.0:* 760/ntpd udp 0 0 0.0.0.0:123 0.0.0.0:* 760/ntpd udp 0 0 0.0.0.0:161 0.0.0.0:* 19346/snmpd udp6 0 0 :::123 :::* 760/ntpd SNMP相关知识 snmp原理图 什么是MIB？ MIB是描述被管理设备商的参数的数据结构。如前所述管理一个设备，就是利用snmp协议，通过网络对被管理的设备上的参数进行get和get操作。 那么如何组织被管理设备上的参数呢？多数情况下，可以get和set的参数实在多得惊人，假如仅仅简单地线性罗列它们，操作会十分不便。 想象一下把1000个参数列成一张表，需要使用的时候查询这样一张表会有多么困难啊？比如您打算在地球上找一个城市，”Ithaca”，如果没有归类和分级，则需要查找一张巨大的表格。 但如果告诉您城市”Ithaca”是：南美洲国家圭亚那的北部城市”Ithaca”，那么就容易些了吧？ 被管理的设备相当复杂，拥有很多可以被管理的参数，需要对它们进行归类，分级。 管理信息库(MIB)是一个具有分层特性的信息的集合，我们可以通过 SNMP 去存取它。 MIB 的成员是一些被管理的对象(ManagedObject)，以对象标示符(ObjectIdentifiers)来区分它们。被管理的对象由一个或多个对象实例(ObjectInstances)组成，本质上，这些对象实例就是变量。 在 MIB 的层次结构中，一个对象标示符唯一标识了被管理对象。MIB的层次结构可以被描述成无根名的树，树的级别被不同的组织所划分。如下图所示： 相应的数字表示（对象标识符OID，唯一标识一个MIB对象） 很多能够被 SNMP 管理的对象都是由标准组织定义好的。比如系统磁盘的信息，用 OID ”1.3.6.1.4.1.2021.9” 表示。这串数字是国际标准化组织协商定义好的，大家都要去遵循它。 当然，国际组织不可能预知未来，如果您要开发的设备有一些管理需求没有任何 RFC 定义过，那么您也可以编写自己的 MIB 文件来定义私有的 MIB 对象。 NET-SNMP 是一种开放源代码的 SNMP 协议实现。它支持 SNMP v1, SNMP v2c 与 SNMP v3，并可以使用 IPV4 及 IPV6 。也包含 SNMP Trap 的所有相关实现。 Net-snmp 包含了 snmp 实用程序集和完整的 snmp 开发库。用户使用 net-snmp 提供的工具，可以完成很多关于 SNMP 的操作，具体说来，包括以下一些命令行应用程序：一些应用程序可以用来从支持 SNMP 的设备获得数据。其中 snmpget, snmpgetnext 可以支持独立请求，比如： NET-SNMP 简介 在 Linux 系统中，我们可以选择 net-snmp 来处理绝大多数和 SNMP 相关的工作。NET-SNMP 是一种开放源代码的 SNMP 协议实现。它支持 SNMP v1, SNMP v2c 与 SNMP v3，并可以使用 IPV4 及 IPV6 。也包含 SNMP Trap 的所有相关实现。Net-snmp 包含了 snmp 实用程序集和完整的 snmp 开发库。用户使用 net-snmp 提供的工具，可以完成很多关于 SNMP 的操作，具体说来，包括以下一些命令行应用程序：一些应用程序可以用来从支持 SNMP 的设备获得数据。其中 snmpget, snmpgetnext 可以支持独立请求，比如:12% snmpget -v 1 -c demopublic test.net-snmp.org system.sysUpTime.0 system.sysUpTime.0 = Timeticks: (586731977) 67 days, 21:48:39.77 该命令获得单个独立的 MIB 对象 system.sysUpTime.0 的值。 而 snmpwalk, snmptable, snmpdelta 则用来支持重复请求。 % snmpwalk -v 2c -c demopublic test.net-snmp.org system SNMPv2-MIB::sysDescr.0 = HP-UX net-snmp B.10.20 A 9000/715 SNMPv2-MIB::sysObjectID.0 = OID: enterprises.ucdavis.ucdSnmpAgent.hpux10 SNMPv2-MIB::sysUpTime.0 = Timeticks: (586998396) 67 days, 22:33:03.96 SNMPv2-MIB::sysContact.0 = Wes Hardaker wjhardaker@ucdavis.edu SNMPv2-MIB::sysName.0 = net-snmp 上面的命令返回所有 system 节点以下的 MIB 对象的值。命令 snmpset 对支持 SNMP 的设备配置属性。如下例所示 $ snmpget -v 1 -c demopublic test.net-snmp.org ucdDemoPublicString.0 UCD-DEMO-MIB::ucdDemoPublicString.0 = &quot;hi there!&quot; $ snmpset -v 1 -c demopublic test.net-snmp.org ucdDemoPublicString.0 s &quot;Hello, world!&quot; UCD-DEMO-MIB::ucdDemoPublicString.0 = &quot;Hello, world!&quot; $ snmpget -v 1 -c demopublic test.net-snmp.org ucdDemoPublicString.0 UCD-DEMO-MIB::ucdDemoPublicString.0 = &quot;Hello, world!&quot; 命令snmpdf, snmpnetstat, snmpstatus 可以从支持 SNMP 的设备获取特定的信息。比如下面的命令从目标系统上获得类似 netstat 的信息： % snmpnetstat -v 2c -c public -a testhost Active Internet (tcp) Connections (including servers) Proto Local Address Foreign Address (state) tcp *.echo *.* LISTEN tcp *.discard *.* LISTEN tcp *.daytime *.* LISTEN tcp *.chargen *.* LISTEN tcp *.ftp *.* LISTEN tcp *.telnet *.* LISTEN tcp *.smtp *.* LISTEN Active Internet (udp) Connections Proto Local Address udp *.echo udp *.discard udp *.daytime udp *.chargen udp *.time snmptranslate 命令将 MIB OIDs 的两种表现形式 ( 数字及文字 ) 相互转换。并显示 MIB 的内容与结构，如下所示： % snmptranslate .1.3.6.1.2.1.1.3.0 SNMPv2-MIB::sysUpTime.0 % snmptranslate -On SNMPv2-MIB::sysUpTime.0 .1.3.6.1.2.1.1.3.0 Net-snmp还提供了一个基于 Tk/perl 的，图形化的 MIB 浏览器 tkmib。首先调用函数 snmp_pdu_create 创建一个 SNMPv2 的 Trap PDU。然后调用 snmp_add_var 向该 PDU 中添加图三所示的三个部分。sysUpTime 在 SNMPv2-MIB中定义，其OID为”1.3.6.1.2.1.1.3.0”。我们只需要通过 get_uptime() 函数获得该值，然后调用snmp_add_var将该变量加入刚才创建的 PDU中。 SNMP例子：查看系统第一分钟的负载 [root@tang snmp]# snmpget -v2c -c tang 172.17.82.185 1.3.6.1.4.1.2021.10.1.3.1 -c是团体名，在配置文件中定义的，还有ip地址 UCD-SNMP-MIB::laLoad.1 = STRING: 0.00 [root@tang snmp]# cat /etc/snmp/snmpd.conf rocommunity tang 172.17.82.185 提示：我们cpu所有指标都有一个oid 后面我们定义的数字就是oid例如cacti就是通过snmp来获取性能指标，在使用RRDTool来进行画图 SNMP 2种常用模式 1.GerRequest PDU2.GetNextRequest PDU [root@localhost snmp]# snmpwalk -v2c -c tang 172.17.82.185 1.3.6.1.4.1.2021.10.1.3 UCD-SNMP-MIB::laLoad.1 = STRING: 0.00 UCD-SNMP-MIB::laLoad.2 = STRING: 0.01 UCD-SNMP-MIB::laLoad.3 = STRING: 0.05 [root@localhost snmp]# uptime 13:16:08 up 6:35, 2 users, load average: 0.00, 0.01, 0.05 linux下常用Oidhttp://linux.chinaunix.net/techdoc/net/2008/08/21/1026818.shtmlhttp://www.2cto.com/os/201211/170730.html提示：只需要在IP地址后面输入相对应的oid即可 系统监控 CPU内存IO Input/Output(网络、磁盘) 企业面试题：如果系统负载达到200了，SSH连接不上，如何让SSH连接上 解答：改变SSH的优先级 CPU监控cpu三个重要概念： 1.上下文切换：CPU调度器实施的进程的切换过程，上下文切换 2.运行队列（负载）：运行队列，排队可以参考 我是一个进程文章（http://blog.csdn.net/nylx/article/details/51058389） 3.使用率 监控CPU需要确定服务类型： 1.IO密集型（数据库） 2.CPU密集型（web/mail） 确定性能的基准线： 1.运行队列：1-3个线程 基准：1CPU 4核 负载不超过12 2.CPU使用：65%-70%用户态利用率 30%-35%内核态利用率 0%-5%空闲 3.上下文切换：越少越好 所有的监控都要根据业务来考虑 常见CPU监控工具top sysstat mpstat top说明 第一行 分别显示：系统当前时间 系统运行时间 当前用户登陆数 系统负载。 系统负载（loadaverage），这里有三个数值，分别是系统最近1分钟，5分钟，15分钟的平均负载。 一般对于单个处理器来说，负载在0—1.00之间是正常的，超过1.00就要引起注意了。在多核处理器中，你的系统均值不应该高于处理器核心的总数。 第二行 分别显示：total进程总数、 running正在运行的进程数、 sleeping睡眠的进程数、stopped停止的进程数、 zombie僵尸进程数。 第三行 分别显示： %us用户空间占用CPU百分比、 %sy内核空间占用CPU百分比、 %ni用户进程空间内改变过优先级的进程占用CPU百分比、 %id空闲CPU百分比、 %wa等待输入输出（I/O）的CPU时间百分比 、 %hi指的是cpu处理硬件中断的时间、%si指的是cpu处理软中断的时间 、 %st用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间。 通常id%值可以反映一个系统cpu的闲忙程度。 第四行 MEM ：total 物理内存总量、 used 使用的物理内存总量、free 空闲内存总量、 buffers 用作内核缓存的内存量。 第五行 SWAP：total 交换区总量、 used使用的交换区总量、free 空闲交换区总量、 cached缓冲的交换区总量。buffers和cached的区别需要说明一下，buffers指的是块设备的读写缓冲区，cached指的是文件系统本身的页面缓存。它们都是linux操作系统底层的机制，目的就是为了加速对磁盘的访问 第六行 PID(进程号)、 USER（运行用户）、PR（优先级）、NI（任务nice值）、VIRT（虚拟内存用量）VIRT=SWAP+RES 、RES（物理内存用量）、SHR（共享内存用量）、S（进程状态）、%CPU（CPU占用比）、%MEM（物理内存占用比）、TIME+（累计CPU占 用时间)、 COMMAND 命令名/命令行。 top命令的使用方法：top [-] [d] [q] [c] [C] [S] [n]运维必会！参数说明d指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。p通过指定监控进程ID来仅仅监控某个进程的状态。q该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。S指定累计模式。s使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。i使top不显示任何闲置或者僵死进程。c显示整个命令行而不只是显示命令名。 下面介绍在top命令执行过程中可以使用的一些交互命令 从使用角度来看，熟练的掌握这些命令比掌握选项还重要一些。 这些命令都是单字母的，如果在命令行选项中使用了s选项，则可能其中一些命令会被屏蔽掉。Ctrl+L 擦除并且重写屏幕。h或者? 显示帮助画面，给出一些简短的命令总结说明。k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。i 忽略闲置和僵死进程。这是一个开关式命令。q 退出程序。r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。f或者F 从当前显示中添加或者删除项目。o或者O 改变显示项目的顺序。l 切换显示平均负载和启动时间信息。m 切换显示内存信息。t 切换显示进程和CPU状态信息。c 切换显示命令名称和完整命令行。M 根据驻留内存大小进行排序。P 根据CPU使用百分比大小进行排序。T 根据时间/累计时间进行排序。W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。Shift+M 可按内存占用情况进行排序。 sysstat 说明[root@tang ~]# yum install sysstat -y [root@tang ~]# vmstat --help usage: vmstat [-V] [-n] [delay [count]] -V prints version. -n causes the headers not to be reprinted regularly. -a print inactive/active page stats. -d prints disk statistics -D prints disk table -p prints disk partition statistics -s prints vm table -m prints slabinfo -t add timestamp to output -S unit size delay is the delay between updates in seconds. unit size k:1000 K:1024 m:1000000 M:1048576 (default is K) count is the number of updates. 例子：每隔1秒获取1次，次数不限 [root@tang snmp]# vmstat 1 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 926348 124344 624748 0 0 2 6 124 150 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1252 2559 0 1 99 0 0 0 0 0 926332 124344 624748 0 0 0 0 1260 2562 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1256 2569 1 0 99 0 0 r表示CPU排队的情况，b代表 进程堵塞，等待io 每隔1秒获取1次，次数10次 [root@tang snmp]# vmstat 1 10 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 926332 124344 624748 0 0 2 6 125 150 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1260 2574 1 0 99 0 0 0 0 0 926332 124344 624748 0 0 0 0 1253 2558 0 1 99 0 0 0 0 0 926332 124344 624748 0 0 0 0 1279 2589 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1272 2577 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1272 2575 1 0 99 0 0 0 0 0 926332 124344 624748 0 0 0 0 1267 2574 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1269 2571 0 1 99 0 0 0 0 0 926332 124344 624748 0 0 0 0 1289 2597 1 1 98 0 0 0 0 0 926332 124344 624748 0 0 0 0 1279 2600 0 1 99 0 0 mpstat说明查看所有CPU的平均值 [root@tang snmp]# mpstat 1 Linux 3.10.0-514.10.2.el7.x86_64 (tang) 04/23/2017 _x86_64_ (1 CPU) 04:45:51 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 04:45:52 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:45:53 PM all 1.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 98.99 04:45:54 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:45:55 PM all 0.00 0.00 1.02 0.00 0.00 0.00 0.00 0.00 0.00 98.98 [root@tang snmp]# mpstat 1 10 Linux 3.10.0-514.10.2.el7.x86_64 (tang) 04/23/2017 _x86_64_ (1 CPU) 04:46:20 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 04:46:21 PM all 1.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 98.98 04:46:22 PM all 0.00 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 98.99 04:46:23 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:46:24 PM all 1.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 98.00 04:46:25 PM all 2.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:46:26 PM all 1.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 98.00 04:46:27 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:46:28 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 04:46:29 PM all 1.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 98.00 04:46:30 PM all 1.01 0.00 1.01 0.00 0.00 0.00 0.00 0.00 0.00 97.98 Average: all 1.01 0.00 0.81 0.00 0.00 0.00 0.00 0.00 0.00 98.19 上述是CPU监控，CPU监控主要靠经验。因为业务不同指标不同，指标越低越好是不变的道理 内存监控硬盘格式化后分成块（blog）内存默认是页（大小4kb）读取按照页来进行读取内存： free vmstat [root@www ~]# free -m total used free shared buffers cached Mem: 1875 1338 537 0 173 523 -/+ buffers/cache: 640 1234 Swap: 0 0 0 提示：云主机是没有Swap分区的total 总内存used 已使用内存free 空闲内存shared 共享内存（进程间相互通信使用共享内存）buffers 缓冲cached缓存Centos7 会有一个available，活动内存 云服务器一般不分配swap分区，物理机能不使用交换分区就不使用交换分区 vmstat命令[root@www ~]# vmstat 1 procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 550628 177684 536324 0 0 1 6 7 46 1 0 98 0 0 0 0 0 550620 177684 536324 0 0 0 40 187 429 0 0 100 0 0 0 0 0 550620 177684 536324 0 0 0 0 183 427 1 0 99 0 0 0 0 0 550620 177684 536324 0 0 0 0 197 436 0 1 99 0 0 swpd交换分区的大小free可用的物理内存大小buff 缓冲区的大小cache 缓存区的大小si 数据从交换分区读取到内存的大小so 数据从内存到交换分区bi 从交换分区读到内存（block）bo内存写到硬盘的 内存达到多少报警呢？ 80%正常是一个进程启动后会一直往上升，最后到达一个平稳期 硬盘监控硬盘：IOPS IO’s Per Second iotop df -h iostat 顺序IO（快） 随机IO（慢） 查看磁盘剩余空间 [root@tang ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/xvda1 40G 4.1G 34G 11% / tmpfs 938M 0 938M 0% /dev/shm ``` 监控磁盘IO iotop [root@www ~]# yum install iotop -y iotop 可以使用dd命令生成一个文件夹进行测试生成命令如下： [root@www ~]# dd if=/dev/zero of=/tmp/1.txt bs=1M count=1000 1000+0 records in 1000+0 records out 1048576000 bytes (1.0 GB) copied, 20.509 s, 51.1 MB/s [root@www ~]# ls -lh /tmp/1.txt -rw-r--r-- 1 root root 1000M Aug 30 19:48 /tmp/1.txt 此时IO写入如下图 iostat命令，可以看到那块磁盘，比iotop更加细致 [root@tang ~]# iostat 1 2 Linux 2.6.32-431.23.3.el6.x86_64 (www) 08/30/2016 _x86_64_ (1 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 1.10 0.00 0.27 0.16 0.00 98.46 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtn xvda 1.51 2.26 17.09 986748 7467560 avg-cpu: %user %nice %system %iowait %steal %idle 1.02 0.00 0.00 0.00 0.00 98.98 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtn xvda 0.00 0.00 0.00 0 tps 设备每秒的传输次数（每秒多少的io请求）Blk_read/s 每秒从设备读取的数据量Blk_wrtn/s 每秒像设备写入的数据量Blk_read写入数据的总数Blk_wrtn 读取数据的总数 网络监控iftop说明[root@www ~]# yum install iftop -y [root@www ~]# iftop -n #-n不做域名解析 正常监控只需要监控网卡带宽即可其中网络监控是最复杂的，ping监控网络延迟网络丢包等。但是此类的网络监控只是监控自己到客户端是否丢包，并不能保证客户端到服务器这边不丢包 其中就产生了如：阿里测、奇云测、站长工具等一系列多节点的监控工具 性能测试常用工具：IBM nmon （nmon analyser---生成AIX性能报告的免费工具）http://nmon.sourceforge.net/pmwiki.php #下载地址（需要翻墙工具）所以我们提供了百度云下载链接：http://pan.baidu.com/s/1boXV6R9 密码：sblf只需要下载对应的版本，给执行权限。执行即可 [root@tang tmp]# chmod +x nmon16e_x86_rhel72 [root@tang tmp]# ./nmon16e_x86_rhel72 我们可以直接输入一个c 一个m一个d。这个是实时的一个状态 我们可以查看帮助 [root@localhost tmp]# ./nmon16e_x86_rhel72 --help ./nmon16e_x86_rhel72: invalid option -- &apos;-&apos; Hint for nmon16e_x86_rhel72 version 16e Full Help Info : nmon16e_x86_rhel72 -h On-screen Stats: nmon16e_x86_rhel72 Data Collection: nmon16e_x86_rhel72 -f [-s &lt;seconds&gt;] [-c &lt;count&gt;] [-t|-T] Capacity Plan : nmon16e_x86_rhel72 -x Interactive-Mode: Read the Welcome screen &amp; at any time type: &quot;h&quot; for more help Type &quot;q&quot; to exit nmon For Data-Collect-Mode -f Must be the first option on the line (switches off interactive mode) Saves data to a CSV Spreadsheet format .nmon file in then local directory Note: -f sets a defaults -s300 -c288 which you can then modify Further Data Collection Options: -s &lt;seconds&gt; time between data snapshots -c &lt;count&gt; of snapshots before exiting -t Includes Top Processes stats (-T also collects command arguments) -x Capacity Planning=15 min snapshots for 1 day. (nmon -ft -s 900 -c 96) ---- End of Hints -c 采集的次数-s 采集的间隔时间-f 生成一个文件-m 指定生成文件位置采集10次 间隔10秒 [root@localhost tmp]# ./nmon16e_x86_rhel72 -c 10 -s 10 -f -m /tmp/ [root@localhost tmp]# ls localhost_160831_0435.nmon nmon16e_x86_rhel72 前面为主机名后面是日期（年月日时分）因为测试可能需要，我们要制作成表格，所以现在将文件上传到桌面上 [root@localhost tmp]# sz localhost_160831_0435.nmon 我们打开下载的工具 解压文件夹，打开nmon analyser v34a.xls 点击Analyse nmon data找到我们刚刚复制出来的文件，就可以看到了。 应用服务监控举例：Nginx安装nginx [root@localhost ~]# yum install -y gcc glibc gcc-c++ prce-devel openssl-devel 提示：nginx可以使用稳定版的最新版，因为安全性会不断的提高。如果是特别老的版本会有一些漏洞和功能 要想监控nginx需要在编译时添加如下参数 --with-http_stub_status_module 下载Nginx [root@localhost src]# wget http://nginx.org/download/nginx-1.10.1.tar.gz 解压，后面步骤太简单不说了安装 [root@localhost nginx-1.10.1]# useradd -s /sbin/nologin www [root@localhost nginx-1.10.1]# ./configure --prefix=/usr/local/nginx-1.10.1 --user=www --group=www --with-http_ssl_module --with-http_stub_status_module configure 是一个shell脚本，执行它的作用是生成MAKEFILE（编译make需要） [root@localhost nginx-1.10.1]# make &amp;&amp; make install [root@localhost nginx-1.10.1]# ll total 676 drwxr-xr-x 6 1001 1001 4096 Aug 31 06:02 auto -rw-r--r-- 1 1001 1001 262898 May 31 09:47 CHANGES -rw-r--r-- 1 1001 1001 400701 May 31 09:47 CHANGES.ru drwxr-xr-x 2 1001 1001 4096 Aug 31 06:02 conf -rwxr-xr-x 1 1001 1001 2481 May 31 09:47 configure drwxr-xr-x 4 1001 1001 68 Aug 31 06:02 contrib drwxr-xr-x 2 1001 1001 38 Aug 31 06:02 html -rw-r--r-- 1 1001 1001 1397 May 31 09:47 LICENSE -rw-r--r-- 1 root root 404 Aug 31 07:46 Makefile drwxr-xr-x 2 1001 1001 20 Aug 31 06:02 man drwxr-xr-x 3 root root 119 Aug 31 07:46 objs -rw-r--r-- 1 1001 1001 49 May 31 09:47 README drwxr-xr-x 9 1001 1001 84 Aug 31 06:02 src make是生成文件，make install是将生成的文件拷贝到不同的地方make install 完成之后可以直接将当前目录拷贝到其他服务器上，安装相同的依赖就可以进行使用。 [root@localhost nginx-1.10.1]# ln -s /usr/local/nginx-1.10.1/ /usr/local/nginx [root@localhost nginx-1.10.1]# netstat -lntp|grep nginx tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 7058/nginx: master 修改nginx.conf配置文件 location /status { stub_status on; access_log off; allow 192.168.56.0/24; deny all; } 设置只允许56网段访问，并开启日志和状态模块这个比较基础，如果不知道怎么添加。可以参考www.nginx.org 状态模块浏览器访问：http://192.168.56.11/status Active connections: 1 server accepts handled requests 3 3 163 Reading: 0 Writing: 1 Waiting: 0 Active connections: 当前活跃的连接数 3—-&gt; 一共处理了多少个链接（请求）3—-&gt; 成功创建多少次握手163–&gt; 总共创建了多少个请求Reading:当前读取客户端heardr的数量Writing:当前返回给客户端heardr的数量 #如果这个指标飙升，说明是后面的节点挂掉了，例如数据库等。Waiting:大体意思是已经处理完，等待下次请求的数量提示：我们只需要关注活动链接即可 监控最基础的功能采集 存储 展示 告警 几款监控软件说明： Nagios+CactiNagios报警功能比较强，但是画图比较弱（有插件） Cacti 画图比较强，报警比较弱（有插件）Zabbix可以直接监控IPMI、SNMP、JVM 这些监控项目别的软件本身干不了，插件除外 Zabbix分为Server—-&gt;Agent 有主动和被动模式Gangla 根本没听说过！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五分钟商学院--大纲]]></title>
      <url>%2F2016%2F09%2F25%2F%E4%BA%94%E5%88%86%E9%92%9F%E5%95%86%E5%AD%A6%E9%99%A2--%E5%A4%A7%E7%BA%B2%2F</url>
      <content type="text"><![CDATA[商业四大体系合体。 1）商业，你与企业外部的关系；2）管理，你与企业内部的关系；3）个人，你与自己的关系；4）以及提升前三者的：工具。 商业篇消费心理学1.心理账户2.沉没成本3.比例偏见4.损失规避5.价格锚点 商业世界五大基础逻辑6.流量之河7.倍率之刀8.价量之秤9.风险之眼10.规则之缝 互联网世界五大基本定律11.信息对称12.平台经济13.边际成本14.长尾理论15.免费理论 行为经济学16.结果偏见17.适应性偏见18.鸡蛋理论19.概率偏见20.凡勃伦效应 微观经济学21.供需理论22.边际效用23.机会成本24.代理两难25.科斯定理 宏观经济学26.节约悖论27.张维迎林毅夫之争28.人口抚养比29.经济泡沫30.福利经济 金融法律31.风险投资32.公司的形态：有限责任，合伙企业，个人独资33.期权（员工激励方案）34.庞氏骗局35.互联网金融 市场营销 Product36.产品定位37.自我认知38.极致单品39.三驾马车40.最小可用品 市场营销 Price41.渗透定价法42.组合定价法43.撇脂定价法44.价格歧视45.客户自定价 市场营销 Promotion46.定位营销47.饥饿营销48.死亡之井49.危机公关50.独特的销售主张-USP 市场营销 Place51.深度分销52.直接销售53.虚实结合54.社区商务55.反向定制 市场营销 互联网营销56.社群经济57.口碑经济（POE理论）58.粉丝经济59.引爆点60.红利理论 所有现象背后都有商业逻辑61.运动对赌62.雇佣客户63.服务行业美女越多，经济越不景气64.狩猎式 vs 农耕式65.稳定平衡态 vs 不稳定平衡态 管理篇管理选人66.上下车法则67.奥格尔维定律68.首因效应/光环效应69.特雷默定律70.重视面试被拒的人 管理育人71.蘑菇定律72.师傅制73.情境领导II74.鲶鱼效应75.贝尼斯定理 管理用人76.不值得定律77.懒蚂蚁效应78.热炉法则79.拜伦法则80.波特定律 管理留人81.酒与污水定律82.格雷欣法则（劣币驱逐良币）83.雷尼尔效应84.南风法则85.离职面试 管理就是激励需求理论86.马斯洛人类需求五层次理论-生理87.马斯洛人类需求五层次理论-安全88.马斯洛人类需求五层次理论-归属89.马斯洛人类需求五层次理论-尊重90.马斯洛人类需求五层次理论-实现 管理就是激励其他理论91.卡诺满意度模型92.赫兹伯格的双因素激励理论93.亚佛斯德原则（期望理论）94.马蝇效应95.波什定律 从员工到经理96.古狄逊定理97.吉格勒定理98.刺猬法则99.目标置换效应100.篮球架子原理 管理1101.崔西定律102.蓝柏格定理103.阿什定律104.彼得斯定律105.超限效应 管理2106.奥卡姆剃刀定律107.法约尔原则（责权利心法）108.例外原则109.洛克忠告110.海恩法则 管理3111.波特法则112.卡贝定律113.飞轮效应114.墨菲定律115.克里夫兰法则 团队合作116.球队，交响乐队，军队117.木桶定律118.多样性（异性效应）119.苛希纳定律120.蚁群效应 项目管理121.作战指挥室122.关键路径123.范围、时间、资源的金三角124.风险管理（已知的未知风险）125.权利来源：专业 管理常见病126.破窗效应127.旁观者效应128.帕金森定律129.彼得原理130.手表定律 个人篇高效能人士的七种习惯131.范式转变132.情感账户133.积极主动134.以终为始135.要事第一 高效能人士的七种习惯136.双赢思维137.知彼解己138.统合综效139.不断更新140.找到心声 时间管理141.时间成本142.GTD143.猴子理论144.三八理论145.番茄钟 职业素养146.如何打招呼147.如何吃西餐148.如何和老板一起坐车149.如何搭配衣服150.邮件礼仪 学习能力151.幸存者偏见152.库博经验学习圈153.知识、技能、态度154.学习小组（私人董事会）155.如何最快速的学习 思考能力156.六顶思考帽157.批判性思维/辩证思维158.系统思维-关联的、整体的、动态的159.正向思维160.逆向思维 逻辑思维161.偷换概念-同一律162.自相矛盾-矛盾律163.模棱两可-排中律164.三段论165.归纳法与黑天鹅事件 谈判能力166.吉普赛陷阱167.定位调整偏见168.有限的权利 &amp; 不露面的人169.战略延迟 &amp; 最终期限170.吃惊 &amp; 撤退 情感能力171.元能力：同理心172.元能力：自我认知（卢维斯定理）173.元能力：自我控制174.元能力：自我激励175.元能力：人际关系处理 演讲能力176.导游心法177.注意力法则178.空中加油179.案例和幽默感180.打透 沟通能力181.快乐痛苦四原则182.亨利法则183.踢猫效应184.电梯测验185.如何问出好问题 创新能力186.创新者的窘境187.人无我有，人有我优，人优我廉……188.达维多定律189.路径依赖190.比伦定律 领导能力191.远（后喻文明）192.小（科斯定理）193.变（企业生命周期）194.快（快鱼吃慢鱼）195.专（网状激活系统） 战略篇战略工具196.麦肯锡·MECE法197.波特·五力模型198.波士顿矩阵199.金字塔原理200.通用电器矩阵 战略工具201.正态分布理论202.逻辑树/决策树203.平衡计分表204.SWOT模型205.麦肯锡·七步成诗法 博弈工具206.纳什均衡207.囚徒困境208.贝叶斯均衡209.智猪博弈210.公地悲剧 博弈工具211.你分我拿212.拍卖逻辑213.零和游戏原理214.拍卖美元215.用餐者困境 决策工具216.儒佛尔定律217.吉德林法则218.布利丹效应219.羊群效应220.麦穗哲理 创新工具221.减法创新222.除法创新223.乘法创新224.任务统筹策略225.属性依存策略 管理工具226.OKR227.MBTI人格理论（自我管理）228.SMART原则（目标管理）229.PDCA循环规则（项目管理）230.5W2H法（目标管理） 思考工具231.头脑风暴法232.思考工具：白板233.思维导图234.5WHY分析法235.复盘 沟通工具236.有效的1：1237.罗伯特议事规则238.白板墙、低隔板、下午茶和即时贴239.拉波波特评论规则240.结构沟通法 财务工具241.财务分析中的五力分析法242.零基预算？243.本福特定律244.独立P&amp;L245.计算企业价值 营销工具246.直播营销247.Focus Group248.STP249.4C250.4P 未来已来256.零边际成本社会257.奇点临近258.比特币259.基因科技260.人工智能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL问题系列- MySQL连接数被限制为214个]]></title>
      <url>%2F2016%2F09%2F04%2FMySQL%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97-%20MySQL%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%A2%AB%E9%99%90%E5%88%B6%E4%B8%BA214%E4%B8%AA%2F</url>
      <content type="text"><![CDATA[问题项目中，由于连接数过多，提示“Too many connections”，需要增加连接数。我在 /etc/my.cnf中修改了 1max_connections = 2000 但是， 实际连接数一直被限制在 2141234567mysql&gt; show variables like &quot;max_connections&quot;;+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 214 |+-----------------+-------+1 row in set MySQL max_connections 总是 214 。不能设大了？ 环境CentOS 7.1MySQL 5.6.25 思考如果我设置连接小于214时，比如 200，那么实际连接数就是 200，也就是说，我的配置文件是没有问题的。 查 MySQL 官方文档，里面说了123The maximum number of connections MySQL can support depends on the quality of the thread library on a given platform, the amount of RAM available, how much RAM is used for each connection, the workload from each connection, and the desired response time. Linux or Solaris should be able to support at 500 to 1000 simultaneous connections routinely and as many as 10,000 connections if you have many gigabytes of RAM available and the workload from each is low or the response time target undemanding. Windows is limited to (open tables × 2 + open connections) &lt; 2048 due to the Posix compatibility layer used on that platform.Increasing open-files-limit may be necessary. Also see Section 2.5, “Installing MySQL on Linux”, for how to raise the operating system limit on how many handles can be used by MySQL. 大概意思是 MySQL 能够支持的最大连接数量受限于操作系统,必要时可以增大 open-files-limit。换言之，连接数与文件打开数有关。 解决执行12[root@emsc ~]# ulimit -n1024 可知，操作系统最大文件描述符限制为 1024， 在 配置文件中添加12[root@emsc ~]# vim /etc/security/limits.confopen_files_limit = 65535 实际上也没有生效 更改 MySQL 在 Linux 的最大文件描述符限制，编辑 /usr/lib/systemd/system/mysqld.service 文件，在文件最后添加:123[root@emsc ~]# vim /usr/lib/systemd/system/mysqld.serviceLimitNOFILE=65535LimitNPROC=65535 保存后，执行下面命令，使配置生效12$ systemctl daemon-reload$ systemctl restart mysqld.service 实际连接数到 2000 了，解决1234567mysql&gt; show variables like &quot;max_connections&quot;;+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 2000 |+-----------------+-------+1 row in set]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[postgresql（2）--安装方式]]></title>
      <url>%2F2016%2F07%2F21%2Fpostgresql%EF%BC%882%EF%BC%89--%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[RPM安装方式rpm安装包12345678910111213postgresql94-9.4.8-1PGDG.rhel6.x86_64.rpmpostgresql94-contrib-9.4.8-1PGDG.rhel6.x86_64.rpmpostgresql94-devel-9.4.8-1PGDG.rhel6.x86_64.rpmpostgresql94-libs-9.4.8-1PGDG.rhel6.x86_64.rpmpostgresql94-server-9.4.8-1PGDG.rhel6.x86_64.rpmcat psql_install.sh #安装脚本rpm -ivh libxslt1-1.1.28-66.1.x86_64.rpm #依赖包rpm -ivh --force postgresql94-*service postgresql-9.4 initdb #初始化sed -i &quot;s/peer/trust/g&quot; /var/lib/pgsql/9.4/data/pg_hba.conf #允许远程连接sed -i &quot;s/ident/trust/g&quot; /var/lib/pgsql/9.4/data/pg_hba.confservice postgresql-9.4 start 源码安装方式123456789101112cd /usr/src/ wget http://ftp.postgresql.org/pub/source/v9.4.8/postgresql-9.4.8.tar.gztar -zxvf postgresql-9.4.8.tar.gzcd postgresql-9.1.4 ./configure make make install mkdir /usr/local/pgsql/data chown postgres /usr/local/pgsql/data su – postgres /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[postgresql（3）--常用命令]]></title>
      <url>%2F2016%2F07%2F21%2Fpostgresql%EF%BC%883%EF%BC%89--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647创建数据库CREATE DATABASE test WITH OWNER = postgres ENCODING = &apos;UTF8&apos;;进入控制台方法，在postgreSQL的安装目的bin下执行命令： psql 数据库名， 例： /usr/local/pgsql/bin/psql mydb指定host、用户名和数据库的话，如：/usr/local/pgsql/bin/psql -h localhost -U postgres -d test查看版本： psql --version 或 SELECT version();查看所有数据库：\l查看所有数据库（包括详细参数）：select * from pg_database;选择数据库：\c databasename查看所有表：\dt查看某个表的结构：\d tablename退出psql控制台：\q查看表的索引：select * from pg_indexes where tablename=&apos;log&apos;;导出备份数据库：pg_dump -h localhost -U postgres databasename &gt; /tmp/databasename.bak.yyyymmdd.sql导入恢复数据库(sql文件是pg_dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等)：psql -h localhost -U postgres -d databasename &lt; /tmp/databasename.bak.yyyymmdd.sql导出数据结构，主要是加上参数-s：pg_dump -U username -W dbname -f /tmp/filename.sql导出某个表：pg_dump -h localhost -U postgres -t tablename dbname &gt; test.sql导出某个表的结构，同样是加参数&quot;-s&quot;：pg_dump -h localhost -U postgres -t tablename -s dbname &gt; test_construct.sql导出某个表的数据，加参数&quot;-a&quot;：pg_dump -h localhost -U postgres -t tablename -a dbname &gt; test_data.sql查看序列：select * from information_schema.sequences where sequence_schema = &apos;public&apos;;查看数据库大小：select pg_size_pretty(pg_database_size(&apos;test&apos;));查看表的大小：select pg_size_pretty(pg_relation_size(&apos;test&apos;));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat相关知识整理（1）]]></title>
      <url>%2F2016%2F07%2F20%2FTomcat%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[初识ServletSUN公司制定了一系列Web应用与Web服务器进行协作的标准Java接口，统称为Java Servlet API，还对Web服务器发布及运行Web应用的一些细节做了规约。SUN公司把这一系列标准Java接口和规约统称为Servlet规范。Servlet就是Web服务器与Web应用进行协作的标准接口。 Servlet规范把能够发布和运行JavaWeb应用的Web服务器称为Servlet容器，它的最主要的特征就是动态执行JavaWeb应用中的Servlet实现类中的程序代码。 Servlet是一种运行在服务器上的小插件，其最常见的用途是扩展Web服务器的功能，可作为非常安全的、可移植的、易于使用的CGI替代品。具有以下特点： 提供了可被服务器动态加载并执行的程序代码，为来自客户端的请求提供相应的服务； Servlet完全用Java语言编写，因此要求运行Servlet的服务器必须支持Java语言； Servlet完全在服务器端运行，因此它的运行不依赖于浏览器。不管浏览器是否支持Java语言，都能请求访问服务器端的Servlet。 TomcatTomcat作为运行Servlet的容器，其基本功能是负责接收和解析来自客户端的请求，同时把客户端的请求传送给相应的Servlet，并把Servlet的响应结果返回给客户端。 Tomcat组件Tomcat组件分为4类： 1.顶层类元素：包括&lt;Server&gt;元素和&lt;Service&gt;元素，它们位于整个配置文件的顶层； 2.连接器类元素：为&lt;Connector&gt;元素，代表介于客户端与服务器端之间的通信接口，负责将客户端的请求发送给服务器端，并将服务器的响应结果返回给客户端； 3.容器类元素：代表处理客户端请求并生成响应结果的组件，共有四类，分别为&lt;Engine&gt;、&lt;Host&gt;、&lt;Context&gt;和&lt;Cluster&gt;元素。Engine组件为特定的Service组件处理所有客户端请求，Host组件为特定的虚拟主机处理所有的客户端请求，Context组件为特定的Web应用处理所有的客户端请求。 Cluster组件负责为Tomcat集群系统进行会话复制、Context组件的属性的复制，以及集群范围内WAR文件的发布。 4.嵌套类元素：代表可以被嵌入到容器中的组件，如&lt;Valve&gt;元素和&lt;Realm&gt;元素等。 #### Tomcat元素 &lt;Server&gt;元素：代表整个Servlet容器组件，是Tomcat的顶级元素。在&lt;Server&gt;元素中可包含一个或多个&lt;Service&gt;元素； &lt;Service&gt;元素：包含一个&lt;Engine&gt;元素，以及一个或多个&lt;Connector&gt;元素，这些&lt;Connector&gt;元素共享同一个&lt;Engine&gt;元素； &lt;Connector&gt;元素：代表和客户端实际交互的组件，负责接收客户端请求，以及向客户端返回响应结果； &lt;Engine&gt;元素：每个&lt;Service&gt;元素只能包含一个&lt;Engine&gt;元素。&lt;Engine&gt;元素处理在同一个&lt;Service&gt;中所有&lt;Connector&gt;元素接收到的客户端请求； &lt;Host&gt;元素：在一个&lt;Engine&gt;元素中可以包含多个&lt;Host&gt;元素。每个&lt;Host&gt;元素定义了一个虚拟主机，它可以包含一个或多个Web应用； &lt;Context&gt;元素：每个&lt;Context&gt;元素代表了运行在虚拟主机上的单个Web应用。在一个&lt;Host&gt;元素中可以包含多个&lt;Context&gt;元素。 Tomcat的工作模式独立的Servlet容器Tomcat作为独立的web服务器来单独运行，Servlet容器组件作为web服务器中的一部分存在，这是Tomcat的默认工作模式。 在这种模式下，Tomcat是一个独立进行的Java程序。和运行其他Java程序一样，运行Tomcat需要启动一个Java虚拟机进程，由该进程来运行Tomcat。 其他web服务器进程内的Servlet容器在这种模式下，Tomcat分为web服务器插件和Servlet容器插件两部分。web服务器插件在其他web服务器进程的内部地址空间启动一个JVM，Servlet在此JVM中运行。如有客户端发出调用Servlet的请求，web服务器插件获得对此请求的控制并将它转发(JNI通信机制)给Servlet容器组件。 其他web服务器进程外的Servlet容器在这种模式下，Tomcat分为web服务器插件和Servlet容器组件两部分。web服务器插件在其他web服务器的外部地址空间启动一个JVM进程，Servlet容器组件再次JVM中运行。如有客户端发出调用Servlet的请求，web服务器插件获得对此请求的控制并将它转发(IPC通信机制)给Servlet容器组件。 当Tomcat作为独立的Servlet容器来运行时，可看做是能运行Java Servlet的独立web服务器。此外，Tomcat还可作为其他web服务器进程内或进程外的Servlet容器，从而与其他web服务器集成，集成的意义在于：对于不支持运行Java Servlet的其web服务器，可通过集成Tomcat来提供运行Servlet的功能。 Tomcat的目录结构bin：存放启动和关闭Tomcat的脚本文件及所用到的类； conf：存放Tomcat的各种配置文件，其中最重要的配置文件是server.xml； logs：存放Tomcat的日志文件； lib：存放Tomcat服务器及所有Web应用都可以访问的jar文件； webapps：Web应用的默认部署目录； work：Tomcat的工作目录，Tomcat在运行时把生成的一些工作文件放于此目录下。在默认情况下，Tomcat把编译JSP而生成的Servlet类文件放于此目录下； tmp：临时文件目录。 NOTE: Tomcat的lib子目录：存放的jar文件不仅能被Tomcat访问，还能被所有在Tomcat中发布的JavaWeb应用访问； JavaWeb应用的lib子目录：存放的jar文件只能被当前JavaWeb应用访问。 NOTE： Tomcat在加载Web应用时，会把相应的web.xml文件中的数据读入到内存中。 Context元素 主要属性path：指定访问该Web应用的URL入口，什么都不写表示根路径； docBase：指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于的appBase属性的相对路径。如果Web应用采用开放目录结构，则指定Web应用的根路径；如果Web应用是个war文件，则是定war文件的路径； className：指定实现Context组件的Java类的名字，这个类必须实现org.apache.catalina.Context接口； reloadable：如果这个属性设为true，Tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下的class文件的改动，以监视Web应用的WEB-INF/web.xml文件的改动。如果检测到有class文件或web.xml文件被更新，服务器会自动重新加载Web应用。 专有属性cachingAllowed：如果为true，表示允许启用静态资源的缓存，默认值为true； cacheMaxSize：设定静态资源缓存的最大容量，默认为10m； workDir：指定Web应用的工作目录，Tomcat在运行时会把与这个web应用相关的临时文件放在这个目录下； uppackWar：如果设为true，表示将把Web应用的WAR文件展开为开放目录结构后再运行。如果设为false，则直接运行war文件。默认为true。 Host元素主要属性name：指定虚拟主机的名字 className：指定实现虚拟主机的Java类的名字，这个Java类必须实现org.apache.catalina.Host接口； appBase：指定虚拟主机的目录，可以指定绝对目录，也可以指定相对于的相对路径； autoDeploy：如果设定为true，表示当Tomcat服务器处于运行状态时，能够检测appBase下的文件，如果有新的Web应用加进来，则会自动发布这个Web应用； deployOnStart：如果此项设置为true，则表示当Tomcat启动时会自动发布appBase目录下的所有Web应用。如果web应用没有相应的context元素，那么Tomcat会提供一个默认的context组件。默认值为true。 专有属性unpackWARS：如果设置为true，表示将把appBase属性指定的目录下的web应用的war文件先展开为开放的目录结构后再运行，如果设置为false，则直接运行war文件； workDir：指定虚拟主机的工作目录，Tomcat在运行时会把与这个虚拟主机的所有web应用相关的临时文件放在此目录下，默认值为&lt;CATALINA_HOME&gt;/work。如果&lt;Host&gt;元素下的一个&lt;Context&gt;元素也设置了workDIR属性，那么&lt;Context&gt;的workDir属性会覆盖&lt;Host&gt;元素的workDir属性； deployXML：如果设置为false，那么Tomcat不会解析web应用中的用于设置context元素的META-INF/context.xml文件。默认值为true。 JavaWebSUN的Servlet规范对JavaWeb应用的定义：JavaWeb应用由一组Servlet/JSP、HTML文件、相关Java类，以及其他可以绑定的资源构成，它可以在由各种供应商提供的符合Servlet规范的Servlet容器中运行。 JavaWeb应用包含的内容： Srvlet组件：标准Servlet接口的实现类，运行在服务器端，包含了被Servlet容器动态调用的程序代码。 JSP组件：包含Java程序代码的HTML文档，运行在服务器端。当客户端请求JSP文件时，Servlet容器先把它翻译成Servlet类，然后动态调用它的程序代码。 相关的Java类：开发人员自定义的与Web应用相关的Java类。 静态文档：存放在存放在服务器端的文件系统中，如HTML文件、图片文件等。当客户端请求访问这些文件时，Servlet容器先从本地文件系统中读取这些文件的数据，再把它发送到客户端。 web.xml文件：JavaWeb应用的配置文件，采用XML格式。该文件必须位于Web应用的WEB-INF目录下。 Servlet规范规定：JavaWeb应用必须采用固定的目录结构，即每种类型的组件在web应用中都有固定的存放目录。 JavaWeb应用的目录结构，以helloapp为例 /helloapp：此Web应用的根目录，所有的JSP和HTML文件都存放于此目录或用户自定义的子目录下(WEB-INF子目录除外)； /helloapp/WEB-INF：存放此Web应用的配置文件web.xml； /helloapp/WEB-INF/classes：存放各种.class文件，Servlet类的.class文件也存放于此目录下； /helloapp/WEB-INF/lib：存放此Web应用所需的各种jar文件； /helloapp/META-INF：当前Webapp的私有资源目录，通常存放自用的context.xml； /helloapp/classes：此Webapp的私有类； /helloapp/lib：此Webapp的私有类，被打包为jar格式； /helloapp/index.jsp：此Webapp的主页。 NOTE：在WEB-INF目录的classes及lib子目录下都可以存放类文件。在运行时，Servlet容器的类加载器先加载classes目录下的类，再加载lib目录下的jar文件中的类。 Tomcat阀(Valve)Tomcat阀能够对Catalina容器接收到的http请求进行预处理。Tomcat阀可以可以加入到3种Catalina容器中，它们是Engine、Host和Context。 Tomcat阀主要包括以下几种： 客户访问日志阀(Access Log Valve) 远程地址过滤器(Remote Address Filter) 远程主机过滤器(Remote Host Filter) 客户请求记录器(Request Dumper) 客户访问日志阀能够将客户端的请求信息写到日志文件中，这些日志文件可以记录网页的访问次数、访问时间、用户的会话活动和用户的安全验证信息等。客户访问日志阀可以加入到Engine、Host或Context容器。 属性： className：指定阀的实现类，此处为org.apache.catalina.valves.AccessLogValve； directory：设定存放日志文件的绝对或相对于&lt;CATALINA_HOME&gt;的目录，默认为&lt;CATALINA_HOME&gt;/logs； pattern：设定日志的格式和内容； prefix：设定日志文件名前缀，默认为access_log； resolveHosts：如果设为true，表示把远程IP地址解析为主机名；如果设为false，表示直接记录远程IP地址，默认为false； suffix：设定日志文件的扩展名，默认为””； pattern属性的可选值： %a：远程IP地址； %A：本地IP地址； %b：发送的字节数，不包括HTTP头部，符号“-”表示发送字节为零； %B：发送的字节数，不包括HTTP头部； %h：远程主机名； %H：客户端请求所用的协议； %l：远程逻辑用户名(目前总是返回符号“-”)； %m：客户端的请方式； %p：接收到客户端请求的本地服务器端口； %q：客户端请求中的查询字符串(Query String)，即HTTP请求的第一行的URI部分的“?”后面的内容； %r：客户端请求的第一行内容(包括请求方式、请求URI及HTTP协议版本)； %s：服务器响应结果中的HTTP状态代码； %S：用户的额Session ID； %t：时间和日期； %u：通过安全认证的远程用户名，符号“-”表示不存在远程用户名； %U：客户端请求的URL路径； %v：本地服务器名； 远程地址过滤器可以根据远程客户端的IP地址来决定是否接受客户端的请求。在远程地址过滤器中，事先保存了一份被拒绝的IP地址清单和允许访问的IP地址清单。 属性 className：指定阀实现类，此处为org.apache.catalina.valves.AccessLogValve； allow：指定允许访问的客户端IP地址，如果没有设定，则表示只要客户端IP地址不在deny清单中，就允许访问，多个IP地址用逗号隔开； deny：指定不允许访问的IP地址； 远程主机过滤器与远程地址多滤器基本上相同，只是一个是基于ip，一个是基于主机名。 客户请求记录器用于把客户端请求的详细信息记录到日志文件，是一个有效的跟踪工具，尤其是当HTTP请求中的Header或Cookie有错误时，它可以跟踪客户请求的详细信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql 启动慢查询日志]]></title>
      <url>%2F2016%2F04%2F05%2FMysql%20%E5%90%AF%E5%8A%A8%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[查看mysql系统参数12345678910111213141516171819mysql&gt; show variables like &quot;%slow%&quot;;+---------------------------+-------------------------------+| Variable_name | Value |+---------------------------+-------------------------------+| log_slow_admin_statements | OFF || log_slow_slave_statements | OFF || slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | /mysql/data/nagiosdb-slow.log |+---------------------------+-------------------------------+5 rows in set (0.00 sec)slow_query_log： off关闭状态 on开启状态slow_launch_time 默认超过2s为慢查询slow_query_log_file 慢查询日志存放地点这三个参数，在不同的mysql版本中，不太一样，不过都可以通过 show variables like &quot;%slow%&quot; 查看出来 运行如下命令即可运行慢查询日志123456789101112131415161718192021mysql&gt; set global slow_query_log=ON;Query OK, 0 rows affected (0.03 sec)mysql&gt; set global slow_launch_time=5;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &quot;%slow%&quot;;+---------------------------+-------------------------------+| Variable_name | Value |+---------------------------+-------------------------------+| log_slow_admin_statements | OFF || log_slow_slave_statements | OFF || slow_launch_time | 5 || slow_query_log | ON || slow_query_log_file | /mysql/data/nagiosdb-slow.log |+---------------------------+-------------------------------+5 rows in set (0.00 sec)mysql 5.1.6版本起，slow_query_log 和 slow_launch_time 支持写文件或写数据库表两种方式，并且日志的开启，输出方式的修改，都可以在global级别动态修改。只需简单通过set global slow_query_log=ON;即可开启慢查询，而不需要重启数据库！ 可以直接写到配置文件中 my.cnf1234slow_query_log_file=/mysql/log/nagiosdb-slow.logslow_launch_time=5可以完成配置！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql优化系列--总结梳理]]></title>
      <url>%2F2016%2F03%2F12%2FMysql%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97--%E6%80%BB%E7%BB%93%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[对于一个网站来说，在运行很长一段时间后，数据库瓶颈问题会越来越暴露出来。作为运维人员，对数据库做必要的优化十分重要！ 下面总结以往查阅到的以及自己工作中的一些优化操作经验，并根据OSI七层模型从下往上进行优化mysql数据库记录。 物理层面1、cpu:2-16个 2*4双四核，L1L2越大越好 2、内存:越大越好 3、磁盘:SAS或者固态 300G*12磁盘越多IO越高 raid 0&gt;10&gt;5&gt;1 4、网卡:千兆 5、slave的配置最好大于等于master 系统配置如下，配置系统内核参数/etc/sysctl.conf（配置后，使用sysctl -p使之生效） net.ipv4.tcp_fin_timeout = 2 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_keepalive_time =600 net.ipv4.ip_local_port_range = 4000 65000 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.route.gc_timeout = 100 net.ipv4.tcp_syn_retries = 1 net.ipv4.tcp_synack_retries = 1 net.core.somaxconn = 16384 net.core.netdev_max_backlog = 16384 net.ipv4.tcp_max_orphans = 16384 vm.swappiness=0 //尽量不使用swap vm.dirty_backgroud_ratio 5-10 vm.dirty_ratio //上面的值的两倍 将操作系统的脏数据刷到磁 mysql的安装MySQL数据库的线上环境安装，建议采取编译安装的方式，这样性能会有较大的提升。服务器系统则建议CentOS6.7 X86_64，源码包的编译参数会默认以Debug模式生成二进制代码，而Debug模式给MySQL带来的性能损失是比较大的，所以当我们编译准备安装的产品代码时，一定不要忘记使用–without-debug参数禁止Debug模式。如果把–with-mysqld-ldflags和–with-client-ld-flags两个编译参数设置为–all-static的话，可以告诉编译器以静态的方式编译，编译结果将得到最高的性能。使用静态编译和使用动态编译的代码相比，性能差距可能会达到5%至10%之多。在后面我会跟大家分享我们线上MySQL数据库的编译参数，大家可以参考下，然后根据自己的线上环境自行修改内容。 下面是对mysql服务配置文件my.cnf的详解： [client] port = 3306 # 客户端端口号为3306 socket = /data/3306/mysql.sock default-character-set = utf8 # 客户端字符集,(控制character_set_client、character_set_connection、character_set_results) [mysql] no-auto-rehash # 仅仅允许使用键值的updates和deletes [mysqld] # 组包括了mysqld服务启动的参数，它涉及的方面很多，其中有MySQL的目录和文件，通信、网络、信息安全，内存管理、优化、查询缓存区，还有MySQL日志设置等。 user = mysql # mysql_safe脚本使用MySQL运行用户(编译时--user=mysql指定),推荐使用mysql用户。 port = 3306 # MySQL服务运行时的端口号。建议更改默认端口,默认容易遭受攻击。 socket = /data/3306/mysql.sock # socket文件是在Linux/Unix环境下特有的，用户在Linux/Unix环境下客户端连接可以不通过TCP/IP网络而直接使用unix socket连接MySQL。 basedir = /application/mysql # mysql程序所存放路径,常用于存放mysql启动、配置文件、日志等 datadir = /data/3306/data # MySQL数据存放文件(极其重要) character-set-server = utf8 # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码) log-error=/data/3306/mysql.err # mysql错误日志存放路径及名称(启动出现错误一定要看错误日志,百分之百都能通过错误日志排插解决。) pid-file=/data/3306/mysql.pid # MySQL_pid文件记录的是当前mysqld进程的pid，pid亦即ProcessID。 skip-locking # 避免MySQL的外部锁定，减少出错几率，增强稳定性。 skip-name-resolv # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时候。但是需要注意的是，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式了，否则MySQL将无法正常处理连接请求！ skip-networking # 开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果Web服务器是以远程连接的方式访问MySQL数据库服务器的，则不要开启该选项，否则无法正常连接！ open_files_limit = 1024 # MySQLd能打开文件的最大个数,如果出现too mant open files之类的就需要调整该值了。 back_log = 384 # back_log参数是值指出在MySQL暂时停止响应新请求之前，短时间内的多少个请求可以被存在堆栈中。如果系统在短时间内有很多连接，则需要增加该参数的值，该参数值指定到来的TCP/IP连接的监听队列的大小。不同的操作系统在这个队列的大小上有自己的限制。如果试图将back_log设置得高于操作系统的限制将是无效的，其默认值为50.对于Linux系统而言，推荐设置为小于512的整数。 max_connections = 800 # 指定MySQL允许的最大连接进程数。如果在访问博客时经常出现 Too Many Connections的错误提示，则需要增大该参数值。 max_connect_errors = 6000 # 设置每个主机的连接请求异常中断的最大次数，当超过该次数，MySQL服务器将禁止host的连接请求，直到MySQL服务器重启或通过flush hosts命令清空此host的相关信息。 wait_timeout = 120 # 指定一个请求的最大连接时间，对于4GB左右内存的服务器来说，可以将其设置为5~10。 table_cache = 614K # table_cache指示表高速缓冲区的大小。当MySQL访问一个表时，如果在MySQL缓冲区还有空间，那么这个表就被打开并放入表缓冲区，这样做的好处是可以更快速地访问表中的内容。一般来说，可以查看数据库运行峰值时间的状态值Open_tables和Open_tables，用以判断是否需要增加table_cache的值，即如果Open_tables接近table_cache的时候，并且Opened_tables这个值在逐步增加，那就要考虑增加这个值的大小了。 external-locking = FALSE # MySQL选项可以避免外部锁定。True为开启。 max_allowed_packet =16M # 服务器一次能处理最大的查询包的值，也是服务器程序能够处理的最大查询 sort_buffer_size = 1M # 设置查询排序时所能使用的缓冲区大小，系统默认大小为2MB。 # 注意：该参数对应的分配内存是每个连接独占的，如果有100个连接，那么实际分配的总排序缓冲区大小为100 x6=600MB。所以，对于内存在4GB左右的服务器来说，推荐将其设置为6MB~8MB join_buffer_size = 8M # 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。 thread_cache_size = 64 # 设置Thread Cache池中可以缓存的连接线程最大数量，可设置为0~16384，默认为0.这个值表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中;如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建，如果有很多线程，增加这个值可以改善系统性能。通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。我们可以根据物理内存设置规则如下:1GB内存我们配置为8,2GB内存我们配置为16,3GB我们配置为32,4GB或4GB以上我们给此值为64或更大的值。 thread_concurrency = 8 # 该参数取值为服务器逻辑CPU数量x 2，在本例中，服务器有两个物理CPU，而每个物理CPU又支持H.T超线程，所以实际取值为4 x 2 = 8。这也是双四核主流服务器的配置。 query_cache_size = 64M # 指定MySQL查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况;如果Qcache_hits的值非常大，则表明查询缓冲使用得非常频繁。另外如果改值较小反而会影响效率，那么可以考虑不用查询缓冲。对于Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。 query_cache_limit = 2M # 只有小于此设置值的结果才会被缓存 query_cache_min_res_unit = 2k # 设置查询缓存分配内存的最小单位，要适当第设置此参数，可以做到为减少内存快的申请和分配次数，但是设置过大可能导致内存碎片数值上升。默认值为4K，建议设置为1K~16K。 default_table_type = InnoDB # 默认表的类型为InnoDB thread_stack = 256K # 设置MySQL每个线程的堆栈大小，默认值足够大，可满足普通操作。可设置范围为128KB至4GB，默认为192KB #transaction_isolation = Level # 数据库隔离级别 (READ UNCOMMITTED(读取未提交内容) READ COMMITTED(读取提交内容) REPEATABLE READ(可重读) SERIALIZABLE(可串行化)) tmp_table_size = 64M # 设置内存临时表最大值。如果超过该值，则会将临时表写入磁盘，其范围1KB到4GB。 max_heap_table_size = 64M # 独立的内存表所允许的最大容量。 table_cache = 614 # 给经常访问的表分配的内存，物理内存越大，设置就越大。调大这个值，一般情况下可以降低磁盘IO，但相应的会占用更多的内存,这里设置为614。 table_open_cache = 512 # 设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此， table_cache 的大小应与 max_connections 的设置有关。例如，对于 200 个并行运行的连接，应该让表的缓存至少有 200 × N ，这里 N 是应用可以执行的查询的一个联接中表的最大数量。此外，还需要为临时表和文件保留一些额外的文件描述符。 long_query_time = 1 # 慢查询的执行用时上限,默认设置是10s,推荐(1s~2s) log_long_format # 没有使用索引的查询也会被记录。(推荐,根据业务来调整) log-slow-queries = /data/3306/slow.log # 慢查询日志文件路径(如果开启慢查询,建议打开此日志) log-bin = /data/3306/mysql-bin # logbin数据库的操作日志,例如update、delete、create等都会存储到binlog日志,通过logbin可以实现增量恢复 relay-log = /data/3306/relay-bin # relay-log日志记录的是从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件,然后SQL线程会读取relay-log日志的内容并应用到从服务器 relay-log-info-file = /data/3306/relay-log.info # 从服务器用于记录中继日志相关信息的文件,默认名为数据目录中的relay-log.info。 binlog_cache_size = 4M # 在一个事务中binlog为了记录sql状态所持有的cache大小，如果你经常使用大的，多声明的事务，可以增加此值来获取更大的性能，所有从事务来的状态都被缓冲在binlog缓冲中，然后再提交后一次性写入到binlog中，如果事务比此值大，会使用磁盘上的临时文件来替代，此缓冲在每个链接的事务第一次更新状态时被创建。 max_binlog_cache_size = 8M # 最大的二进制Cache日志缓冲尺寸。 max_binlog_size = 1G # 二进制日志文件的最大长度(默认设置1GB)一个二进制文件信息超过了这个最大长度之前,MySQL服务器会自动提供一个新的二进制日志文件接续上。 expire_logs_days = 7 # 超过7天的binlog,mysql程序自动删除(如果数据重要,建议不要开启该选项) key_buffer_size = 256M # 指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器来说，该参数可设置为256MB或384MB。 # 注意：如果该参数值设置得过大反而会使服务器的整体效率降低！ read_buffer_size = 4M # 读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。 read_rnd_buffer_size = 16M # 设置进行随机读的时候所使用的缓冲区。此参数和read_buffer_size所设置的Buffer相反，一个是顺序读的时候使用，一个是随机读的时候使用。但是两者都是针对与线程的设置，每个线程都可以产生两种Buffer中的任何一个。默认值256KB，最大值4GB。 bulk_insert_buffer_size = 8M # 如果经常性的需要使用批量插入的特殊语句来插入数据,可以适当调整参数至16MB~32MB,建议8MB。 myisam_sort_buffer_size = 8M # 设置在REPAIR Table或用Create index创建索引或 Alter table的过程中排序索引所分配的缓冲区大小，可设置范围4Bytes至4GB，默认为8MB lower_case_table_names = 1 # 实现MySQL不区分大小。(发开需求-建议开启) slave-skip-errors = 1032,1062 # 从库可以跳过的错误数字值(mysql错误以数字代码反馈,全的mysql错误代码大全,以后会发布至博客)。 replicate-ignore-db=mysql # 在做主从的情况下,设置不需要同步的库。 server-id = 1 # 表示本机的序列号为1,如果做主从，或者多实例,serverid一定不能相同。 myisam_sort_buffer_size = 128M # 当需要对于执行REPAIR, OPTIMIZE, ALTER 语句重建索引时，MySQL会分配这个缓存，以及LOAD DATA INFILE会加载到一个新表，它会根据最大的配置认真的分配的每个线程。 myisam_max_sort_file_size = 10G # 当重新建索引（REPAIR，ALTER，TABLE，或者LOAD，DATA，TNFILE）时，MySQL被允许使用临时文件的最大值。 myisam_repair_threads = 1 # 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们. myisam_recover # 自动检查和修复没有适当关闭的 MyISAM 表. innodb_additional_mem_pool_size = 4M # 用来设置InnoDB存储的数据目录信息和其他内部数据结构的内存池大小。应用程序里的表越多，你需要在这里面分配越多的内存。对于一个相对稳定的应用，这个参数的大小也是相对稳定的，也没有必要预留非常大的值。如果InnoDB用广了这个池内的内存，InnoDB开始从操作系统分配内存，并且往MySQL错误日志写警告信息。默认为1MB，当发现错误日志中已经有相关的警告信息时，就应该适当的增加该参数的大小。 innodb_buffer_pool_size = 64M # InnoDB使用一个缓冲池来保存索引和原始数据，设置越大，在存取表里面数据时所需要的磁盘I/O越少。强烈建议不要武断地将InnoDB的Buffer Pool值配置为物理内存的50%~80%，应根据具体环境而定。 innodb_data_file_path = ibdata1:128M:autoextend # 设置配置一个可扩展大小的尺寸为128MB的单独文件，名为ibdata1.没有给出文件的位置，所以默认的是在MySQL的数据目录内。 innodb_file_io_threads = 4 # InnoDB中的文件I/O线程。通常设置为4，如果是windows可以设置更大的值以提高磁盘I/O innodb_thread_concurrency = 8 # 你的服务器有几个CPU就设置为几，建议用默认设置，一般设为8。 innodb_flush_log_at_trx_commit = 1 # 设置为0就等于innodb_log_buffer_size队列满后在统一存储，默认为1，也是最安全的设置。 innodb_log_buffer_size = 2M # 默认为1MB，通常设置为8~16MB就足够了。 innodb_log_file_size = 32M # 确定日志文件的大小，更大的设置可以提高性能，但也会增加恢复数据库的时间。 innodb_log_files_in_group = 3 # 为提高性能,MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3。 innodb_max_dirty_pages_pct = 90 # InnoDB主线程刷新缓存池中的数据。 innodb_lock_wait_timeout = 120 # InnoDB事务被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用locak tables 语句注意到锁定设置。默认值是50秒。 innodb_file_per_table = 0 # InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间。0关闭，1开启。 # 独立表空间优点： # 1、每个表都有自己独立的表空间。 # 2 、每个表的数据和索引都会存在自己的表空间中。 # 3、可以实现单表在不同的数据库中移动。 # 4、空间可以回收（除drop table操作处，表空不能自己回收。） [mysqldump] quick max_allowed_packet = 2M # 设定在网络传输中一次消息传输量的最大值。系统默认值为1MB，最大值是1GB，必须设置为1024的倍数。单位为字节。 一些建议： 强烈建议不要武断地将InnoDB的Buffer Pool值配置为物理内存的50%~80%，应根据具体环境而定。 如果key_reads太大，则应该把my.cnf中的key_buffer_size变大，保持key_reads/key_read_re-quests至少在1/100以上，越小越好。 如果qcache_lowmem_prunes很大，就要增加query_cache_size的值。 不过很多时候需要具体情况具体分析，其他参数的变更我们可以等MySQL上线稳定一段时间后在根据status值进行调整。 配置范例: 一份电子商务网站MySQL数据库调整后所运行的配置文件/etc/my.cnf(服务器为DELL R710、16GB内存、RAID10)，大家可以根据实际的MySQL数据库硬件情况进行调整配置文件如下： [client] port = 3306 socket = /data/3306/mysql.sock default-character-set = utf8 [mysqld] user = mysql port = 3306 character-set-server = utf8 socket = /data/3306/mysql.sock basedir = /application/mysql datadir = /data/3306/data log-error=/data/3306/mysql_err.log pid-file=/data/3306/mysql.pid log_slave_updates = 1 log-bin = /data/3306/mysql-bin binlog_format = mixed binlog_cache_size = 4M max_binlog_cache_size = 8M max_binlog_size = 1G expire_logs_days = 90 binlog-ignore - db = mysql binlog-ignore - db = information_schema key_buffer_size = 384M sort_buffer_size = 2M read_buffer_size = 2M read_rnd_buffer_size = 16M join_buffer_size = 2M thread_cache_size = 8 query_cache_size = 32M query_cache_limit = 2M query_cache_min_res_unit = 2k thread_concurrency = 32 table_cache = 614 table_open_cache = 512 open_files_limit = 10240 back_log = 600 max_connections = 5000 max_connect_errors = 6000 external-locking = FALSE max_allowed_packet =16M thread_stack = 192K transaction_isolation = READ-COMMITTED tmp_table_size = 256M max_heap_table_size = 512M bulk_insert_buffer_size = 64M myisam_sort_buffer_size = 64M myisam_max_sort_file_size = 10G myisam_repair_threads = 1 myisam_recover long_query_time = 2 slow_query_log slow_query_log_file = /data/3306/slow.log skip-name-resolv skip-locking skip-networking server-id = 1 innodb_additional_mem_pool_size = 16M innodb_buffer_pool_size = 512M innodb_data_file_path = ibdata1:256M:autoextend innodb_file_io_threads = 4 innodb_thread_concurrency = 8 innodb_flush_log_at_trx_commit = 2 innodb_log_buffer_size = 16M innodb_log_file_size = 128M innodb_log_files_in_group = 3 innodb_max_dirty_pages_pct = 90 innodb_lock_wait_timeout = 120 innodb_file_per_table = 0 [mysqldump] quick max_allowed_packet = 64M [mysql] no – auto - rehash 存储引擎的选择关于存储引擎的选择请看博客：MySQL存储引擎之Myisam和Innodb总结性梳理 线上优化调整 MySQL数据库上线后，可以等其稳定运行一段时间后再根据服务器的status状态进行适当优化，我们可以用如下命令列出MySQL服务器运行的各种状态值。通过命令：show global status; 也可以通过 show status like ‘查询%’; 慢查询有时我们为了定位系统中效率比较低下的Query语法，需要打开慢查询日志，也就是Slow Query log。打开慢查询日志的相关命令如下： mysql&gt;show variables like &apos;%slow%&apos;; +---------------------+-----------------------------------------+ | Variable_name | Value | +---------------------+-----------------------------------------+ | log_slow_queries | ON | | slow_launch_time | 2 | +---------------------+-----------------------------------------+ mysql&gt;show global status like &apos;%slow%&apos;; +---------------------+-------+ | Variable_name | Value | +---------------------+-------+ | Slow_launch_threads | 0 | | Slow_queries | 2128 | +---------------------+-------+ 打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响也会很小。另外，可以用MySQL自带的命令mysqldumpslow进行查询。比如：下面的命令可以查出访问次数最多的20个SQL语句：mysqldumpslow -s c -t 20 host-slow.log 连接数我们如果经常遇见MySQL：ERROR1040：Too many connections的情况，一种情况是访问量确实很高，MySQL服务器扛不住了，这个时候就要考虑增加从服务器分散读压力，从架构层面。另外一种情况是MySQL配置文件中max_connections的值过小。来看一个例子。 mysql&gt; show variables like &apos;max_connections&apos;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 800 | +-----------------+-------+ 这台服务器最大连接数是256，然后查询一下该服务器响应的最大连接数； mysql&gt; show global status like &apos;Max_used_connections&apos;; +----------------------+-------+ | Variable_name | Value | +----------------------+-------+ | Max_used_connections | 245 | +----------------------+-------+ MySQL服务器过去的最大连接数是245，没有达到服务器连接数的上线800，不会出现1040错误。 Max_used_connections /max_connections * 100% = 85%最大连接数占上限连接数的85%左右,如果发现比例在10%以下，则说明MySQL服务器连接数的上限设置得过高了。 key_buffer_sizekey_buffer_size是设置MyISAM表索引缓存空间的大小，此参数对MyISAM表性能影响最大。下面是一台MyISAM为主要存储引擎服务器的配置： mysql&gt; show variables like &apos;key_buffer_size&apos;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | key_buffer_size | 536870912 | +-----------------+-----------+ 从上面可以看出，分配了512MB内存给key_buffer_size。再来看key_buffer_size的使用情况： mysql&gt; show global status like &apos;key_read%&apos;; +-------------------+--------------+ | Variable_name | Value | +-------------------+-------+ | Key_read_requests | 27813678766 | | Key_reads | 6798830| +-------------------+--------------+ 一共有27813678766个索引读取请求，有6798830个请求在内存中没有找到，直接从硬盘读取索引。 key_cache_miss_rate = key_reads / key_read_requests * 100% 比如上面的数据，key_cache_miss_rate为0.0244%，4000%个索引读取请求才有一个直接读硬盘，效果已经很好了，key_cache_miss_rate在0.1%以下都很好，如果key_cache_miss_rate在0.01%以下的话，则说明key_buffer_size分配得过多，可以适当减少。 临时表当执行语句时，关于已经被创建了隐含临时表的数量，我们可以用如下命令查询其具体情况： mysql&gt; show global status like &apos;created_tmp%&apos;; +-------------------------+----------+ | Variable_name | Value | +-------------------------+----------+ | Created_tmp_disk_tables | 21119 | | Created_tmp_files | 6 | | Created_tmp_tables | 17715532 | +-------------------------+----------+ MySQL服务器对临时表的配置： mysql&gt; show variables where Variable_name in (&apos;tmp_table_size&apos;,&apos;max_heap_table_size&apos;); +---------------------+---------+ | Variable_name | Value | +---------------------+---------+ | max_heap_table_size | 2097152 | | tmp_table_size | 2097152 | +---------------------+---------+ 每次创建临时表时，Created_tmp_table都会增加，如果磁盘上创建临时表，Created_tmp_disk_tables也会增加。Created_tmp_files表示MySQL服务创建的临时文件数，比较理想的配置是： Created_tmp_disk_tables / Created_tmp_files *100% &lt;= 25% 比如上面的服务器： Created_tmp_disk_tables / Created_tmp_files *100% =1.20%，这个值就很棒了。 打开表的情况Open_tables表示打开表的数量，Opened_tables表示打开过的表数量，我们可以用如下命令查看其具体情况： mysql&gt; show global status like &apos;open%tables%&apos;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Open_tables | 351 | | Opened_tables | 1455 | 查询下服务器table_open_cache; mysql&gt; show variables like &apos;table_open_cache&apos;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | table_open_cache | 2048 | +------------------+-------+ 如果Opened_tables数量过大，说明配置中table_open_cache的值可能太小。 比较合适的值为： open_tables / opened_tables* 100% &gt; = 85% open_tables / table_open_cache* 100% &lt; = 95% 进程使用情况如果我们在MySQL服务器的配置文件中设置了thread_cache_size，当客户端断开时，服务器处理此客户请求的线程将会缓存起来以响应一下客户而不是销毁(前提是缓存数未达上线)Thread_created表示创建过的线程数，我们可以用如下命令查看： mysql&gt; show global status like &apos;thread%&apos;; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | Threads_cached | 40| | Threads_connected | 1 | | Threads_created | 330 | | Threads_running | 1 | +-------------------+-------+ 查询服务器thread_cache_size配置如下： mysql&gt; show variables like &apos;thread_cache_size&apos;; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | thread_cache_size | 100 | +-------------------+-------+ 如果发现Threads_created的值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗费资源的，可以适当增大配置文件中thread_cache_size的值。 查询缓存(query cache) 它主要涉及两个参数，query_cache_size是设置MySQL的Query Cache大小，query_cache_type是设置使用查询缓存的类型，我们可以用如下命令查看其具体情况： mysql&gt; show global status like &apos;qcache%&apos;; +-------------------------+-----------+ | Variable_name | Value | +-------------------------+-----------+ | Qcache_free_blocks | 22756 | | Qcache_free_memory | 76764704 | | Qcache_hits | 213028692 | | Qcache_inserts | 208894227 | | Qcache_lowmem_prunes | 4010916 | | Qcache_not_cached | 13385031 | | Qcache_queries_in_cache | 43560 | | Qcache_total_blocks | 111212 | +-------------------------+-----------+ MySQL查询缓存变量的相关解释如下： Qcache_free_blocks： 缓存中相领内存快的个数。数目大说明可能有碎片。flush query cache会对缓存中的碎片进行整理，从而得到一个空间块。Qcache_free_memory：缓存中的空闲空间。Qcache_hits：多少次命中。通过这个参数可以查看到Query Cache的基本效果。Qcache_inserts：插入次数，没插入一次查询时就增加1。命中次数除以插入次数就是命中比率。Qcache_lowmem_prunes：多少条Query因为内存不足而被清楚出Query Cache。通过Qcache_lowmem_prunes和Query_free_memory相互结合，能 够更清楚地了解到系统中Query Cache的内存大小是否真的足够，是否非常频繁地出现因为内存不足而有Query被换出的情况。Qcache_not_cached：不适合进行缓存的查询数量，通常是由于这些查询不是select语句或用了now()之类的函数。Qcache_queries_in_cach：当前缓存的查询和响应数量。Qcache_total_blocks：缓存中块的数量。 query_cache的配置命令： mysql&gt; show variables like &apos;query_cache%&apos;; +------------------------------+---------+ | Variable_name | Value | +------------------------------+---------+ | query_cache_limit | 1048576 | | query_cache_min_res_unit | 2048 | | query_cache_size | 2097152 | | query_cache_type | ON | | query_cache_wlock_invalidate | OFF | +------------------------------+---------+ 字段解释如下： query_cache_limit：超过此大小的查询将不缓存。query_cache_min_res_unit：缓存块的最小值。query_cache_size：查询缓存大小。query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存select sql_no_cache查询。query_cache_wlock_invalidat：表示当有其他客户端正在对MyISAM表进行写操作，读请求是要等WRITE LOCK释放资源后再查询还是允许直接从Query Cache中读取结果，默认为OFF（可以直接从Query Cache中取得结果。）query_cache_min_res_unit的配置是一柄双刃剑，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。 查询缓存碎片率 = Qcache_free_blocks /Qcache_total_blocks * 100%如果查询碎片率超过20%，可以用 flush query cache 整理缓存碎片，或者试试减少query_cache_min_res_unit，如果你查询都是小数据库的话。查询缓存利用率 = (Qcache_free_size – Qcache_free_memory)/query_cache_size * 100%查询缓存利用率在25%一下的话说明query_cache_size设置得过大，可适当减少;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话则说明query_cache_size可能有点小，不然就是碎片太多。 查询命中率 = (Qcache_hits - Qcache_insert)/Qcache)hits * 100%示例服务器中的查询缓存碎片率等于20%左右，查询缓存利用率在50%，查询命中率在2%，说明命中率很差，可能写操作比较频繁，而且可能有些碎片。 排序使用情况它表示系统中对数据进行排序时所用的Buffer，我们可以用如下命令查看： mysql&gt; show global status like &apos;sort%&apos;; +-------------------+----------+ | Variable_name | Value | +-------------------+----------+ | Sort_merge_passes | 10 | | Sort_range | 37431240 | | Sort_rows | 6738691532 | | Sort_scan | 1823485 | +-------------------+----------+ Sort_merge_passes包括如下步骤：MySQL首先会尝试在内存中做排序，使用的内存大小由系统变量sort_buffer_size来决定，如果它不够大则把所有的记录都读在内存中，而MySQL则会把每次在内存中排序的结果存到临时文件中，等MySQL找到所有记录之后，再把临时文件中的记录做一次排序。这次再排序就会增加sort_merge_passes。实际上，MySQL会用另外一个临时文件来存储再次排序的结果，所以我们通常会看sort_merge_passes增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增大sort_buffer_size会减少sort_merge_passes和创建临时文件的次数，但盲目地增大sort_buffer_size并不一定能提高速度。 文件打开数(open_files)我们现在处理MySQL故障时，发现当Open_files大于open_files_limit值时，MySQL数据库就会发生卡住的现象，导致Nginx服务器打不开相应页面。这个问题大家在工作中应注意，我们可以用如下命令查看其具体情况： show global status like ‘open_files’; +—————+——-+ | Variable_name | Value | +—————+——-+ | Open_files | 1481 | +—————+——-+ mysql&gt; show global status like ‘open_files_limit’; +——————+——-+ | Variable_name | Value | +——————+——–+ | Open_files_limit | 4509 | +——————+——–+ 比较合适的设置是：Open_files / Open_files_limit * 100% &lt; = 75% InnoDB_buffer_pool_cache合理设置InnoDB存储引擎的缓存机制和MyISAM的最大区别就在于，InnoDB不仅仅缓存索引，同时还会缓存实际的数据。此参数用来设置InnoDB最主要的Buffer的大小，也就是缓存用户表及索引数据的最主要缓存空间，对InnoDB整体性能影响也最大。无论是MySQL官方手册还是网络上许多人分享的InnoDB优化建议，都是简单地建议将此值设置为整个系统物理内存的50%~80%。这种做法其实不妥，我们应根据实际的运行场景来正确设置此项参数。 很多时候我们会发现，通过参数设置进行性能优化所带来的性能提升，并不如许多人想象的那样会产生质的飞跃，除非是之前的设置存在严重不合理的情况。我们不能将性能调优完全依托与通过DBA在数据库上线后进行参数调整，而应该在系统设计和开发阶段就尽可能减少性能问题。(重点在于前期架构合理的设计及开发的程序合理) MySQL数据库的可扩展架构方案（即高可用方案） 可参考：mysql高可用方案总结性说明如果凭借MySQL的优化任无法顶住压力，这个时候我们就必须考虑MySQL的可扩展性架构了(有人称为MySQL集群)它有以下明显的优势： 1）成本低，很容易通过价格低廉Pc server搭建出一个处理能力非常强大的计算机集群。2）不太容易遇到瓶颈，因为很容易通过添加主机来增加处理能力。3）单节点故障对系统的整体影响较小。 主从复制解决方案这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。MySQL replication就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。为了达到更高的可用性，在实际的应用环境中，一般都是采用MySQL replication技术配合高可用集群软件keepalived来实现自动failover，这种方式可以实现95.000%的SLA。 在实际应用场景中，MySQL Replication是使用最为广泛的一种提高系统扩展性的设计手段。众多的MySQL使用者通过Replication功能提升系统的扩展性后，通过 简单的增加价格低廉的硬件设备成倍 甚至成数量级地提高了原有系统的性能，是广大MySQL中低端使用者非常喜欢的功能之一，也是许多MySQL使用者选择MySQL最为重要的原因。比较常规的MySQL Replication架构也有好几种，这里分别简单说明下： MySQL Replication架构一：常规复制架构–Master-slaves是由一个Master复制到一个或多个Salve的架构模式，主要用于读压力大的应用数据库端廉价扩展解决方案，读写分离，Master主要负责写方面的压力。MySQL Replication架构二：级联复制架构即Master-Slaves-Slaves,这个也是为了防止Slaves的读压力过大，而配置一层二级 Slaves，很容易解决Master端因为附属slave太多而成为瓶劲的风险。MySQL Replication架构三：Dual Master与级联复制结合架构即Master-Master-Slaves，最大的好处是既可以避免主Master的写操作受到Slave集群的复制带来的影响，而且保证了主Master的单点故障。MySQL Replication的不足：如果Master主机硬件故障无法恢复，则可能造成部分未传送到slave端的数据丢失。所以大家应该根据自己目前的网络 规划，选择自己合理的Mysql架构方案，跟自己的MySQL DBA和程序员多沟涌，多备份(备份我至少会做到本地和异地双备份)，多测试，数据的事是最大的事，出不得半点差错，切记切记 MMM/MHA高可用解决方案MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。 Heartbeat/SAN高可用解决方案在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。 Heartbeat/DRBD高可用解决方案此方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。 percona xtradb clusterPercona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。3）每个节点都包含完整的数据副本。PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。 MYSQL经典应用架构 其中：Dbm157是mysql主，dbm158是mysql主的备机，dbs159/160/161是mysql从。MySQL写操作一般采用基于heartbeat+DRBD+MySQL搭建高可用集群的方案。通过heartbeat实现对mysql主进行状态监测，而DRBD实现dbm157数据同步到dbm158。读操作普遍采用基于LVS+Keepalived搭建高可用高扩展集群的方案。前端AS应用通过提高的读VIP连接LVS，LVS有keepliaved做成高可用模式，实现互备。最后，mysql主的从节点dbs159/160/161通过mysql主从复制功能同步mysql主的数据，通过lvs功能提供给前端AS应用进行读操作，并实现负载均衡。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQ binlog三种模式及设置方法]]></title>
      <url>%2F2016%2F03%2F12%2FMySQ%20binlog%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[MySQ binlog三种模式及设置方法Row Level 行模式日志中会记录每一行数 据被修改的形式，然后在slave端再对相同的数据进行修改 优点：在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条被修改。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。 不会出现某些特定的情况下的存储过程或function，以及trigger的调用和触发无法被正确复制的问题 缺点：row level，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，会产生大量的日志内容。 Statement Level（默认每一条会修改数据的sql都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行 优点：statement level下的优点首先就是解决了row level下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能，因为它只需要在Master上锁执行的语句的细节，以及执行语句的上下文的信息。 缺点：由于只记录语句，所以，在statement level下 已经发现了有不少情况会造成MySQL的复制出现问题，主要是修改数据的时候使用了某些定的函数或者功能的时候会出现。 Mixed 自动模式在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志格式，也就是在Statement和Row之间选择一种。 如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。 企业场景如何选择binlog模式1、互联网公司，使用MySQL的功能相对少（存储过程、触发器、函数） 选择默认的语句模式，Statement Level（默认） 2、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数） 则选择Mixed模式 3、公司如果用到使用MySQL的特殊功能（存储过程、触发器、函数）又希望数据最大化一直，此时最好选择Row level模式 行模式和语句模式的区别1.语句模式： 100万条记录 只需1条delete * from test；就可以删除100万条记录 2.row模式 100万条记录 记录100万条删除命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx配置SSL证书部署HTTPS网站]]></title>
      <url>%2F2016%2F03%2F11%2FNginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E9%83%A8%E7%BD%B2HTTPS%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[购买ssl证书购买网站：沃通 上传证书到nginx服务器，然后进行解压。解压后的的效果： [root@bubidev-ng3 nginx]# pwd/etc/nginx [root@bubidev-ng3 nginx]# ll CRT 即 certificate的缩写，即证书。KEY 通常指私钥。 在nginx的配置文件里面配置12345678910111213141516171819server &#123; listen 443; server_name www.tang.cn tang.cn; ssl on; ssl_certificate bumeng_cn_ssl_pro.crt; ssl_certificate_key bumeng_cn_ssl_pro.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1; ssl_ciphers HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM; ssl_prefer_server_ciphers on; if ( $http_user_agent = &quot;Mozilla/5.0&quot;)&#123; return 403; &#125; location / &#123; proxy_pass http://10.0.0.10:8080/tang; proxy_cookie_path /tang/ /; proxy_set_header Host &quot;www.tang.cn&quot;; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx采用https加密访问后出现的问题]]></title>
      <url>%2F2016%2F03%2F11%2FNginx%E9%87%87%E7%94%A8https%E5%8A%A0%E5%AF%86%E8%AE%BF%E9%97%AE%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[线上的一个网站运行了一段时间，应领导要求，将其访问方式更改为https加密方式。更改为https后，网站访问正常，但网站注册功能不能正常使用了！ 经过排查，是nginx配置里结合php部分漏洞了一个参数（fastcgi_param HTTPS ）导致，添加上这个参数后，问题迎刃而解！nginx支持https的配置时，需要在php区域配置中添加FastCGI服务，否则https不支持php文件。 1234567891011location ~ \.php$ &#123;root /var/www/vhosts/fff/main;fastcgi_pass 127.0.0.1:9000;fastcgi_read_timeout 30;fastcgi_index fff.php;fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;#include fastcgi_params;include fastcgi.conf;fastcgi_param HTTPS on; 【或者fastcgi_param HTTPS $https if_not_empty; 】&#125; &#125; 如何开启 Nginx 的 SSL 或者 HTTPS呢？ 大家有没有试过使用HTTPS登陆 phpmyadmin 的时候会自动返回“The plain HTTP request was sent to HTTPS port”？这是个 fastcgi 的配置问题！ 解决方法：12345678location ~ .*\.(php|php5)?$&#123;try_files $uri =404;fastcgi_pass unix:/tmp/php-cgi.sock;fastcgi_param HTTPS $https if_not_empty;fastcgi_index index.php;include fcgi.conf;&#125; 解释： 很多人认为使用 fastcgi_param HTTPS on;，这样是没错啦，不过强迫使用这个参数，可能不太有效！ 最好的答案是上面的配置（参考下面 nginx 官方的链接）fastcgi_param HTTPS $https if_not_empty;有 https 协议时才自动使用 https on，否则忽略这个参数。内嵌的变量：$https – 如果链接是 SSL 就返回 “ON”，否则返回空字符串。if_not_empty; – 当参数有值时才传递到服务器 注意：这个 if_not_empty 额外参数只适合 Nginx 1.1.11 之后的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysqladmin命令总结]]></title>
      <url>%2F2016%2F03%2F11%2FMysqladmin%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[mysqladmin 工具的使用格式： mysqladmin [option] command [command option] command ...... 参数选项： -c number 自动运行次数统计，必须和 -i 一起使用 -i number 间隔多长时间重复执行 0）每个两秒查看一次服务器的状态，总共重复5次。 [root@test-huanqiu ~]# mysqladmin -uroot -p -i 2 -c 5 status 1）查看服务器的状况：status [root@test-huanqiu ~]# mysqladmin -uroot -p status 2）修改root 密码： [root@test-huanqiu ~]# mysqladmin -u root -p原密码 password &apos;newpassword&apos; 3）检查mysqlserver是否可用： [root@test-huanqiu ~]# mysqladmin -uroot -p ping 4）查询服务器的版本 [root@test-huanqiu ~]# mysqladmin -uroot -p version 5）查看服务器状态的当前值： [root@test-huanqiu ~]# mysqladmin -uroot -p extended-status 6）查询服务器系统变量值： [root@test-huanqiu ~]# mysqladmin -uroot -p variables 7）显示服务器所有运行的进程： [root@test-huanqiu ~]# mysqladmin -uroot -p processlist [root@test-huanqiu ~]# mysqladmin -uroot -p-i 1 processlist 8）创建数据库 [root@test-huanqiu ~]# mysqladmin -uroot -p create daba-test//每秒刷新一次 9）显示服务器上的所有数据库 [root@test-huanqiu ~]# mysqlshow -uroot -p 10）显示数据库daba-test下有些什么表： [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test 11）统计daba-test 下数据库表列的汇总 [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v 12）统计daba-test 下数据库表的列数和行数 [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v -v 13）删除数据库 daba-test [root@test-huanqiu ~]# mysqladmin -uroot -p drop daba-test 14）重载权限信息 [root@test-huanqiu ~]# mysqladmin -uroot -p reload 15）刷新所有表缓存，并关闭和打开log [root@test-huanqiu ~]# mysqladmin -uroot -p refresh 16）使用安全模式关闭数据库 [root@test-huanqiu ~]# mysqladmin -uroot -p shutdown 17）刷新命令mysqladmin flush commands [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-hosts [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-logs [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-privileges [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-status [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-tables [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-threads 18）mysqladmin 执行kill 进程： [root@test-huanqiu ~]# mysqladmin -uroot -p processlist [root@test-huanqiu ~]# mysqladmin -uroot -p kill idnum 19）停止和启动MySQL replication on a slave server [root@test-huanqiu ~]# mysqladmin -u root -p stop-slave [root@test-huanqiu ~]# mysqladmin -u root -p start-slave 20）同时执行多个命令 [root@test-huanqiu ~]# mysqladmin -u root -p process status version]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx服务器http重定向到https]]></title>
      <url>%2F2016%2F03%2F11%2FNginx%E6%9C%8D%E5%8A%A1%E5%99%A8http%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0https%2F</url>
      <content type="text"><![CDATA[http重定向到https使用了nginx的重定向命令。那么应该如何写重定向？之前老版本的nginx可能使用了以下类似的格式。 1rewrite ^/(.*)$ http://domain.com/$1 permanent; 或者1rewrite ^ http://domain.com$request_uri? permanent; 现在nginx新版本已经换了种写法，上面这些已经不再推荐。 下面是nginx http页面重定向到https页面最新支持的写法：123456789101112server &#123; listen 80; server_name my.domain.com; return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl; server_name my.domain.com; [....]&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx配置文件nginx.conf中文详解]]></title>
      <url>%2F2016%2F03%2F11%2FNginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6nginx.conf%E4%B8%AD%E6%96%87%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。Nginx安装完毕后，会有响应的安装目录，安装目录里nginx.conf为nginx的主配置文件，ginx主配置文件分为4部分，main（全局配置）、server（主机设置）、upstream（负载均衡服务器设）和location（URL匹配特定位置的设置），这四者关系为：server继承main，location继承server，upstream既不会继承其他设置也不会被继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123;#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。use epoll;#单个进程最大连接数（最大连接数=连接数*进程数）worker_connections 65535;&#125;#设定http服务器http&#123;include mime.types; #文件扩展名与文件类型映射表default_type application/octet-stream; #默认文件类型#charset utf-8; #默认编码server_names_hash_bucket_size 128; #服务器名字的hash表大小client_header_buffer_size 32k; #上传文件大小限制large_client_header_buffers 4 64k; #设定请求缓client_max_body_size 8m; #设定请求缓sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。tcp_nopush on; #防止网络阻塞tcp_nodelay on; #防止网络阻塞keepalive_timeout 120; #长连接超时时间，单位是秒#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#gzip模块设置gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 2; #压缩等级gzip_types text/plain application/x-javascript text/css application/xml;#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。gzip_vary on;#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用upstream blog.ha97.com &#123;#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。server 192.168.80.121:80 weight=3;server 192.168.80.122:80 weight=2;server 192.168.80.123:80 weight=3;&#125;#虚拟主机的配置server&#123;#监听端口listen 80;#域名可以有多个，用空格隔开server_name www.ha97.com ha97.com;index index.html index.htm index.php;root /data/www/ha97;location ~ .*\.(php|php5)?$&#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125;#图片缓存时间设置location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 10d;&#125;#JS和CSS缓存时间设置location ~ .*\.(js|css)?$&#123;expires 1h;&#125;#日志格式设定log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;#定义本虚拟主机的访问日志access_log /var/log/nginx/ha97access.log access;#对 &quot;/&quot; 启用反向代理location / &#123;proxy_pass http://127.0.0.1:88;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IPproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#以下是一些反向代理的配置，可选。proxy_set_header Host $host;client_max_body_size 10m; #允许客户端请求的最大单文件字节数client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&#125;#设定查看Nginx状态的地址location /NginxStatus &#123;stub_status on;access_log on;auth_basic &quot;NginxStatus&quot;;auth_basic_user_file conf/htpasswd;#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#125;#本地动静分离反向代理配置#所有jsp的页面均交由tomcat或resin处理location ~ .(jsp|jspx|do)?$ &#123;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://127.0.0.1:8080;&#125;#所有静态文件由nginx直接读取不经过tomcat或resinlocation ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; expires 15d; &#125;location ~ .*.(js|css)?$&#123; expires 1h; &#125;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Iptables防火墙规则使用梳理]]></title>
      <url>%2F2016%2F02%2F25%2FIptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E4%BD%BF%E7%94%A8%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[iptables是组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换(NAT)等功能。在日常Linux运维工作中，经常会设置iptables防火墙规则，用来加固服务安全。以下对iptables的规则使用做了总结性梳理： iptables相关概念### 规则概念规则（rules）其实就是网络管理员的预定义的条件，规则一般定义为’如果数据包’符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等.当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行(accept),拒绝(reject)和丢弃(drop)等。配置防火墙的主要工作是添加,修改和删除等规则。 其中：匹配（match）：符合指定的条件，比如指定的 IP 地址和端口。丢弃（drop）：当一个包到达时，简单地丢弃，不做其它任何处理。接受（accept）：和丢弃相反，接受这个包，让这个包通过。拒绝（reject）：和丢弃相似，但它还会向发送这个包的源主机发送错误消息。这个错误消息可以指定，也可以自动产生。目标（target）：指定的动作，说明如何处理一个包，比如：丢弃，接受，或拒绝。跳转（jump）：和目标类似，不过它指定的不是一个具体的动作，而是另一个链，表示要跳转到那个链上。规则（rule）：一个或多个匹配及其对应的目标。 iptables和netfilter的关系Iptables和netfilter的关系是一个很容易让人搞不清的问题。很多的知道iptables却不知道netfilter。其实iptables只是Linux防火墙的管理工具而已，位于/sbin/iptables。真正实现防火墙功能的是 netfilter，它是Linux内核中实现包过滤的内部结构。 iptables的规则表和链表（tables）：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。 链（chains）：是数据包传播的路径，每一条链其实就是众多规则的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定 义的默认策略来处理数据包。 Iptables采用“表”和“链”的分层结构，在Linux中现在是四张表五个链。下面罗列一下这四张表和五个链（注意一定要明白这些表和链的关系及作用）。 规则表：1.filter表——三个链：INPUT、FORWARD、OUTPUT作用：过滤数据包 内核模块：iptables_filter.2.Nat表——三个链：PREROUTING、POSTROUTING、OUTPUT作用：用于网络地址转换（IP、端口） 内核模块：iptable_nat3.Mangle表——五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS内核模块：iptable_mangle(别看这个表这么麻烦，咱们设置策略时几乎都不会用到它)4.Raw表——两个链：OUTPUT、PREROUTING作用：决定数据包是否被状态跟踪机制处理 内核模块：iptable_raw 规则链：1.INPUT——进来的数据包应用此规则链中的策略2.OUTPUT——外出的数据包应用此规则链中的策略3.FORWARD——转发数据包时应用此规则链中的策略4.PREROUTING——对数据包作路由选择前应用此链中的规则（记住！所有的数据包进来的时侯都先由这个链处理）5.POSTROUTING——对数据包作路由选择后应用此链中的规则（所有的数据包出来的时侯都先由这个链处理） 管理和设置iptables规则： iptables传输数据包的过程 1）当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。 2）如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。 3）如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。 如果还是不清楚数据包经过iptables的基本流程，再看下面更具体的流程图：从图中可将iptables数据包报文的处理过程分为三种类型： 目的为本机的报文报文以本机为目的地址时，其经过iptables的过程为：1.数据包从network到网卡2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)3.如果设置了连接跟踪，则在这条连接上处理。4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤/NAT/伪装这类的事情)5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源/目的地址的转换)6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文交给本机处理)7.进入mangle表的 INPUT 链。在把报文实际送给本机前，路由之后，我们可以再次修改报文。8.进入filter表的 INPUT 链。在这儿我们对所有送往本机的报文进行过滤，要注意所有收到的并且目的地址为本机的报文都会经过这个链，而不管哪个接口进来的或者它往哪儿去。 进过规则过滤，报文交由本地进程或者应用程序处理，例如服务器或者客户端程序。本地主机发出报文数据包由本机发出时，其经过iptables的过程为：1.本地进程或者应用程序（例如服务器或者客户端程序）发出数据包。2.路由选择，用哪个源地址以及从哪个接口上出去，当然还有其他一些必要的信息。3.进入raw表的OUTPUT链。这里是能够在连接跟踪生效前处理报文的点，在这可以标记某个连接不被连接跟踪处理。4.连接跟踪对本地的数据包进行处理。5.进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤(以避免副作用)。6.进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做目的NAT(DNAT) 。7.进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。8.再次进行路由决定，因为前面的 mangle 和 nat 表可能修改了报文的路由信息。9.进入 mangle 表的 POSTROUTING 链。这条链可能被两种报文遍历，一种是转发的报文，另外就是本机产生的报文。10.进入 nat 表的 POSTROUTING 链。在这我们做源 NAT（SNAT），建议你不要在这做报文过滤，因为有副作用。即使你设置了默认策略，一些报文也有可能溜过去。11.进入出去的网络接口。转发报文报文经过iptables进入转发的过程为：1.数据包从network到网卡2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)3.如果设置了连接跟踪，则在这条连接上处理。4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤/NAT/伪装这类的事情)5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源/目的地址的转换)6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文进行转发)7.进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。8.进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。9.进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。10.进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。11.进入出去的网络接口。 iptables规则设置用法iptables的基本语法格式iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］说明：表名、链名：用于指定iptables命令所操作的表和链；命令选项：用于指定管理iptables规则的方式（比如：插入、增加、删除、查看等；条件匹配：用于指定对符合什么样 条件的数据包进行处理；目标动作或跳转：用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转（Jump）给其它链处理。 iptables命令的管理控制选项-A 在指定链的末尾添加（append）一条新的规则-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除-I 在指定链中插入（insert）一条新的规则，默认在第一行添加-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换-L 列出（list）指定链中所有的规则进行查看（默认是filter表，如果列出nat表的规则需要添加-t，即iptables -t nat -L）-E 重命名用户定义的链，不改变链本身-F 清空（flush）-N 新建（new-chain）一条用户自己定义的规则链-X 删除指定表中用户自定义的规则链（delete-chain）-P 设置指定链的默认策略（policy）-Z 将所有表的所有链的字节和数据包计数器清零-n 使用数字形式（numeric）显示输出结果-v 查看规则表详细信息（verbose）的信息-V 查看版本(version)-h 获取帮助（help） 防火墙处理数据包的四种方式ACCEPT 允许数据包通过DROP 直接丢弃数据包，不给任何回应信息REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息。LOG在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 iptables防火墙规则的保存与恢复iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载使用命令iptables-save来保存规则。一般用：iptables-save &gt; /etc/sysconfig/iptables生成保存规则的文件/etc/sysconfig/iptables，也可以用：service iptables save它能把规则自动保存在/etc/sysconfig/iptables中。当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。 iptables防火墙常用的策略梳理设置默认链策略ptables的filter表中有三种链：INPUT, FORWARD和OUTPUT。默认的链策略是ACCEPT，可以将它们设置成DROP，如下命令就将所有包都拒绝了：iptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP 其实，在运维工作中最常用的两个规则就是白名单规则和NAT转发规则： 白名单规则在linux终端命令行里操作时，如果不是默认的filter表时，需要指定表；如果在/etc/sysconfig/iptables文件里设置，就在对应表的配置区域内设置；上面两种方式设置效果是一样的！12345比如开通本机的22端口，允许192.168.1.0网段的服务器访问（-t filter表配置可以省略，默认就是这种表的配置）[root@linux-node1 ~]# iptables -A INPUT -s 192.168.1.0/24 -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT或者[root@linux-node1 ~]# iptables -t filter -A INPUT -s 192.168.1.0/24 -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT 12开通本机的80端口，只允许192.168.1.150机器访问（32位掩码表示单机，单机指定时可以不加掩码）[root@linux-node1 ~]# iptables -t filter -A INPUT -s 192.168.1.150/32 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT 然后保存规则，重启iptables12[root@linux-node1 ~]# service iptables save[root@linux-node1 ~]# service iptables restart 或者在/etc/sysconfig/iptables文件里设置如下（其实上面在终端命令行里设置并save和restart防火墙后，就会自动保存规则到/etc/sysconfig/iptables这个文件中的）：12345678910111213[root@bastion-IDC ~]# cat /etc/sysconfig/iptables......*filter:INPUT ACCEPT [442620:173026884]:FORWARD ACCEPT [118911:23993940]:OUTPUT ACCEPT [8215384:539509656]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -s 192.168.1.0/24 -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -s 192.168.1.150/32 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT[root@bastion-IDC ~]# service iptables restart NAT转发设置比如访问本机（192.168.1.7）的8088端口转发到192.168.1.160的80端口；访问本机的33066端口转发到192.168.1.161的3306端口准备工作：本机打开ip_forword路由转发功能；192.168.1.160/161的内网网关要和本机网关一致！如果没有内网网关，就将网关设置成本机内网ip，并且关闭防火墙（防火墙要是打开了，就设置对应端口允许本机访问）1234567891011121314151617181920212223242526272829303132333435363738[root@kvm-server conf]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 8088 -j DNAT --to-destination 192.168.1.160:80[root@kvm-server conf]# iptables -t nat -A POSTROUTING -d 192.168.1.160/32 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.168.1.7[root@kvm-server conf]# iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 8088 -j ACCEPT[root@kvm-server conf]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 33066 -j DNAT --to-destination 192.168.1.161:3306[root@kvm-server conf]# iptables -t nat -A POSTROUTING -d 192.168.1.161/32 -p tcp -m tcp --sport 3306 -j SNAT --to-source 192.168.1.7[root@kvm-server conf]# iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 33066 -j ACCEPT[root@kvm-server conf]# service iptables save[root@kvm-server conf]# service iptables restart或者在/etc/sysconfig/iptables文件里设置如下[root@bastion-IDC ~]# cat /etc/sysconfig/iptables......*nat:PREROUTING ACCEPT [60:4250]:INPUT ACCEPT [31:1973]:OUTPUT ACCEPT [3:220]:POSTROUTING ACCEPT [3:220]-A PREROUTING -p tcp -m tcp --dport 8088 -j DNAT --to-destination 192.168.1.160:80 //PREROUTING规则都放在上面-A PREROUTING -p tcp -m tcp --dport 33066 -j DNAT --to-destination 192.168.1.161:3306-A POSTROUTING -d 192.168.1.160/32 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.168.1.7 //POSTROUTING规则都放在下面-A POSTROUTING -d 192.168.1.161/32 -p tcp -m tcp --sport 3306 -j SNAT --to-source 192.168.1.7.....*filter:INPUT ACCEPT [16:7159]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [715:147195]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8088 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 33066 -j ACCEPT.....[root@bastion-IDC ~]# service iptables restart[root@bastion-IDC ~]# iptables -L //列出设置的规则，默认列出的是filter表下的规则[root@bastion-IDC ~]# iptables -L -t nat //如果列出nat表下规则，就加-t参数 删除INPUT链的第一条规则iptables -D INPUT 1 拒绝进入防火墙的所有ICMP协议数据包iptables -I INPUT -p icmp -j REJECT 允许防火墙转发除ICMP协议以外的所有数据包iptables -A FORWARD -p ! icmp -j ACCEPT说明：使用“！”可以将条件取反 拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据1234iptables -A FORWARD -s 192.168.1.11 -j REJECT iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT说明：注意一定要把拒绝的放在前面不然就不起作用了！ 丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包123iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP 封堵网段（192.168.1.0/24），两小时后解封1234# iptables -I INPUT -s 10.20.30.0/24 -j DROP # iptables -I FORWARD -s 10.20.30.0/24 -j DROP # at now 2 hours at&gt; iptables -D INPUT 1 at&gt; iptables -D FORWARD 1说明：这个策略可以借助crond计划任务来完成，就再好不过了 只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机123iptables -A INPUT -s 202.13.0.0/16 -p tcp -m tcp -m state --state NEW --dport 22 -j ACCEPT 说明：这个用法比较适合对设备进行远程管理时使用，比如位于分公司中的SQL服务器需要被总公司的管理员管理时 通常在服务器上会对某一服务端口的访问做白名单限制，比如（其他端口设置和下面一致）：运行本机的3306端口（mysql服务）被访问123iptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 3306 -j ACCEPT 或者只运行本机的3306端口被192.168.1.0/24网段机器访问iptables -A INPUT -s 192.168.1.0/24 -p tcp -m tcp -m state --state NEW --dport 3306 -j ACCEPT 允许本机开放从TCP端口20-1024提供的应用服务1iptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 20:1024 -j ACCEPT 允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包12iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT 屏蔽指定的IP地址以下规则将屏蔽BLOCK_THIS_IP所指定的IP地址访问本地主机：BLOCK_THIS_IP=”x.x.x.x”123iptables -A INPUT -i eth0 -s &quot;$BLOCK_THIS_IP&quot; -j DROP(或者仅屏蔽来自该IP的TCP数据包）iptables -A INPUT -i eth0 -p tcp -s &quot;$BLOCK_THIS_IP&quot; -j DROP 屏蔽环回(loopback)访问12iptables -A INPUT -i lo -j DROPiptables -A OUTPUT -o lo -j DROP 屏蔽来自外部的ping，即禁止外部机器ping本机12iptables -A INPUT -p icmp --icmp-type echo-request -j DROPiptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP 屏蔽从本机ping外部主机，禁止本机ping外部机器12iptables -A OUTPUT -p icmp --icmp-type echo-request -j DROPiptables -A INPUT -p icmp --icmp-type echo-reply -j DROP 禁止其他主机ping本机，但是允许本机ping其他主机（禁止别人ping本机，也可以使用echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all）123iptables -I INPUT -p icmp --icmp-type echo-request -j DROP iptables -I INPUT -p icmp --icmp-type echo-reply -j ACCEPT iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT 禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包123iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。咱们这里用“-m mac –mac-source”来表示数据包的源MAC地址 允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280123456789iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT注意：这里用“-m multiport --dport”来指定多个目的端口iptables -A INPUT -p tcp -m tcp -m multiport --dports 22,80,443,1250-1280 -m state --state NEW -j ACCEPT也可以将这几个端口分开设置多行：iptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 22 -j ACCEPTiptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 80 -j ACCEPTiptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 443 -j ACCEPTiptables -A INPUT -p tcp -m tcp -m state --state NEW --dport 1250:1280 -j ACCEPT 禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包123456789iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP说明：此处用“-m iprange --src-range”指定IP范围1）过滤源地址范围：iptables -A INPUT -m iprange --src-range 192.168.1.2-192.168.1.7 -j DROP2）过滤目标地址范围：iptables -A INPUT -m iprange --dst-range 192.168.1.2-192.168.1.7 -j DROP3）针对端口访问的过滤。下面表示除了192.168.1.5-192.168.1.10之间的ip能访问192.168.1.67机器的80端口以外，其他ip都不可以访问！iptables -A INPUT -d 192.168.1.67 -p tcp --dport 80 -m iprange --src-range 192.168.1.5-192.168.1.10 -j ACCEPT 禁止转发与正常TCP连接无关的非–syn请求数据包12iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的 拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包123iptables -A INPUT -p tcp -m state --state NEW -j DROP iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等 防止DoS攻击1234567iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT-m limit: 启用limit扩展，限制速度。--limit 25/minute: 允许最多每分钟25个连接--limit-burst 100: 当达到100个连接后，才启用上述25/minute限制--icmp-type 8 表示 Echo request——回显请求（Ping请求）。下面表示本机ping主机192.168.1.109时候的限速设置：iptables -I INPUT -d 192.168.1.109 -p icmp --icmp-type 8 -m limit --limit 3/minute --limit-burst 5 -j ACCEPT 允许路由如果本地主机有两块网卡，一块连接内网(eth0)，一块连接外网(eth1)，那么可以使用下面的规则将eth0的数据路由到eht1：1iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT IPtables中可以灵活的做各种网络地址转换（NAT）网络地址转换主要有两种：SNAT和DNAT1）SNAT是source network address translation的缩写，即源地址目标转换。比如，多个PC机使用ADSL路由器共享上网，每个PC机都配置了内网IP。PC机访问外部网络的时候，路由器将数据包的报头中的源地址替换成路由器的ip，当外部网络的服务器比如网站web服务器接到访问请求的时候，它的日志记录下来的是路由器的ip地址，而不是pc机的内网ip，这是因为，这个服务器收到的数据包的报头里边的“源地址”，已经被替换了。所以叫做SNAT，基于源地址的地址转换 2）DNAT是destination network address translation的缩写，即目标网络地址转换。典型的应用是，有个web服务器放在内网中，配置了内网ip，前端有个防火墙配置公网ip，互联网上的访问者使用公网ip来访问这个网站。当访问的时候，客户端发出一个数据包，这个数据包的报头里边，目标地址写的是防火墙的公网ip，防火墙会把这个数据包的报头改写一次，将目标地址改写成web服务器的内网ip，然后再把这个数据包发送到内网的web服务器上。这样，数据包就穿透了防火墙，并从公网ip变成了一个对内网地址的访问了。即DNAT，基于目标的网络地址转换 以下规则将会把本机192.168.1.17来自422端口的流量转发到22端口，这意味着来自422端口的SSH连接请求与来自22端口的请求等效。1）启用DNAT转发1iptables -t nat -A PREROUTING -p tcp -d 192.168.1.17 --dport 422 -j DNAT --to-destination 192.168.1.17:22 2）允许连接到422端口的请求1iptables -t filter -A INPUT -p tcp -m tcp -m state --state NEW --dport 422 -j ACCEPT 3）保存规则12# service iptables save# service iptables restart 假设现在本机外网网关是58.68.250.1，那么把HTTP请求转发到内部的一台服务器192.168.1.20的8888端口上，规则如下：12345iptables -t nat -A PREROUTING -p tcp -i eth0 -d 58.68.250.1 --dport 8888 -j DNAT --to 192.168.1.20:80iptables -A FORWARD -p tcp -i eth0 -d 192.168.0.2 --dport 80 -j ACCEPTiptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPTservice iptables saveservice iptables restart 或者或本机内网ip是192.168.1.10，那么把HTTP请求转发到内部的一台服务器192.168.1.20的8888端口上，规则如下：准备工作：本机打开ip_forword路由转发功能；192.168.1.20的内网网关要和本机网关保持一致！如果没有内网网关，就将网关地址设置成本机内网ip，并且关闭防火墙（防火墙要是打开了，就设置对应端口允许本机访问）12345iptables -t nat -A PREROUTING -p tcp -m tcp --dport 20022 -j DNAT --to-destination 192.168.1.150:22iptables -t nat -A POSTROUTING -d 192.168.1.150/32 -p tcp -m tcp --sport 22 -j SNAT --to-source 192.168.1.8iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 20022 -j ACCEPTservice iptables saveservice iptables restart MASQUERADE，地址伪装，在iptables中有着和SNAT相近的效果，但也有一些区别：1）使用SNAT的时候，出口ip的地址范围可以是一个，也可以是多个，例如：1）如下命令表示把所有10.8.0.0网段的数据包SNAT成192.168.5.3的ip然后发出去1iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j SNAT --to-source 192.168.5.3 2）如下命令表示把所有10.8.0.0网段的数据包SNAT成192.168.5.3/192.168.5.4/192.168.5.5等几个ip然后发出去1iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j SNAT --to-source 192.168.5.3-192.168.5.5 这就是SNAT的使用方法，即可以NAT成一个地址，也可以NAT成多个地址。但是，对于SNAT，不管是几个地址，必须明确的指定要SNAT的ip假如当前系统用的是ADSL动态拨号方式，那么每次拨号，出口ip192.168.5.3都会改变，而且改变的幅度很大，不一定是192.168.5.3到192.168.5.5范围内的地址。这个时候如果按照现在的方式来配置iptables就会出现问题了，因为每次拨号后，服务器地址都会变化，而iptables规则内的ip是不会随着自动变化的，每次地址变化后都必须手工修改一次iptables，把规则里边的固定ip改成新的ip，这样是非常不好用的！ 2）MASQUERADE就是针对上述场景而设计的，它的作用是，从服务器的网卡上，自动获取当前ip地址来做NAT。比如下边的命令：1iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j MASQUERADE 如此配置的话，不用指定SNAT的目标ip了。不管现在eth0的出口获得了怎样的动态ip，MASQUERADE会自动读取eth0现在的ip地址然后做SNAT出去这样就实现了很好的动态SNAT地址转换 运维实例设置：1）限制本机的web服务器在周一不允许访问； 新请求的速率不能超过100个每秒； web服务器包含了admin字符串的页面不允许访问： web 服务器仅允许响应报文离开本机；设置如下：周一不允许访问12iptables -A INPUT -p tcp --dport 80 -m time ! --weekdays Mon -j ACCEPTiptables -A OUTPUT -p tcp --dport 80 -m state --state ESTABLISHED -j ACCEPT 新请求速率不能超过100个每秒1iptables -A INPUT -p tcp --dport 80 -m limit --limit 100/s -j ACCEPT web包含admin字符串的页面不允许访问，源端口：dport1iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string &apos;admin&apos; -j REJECT web服务器仅允许响应报文离开主机,放行端口（目标端口）：sportiptables -A OUTPUT -p tcp –dport 80 -m state –state ESTABLISHED -j ACCEPT 2)在工作时间，即周一到周五的8:30-18:00，开放本机的ftp服务给 192.168.1.0网络中的主机访问； 数据下载请求的次数每分钟不得超过 5 个；设置如下：1iptables -A INPUT -p tcp --dport 21 -s 192.168.1.0/24 -m time ! --weekdays 6,7 -m time --timestart 8:30 --timestop 18:00 -m connlimit --connlimit-above 5 -j ACCET 3）开放本机的ssh服务给192.168.1.1-192.168.1.100 中的主机； 新请求建立的速率一分钟不得超过2个； 仅允许响应报文通过其服务端口离开本机；设置如下：12iptables -A INPUT -p tcp --dport 22 -m iprange --src-rang 192.168.1.1-192.168.1.100 -m limit --limit 2/m -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -m iprange --dst-rang 192.168.1.1-192.168.1.100 -m state --state ESTABLISHED -j ACCEPT 4）拒绝 TCP 标志位全部为 1 及全部为 0 的报文访问本机；1iptables -A INPUT -p tcp --tcp-flags ALL ALL -j DROP 5）允许本机 ping 别的主机；但不开放别的主机 ping 本机；12345iptables -I INPUT -p icmp --icmp-type echo-request -j DROP iptables -I INPUT -p icmp --icmp-type echo-reply -j ACCEPT iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT或者下面禁ping操作：echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SaltStack（5）--Grains]]></title>
      <url>%2F2016%2F01%2F05%2FSaltStack%EF%BC%885%EF%BC%89--Grains%2F</url>
      <content type="text"><![CDATA[SaltStack里的Grains功能,讲的是minion端静态变量,在master端通过Granins可以获得minion对应的变量值. 查看minion的全部静态变量，可以通过如下实现： 查看minion的全部静态变量.12345678910111213141516root@node-10 ~]# salt &apos;node-11&apos; grains.lsnode-11: - SSDs - biosreleasedate - biosversion - cpu_flags - cpu_model - cpuarch - disks - dns - domain - fqdn - fqdn_ip4 - fqdn_ip6 - gid ... 列出key及vlaue123456789101112131415[root@node-10 ~]# salt &apos;node-11&apos; grains.itemsnode-11: ---------- SSDs: biosreleasedate: 07/31/2013 biosversion: 6.00 cpu_flags: - fpu - vme - de - pse - tsc ... 静态变量是成组出现的，如上只是列出了组的key（用python的思维理解） 查看指定的key值12345[root@node-10 ~]# salt &apos;node-11&apos; grains.item kernelrelease node-11: ---------- kernelrelease: 3.10.0-123.el7.x86_64 自定义grains.item第一种方法在minion端：修改配置文件/etc/salt/minion 中 打开 default_include: minion.d/*.conf在minion端的/etc/salt/minion.d/ 目录下新建并编辑conf文件，如：1234567[root@node-11 ~]# cd /etc/salt/minion.d/[root@node-11 minion.d]# vim idc.confgrains: #必须声明 idc: tang user: tang1 [root@node-11 minion.d]# systemctl restart salt-minion 重启salt-minion服务，在master验证：12345[root@node-10 ~]# salt &apos;node-11&apos; grains.item idc node-11: ---------- idc: tang 第二种方法在master端添加在/srv/salt/ 创建_grains目录，编写grains文件，需要返回一个字典123456cd /srv/salt/_grains/[root@node-10 /srv/salt/_grains]# vim wlink.pydef wlink(): wlink=&#123;&#125; wlink[&apos;wlink&apos;]=&apos;yes&apos; return wlink 执行如下命令推送到minion端：123[root@node-10 /srv/salt/_grains]# salt &apos;node-11&apos; saltutil.sync_grains node-11: - grains.wlink #必须要出现这个模块，不然表示推送不成功 master端验证：12345[root@node-10 /srv/salt/_grains]# salt &apos;node-11&apos; grains.item wlink node-11: ---------- wlink: yes #返回了值，表示验证成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SaltStack（4）--ZeroMQ]]></title>
      <url>%2F2016%2F01%2F04%2FSaltStack%EF%BC%884%EF%BC%89--ZeroMQ%2F</url>
      <content type="text"><![CDATA[我们进行自动化运维大多数情况下，是我们的服务器数量已经远远超过人工SSH维护的范围，SaltStack可以支数以千计，甚至更多的服务器。这些性能的提供主要来自于ZeroMQ，因为SaltStack底层是基于ZeroMQ进行高效的网络通信。ZMQ用于node与node间的通信，node可以是主机也可以是进程 ZeroMQ简介 ZeroMQ（我们通常还会用ØMQ , 0MQ, zmq等来表示）是一个简单好用的传输层，像框架一样的一个套接字库，他使得Socket编程更加简单、简洁和性能更高。它还是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。 发布与订阅ZeroMQ支持Publish/Subscribe，即发布与订阅模式，我们经常简称Pub/Sub。 Salt Master运行两个网络服务，其中一个是ZeroMQ PUB系统，默认监听4505端口。可以通过修改/etc/salt/master配置文件的publish_port参数设置。它是salt的消息发布系统，如果查看4505端口，会发现所有的Minion连接到Master的4505端口，TCP状态持续保持为ESTABLISHED。123456[root@node-10 ~]# lsof -i:4505COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 1109 root 14u IPv4 2130345 0t0 TCP *:4505 (LISTEN)salt-mast 1109 root 16u IPv4 2131887 0t0 TCP node-10:4505-&gt;node-10:37255 (ESTABLISHED)salt-mast 1109 root 17u IPv4 2133378 0t0 TCP node-10:4505-&gt;node-11:56725 (ESTABLISHED)salt-mini 4712 root 20u IPv4 2134221 0t0 TCP node-10:37255-&gt;node-10:4505 (ESTABLISHED) 这样Salt Master发布一个消息，所有连接到4505这个Pub端口上的Minion都会接收到这个消息。然后每个Minion会再判断自己是否需要执行这个消息。 请求与响应 Salt Master运行的第二个网络服务就是ZeroMQ REP系统，默认监听4506端口，可以通过修改/etc/salt/master配置文件的ret_port参数设置。它是salt客户端与服务端通信的端口。比如说Minion执行某个命令后的返回值就是发送给Master的4506这个REP端口由于我们在最初安装了python-setproctitle软件包，所以我们可以直接看到Salt Master启动的进程的名称123[root@node-10 ~]# lsof -i:4506COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 1115 root 22u IPv4 2129518 0t0 TCP *:4506 (LISTEN)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SaltStack（3）--配置管理]]></title>
      <url>%2F2016%2F01%2F03%2FSaltStack%EF%BC%883%EF%BC%89--%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[YAML编写技巧刚接触Sal tStack的状态管理，最苦恼的可能就是SLS的编写了，尽管YAML语法可能第一眼看上去很简洁，但是真正写起来也是令人畏惧，初学者很容易被各种报错搞晕，降低对Sal tStack的学习乐趣，甚至放弃SaltStack，但是只要记住三个非常简单的规则就可以快乐地使用YAML语法编写SLS文件了。 规则一：缩进YAML使用一个固定的缩进风格表示数据层级结构关系。SaltStack需要每个缩进级别由两个空格组成。注意：不要使用tabs，缩进是初学者总容易出错的地方之一。 提示： 2个空格，不能使用tab键 规则二：冒号Python的字典是简单的键值对，其他语言的用户也应该知道这个数据类型叫哈希表或者关联数组。字典的key在YAML中的表现形式是一个以冒号结尾的字符串： 提示： 冒号后面有空格1my_key: my_value 规则三：短横杠想要表示列表项，使用一个短横杠加一个空格。多个项使用同样的缩进级别作为同一列表的一部分。 提示： 短横线后面有空格 state状态模块state功能state是Saltstack最核心的功能，通过预先定制好的sls（salt state file）文件对被控制主机进行状态管理，支持包括程序包（pkg）、文件（file）、网络配置（network）、系统服务（service）、系统用户（user）等 设置file_roots1234567[root@node-10 ~]# vim /etc/salt/masterfile_roots: #file_root: 需定格 base: #base前面两个空格 - /srv/salt #-前面四个空格，后面一个空格 #这三行去掉前面的#即可，使用默认的配置路径 [root@node-10 ~]# systemctl restart salt-master 123在这里有个特别需要我们注意的问题，一定要确保file_roots前面没有空格，而base前两个空格-前面四个空格，在salt的配置里面空格十分重要，我们必须高度注意，否则及其容易造成实验不成功，之所以对空格敏感主要salt基于Python开发，并采用了yaml的语法.（注意注意注意，不要使用tab键）有必要解释下相关配置内容:base:代表环境（默认必须有），可就是说salt可以同时管理多个环境，比如测试、开发、生产等环境。其实从我们修改的行上方不难我们不难看出，salt拥有针对多环境的特点。至于底下的小- 则代表状态文件存放路径，可能有些同学对这个状态文件有些疑惑，我们拿软件安装来讲，我们想要批量安装，环境标准化。我们总得告诉系统，我们要安装什么，怎么安装。这时候我们就需要一个文件为系统指明，这个文件就是上面的状态文件。要注意-和后面的路径有中间有一个空格哦 创建相应的目录12[root@node-10 ~]# mkdir /srv/salt -p[root@node-10 ~]# cd /srv/salt/ 设置top.sls1234567在top.sls入口文件设置环境（如生产、开发、测试对应不同的minion和模块）。[root@node-10 ~]# vim /srv/salt/top.slsbase: &apos;*&apos;: - nginx解释：所有的Minion均执行base目录下的init模块下的pkg-init.sls。我们可以把很多的sls放在一个目录中，方便管理。在top.sls只需要指定目录结构即可。 编写状态文件123456789101112[root@node-10 web]# vim nginx.sls nginx-install: #state名称：nginx-install pkg.installed: #管理对象类型：pkg，需要执行的方法installed - names: #管理对象名称 - nginx #名称：nginxnginx-service: #管理对象类型：nginx-service，管理系统守护进程 service.running: #service要执行的方法：running， - name: nginx #管理对象名称：nginx - enable: True #管理对象的状态， 提示：注意格式 执行状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@node-10 web]# salt &apos;*&apos; state.sls web.nginxnode-11:---------- ID: nginx-install Function: pkg.installed Name: nginx Result: True Comment: Package nginx is already installed Started: 23:32:40.788400 Duration: 533.65 ms Changes: ---------- ID: nginx-service Function: service.running Name: nginx Result: True Comment: The service nginx is already running Started: 23:32:41.322820 Duration: 47.314 ms Changes: Summary for node-11------------Succeeded: 2Failed: 0------------Total states run: 2Total run time: 580.964 msnode-10:---------- ID: nginx-install Function: pkg.installed Name: nginx Result: True Comment: Package nginx is already installed Started: 21:53:53.713711 Duration: 530.331 ms Changes: ---------- ID: nginx-service Function: service.running Name: nginx Result: True Comment: The service nginx is already running Started: 21:53:54.244788 Duration: 49.855 ms Changes: Summary for node-10------------Succeeded: 2Failed: 0------------Total states run: 2Total run time: 580.186 ms 实际master执行这个nginx.sls模块是将nginx.sls模块发送给minion之后，在minion上执行的12345678910[root@node-11 ~]# cat /var/cache/salt/minion/files/base/web/nginx.sls nginx-install: pkg.installed: - names: - nginxnginx-service: service.running: - name: nginx - enable: True top.sls高级执行状态123456789101112131415161718192021222324252627282930[root@node-10 ~]# cd /srv/salt/[root@node-10 salt]# vim top.sls base: &apos;node-10&apos;: - web.nginx &apos;node-11&apos;: - web.nginx [root@node-10 salt]# salt &apos;*&apos; state.highstate node-10:---------- ID: nginx-install Function: pkg.installed Name: nginx Result: True Comment: Package nginx is already installed Started: 22:16:45.084148 Duration: 471.103 ms Changes: ---------- ID: nginx-service Function: service.running Name: nginx Result: True ... 在执行状态模块之前可以先测试执行，以免执行出错[root@node-10 salt]# salt &apos;*&apos; state.highstate test=True]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SaltStack（2）--远程执行]]></title>
      <url>%2F2016%2F01%2F02%2FSaltStack%EF%BC%882%EF%BC%89--%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[软件依赖要求 Python版本要求Python版本大于2.6小于3.0 msgpack-python: Saltstack消息交换库 YAML: Saltstack配置解析定义语法 jinja2: Saltstack states配置模板 MarkupSafe: Python unicode转换库 apache-libcloud: Saltstack对云架构编排库 Requests HTTP Python库 Zero MQ: Saltstack消息系统 pyzmq: ZeroMQ Python库 PyCrypto: Python 密码库 M2Crypto: Openssl Python包装库 安装系统环境操作系统：centos7 x86_64主机1：IP：192.168.10.10主机名：node-10 主机2：IP: 192.168.10.11主机名：node-11 安装说明1.在主机192.168.10.10上安装salt-master 和salt-minion2.主机192.168.10.11上安装salt-minion 安装具体过程1234[root@node-10 ~]# yum install https://repo.saltstack.com/yum/redhat/salt-repo-latest-1.el7.noarch.rpm -y[root@node-10 ~]# yum install -y salt-master salt-minion[root@node-11 ~]# yum install -y salt-minion[root@node-10 ~]# systemctl start salt-master SaltStack配置修改master配置文件1234[root@node-10 ~]# vim /etc/salt/masterinterface: 129.168.10.10 #服务端ip.[root@node-10 ~]# systemctl start salt-master 修改被minion端12345[root@node-10 ~]# vim /etc/salt/minionmaster: 192.168.10.10 #master的主机名或ip. IP地址后面有一个空格id:node-10 #本机标识符,默认为主机名[root@node-10 ~]# systemctl start salt-minion 日志文件默认路径12[root@node-10 ~]# tailf /var/log/salt/master[root@node-10 ~]# tailf /var/log/salt/minion 接受minion的托管请求minion向master投诚后, 还需要master接受才行. 这个过程叫做”授信”123456[root@node-10 ~]# salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:node-10Rejected Keys: 命令说明：123456789101112salt-key -L #查看当前所有证书情况salt-key -A -y # -A 是接受所有等待认证的key -l ARG, --list=ARG #显示指定状态的key(支持正则表达式) -L， --list-all #显示所有public keys -a ACCEPT, --accept=ACCEPT #接受指定等待认证的key(支持正则表达式) -A, --accept-all #接受所欲等待认证得key -r REJECT, --reject=REJECT #拒绝指定的等待认证的key（支持正则） -R， --reject-all #拒绝所有等待认证的key -d DELETE, --delete=DELETE #删除指定key -D, --delete-all #删除所欲key -f FINGER, --finger=FINGER #删除指定key -F, --finger-all #删除所有key 其中Unaccepted Keys是未许可的minion. 可使用下面的命令通过认证12345678910111213[root@node-10 ~]# salt-key -a node-10The following keys are going to be accepted:Unaccepted Keys:node-10Proceed? [n/Y] yKey for minion node-10 accepted.[root@node-10 ~]# salt-key -LAccepted Keys: #已许可的minionnode-10Denied Keys:Unaccepted Keys:Rejected Keys: 测试基本操作命令通用格式12格式: 命令 对象 执行模块 参数salt ‘*’ cmd.run “ping -c 4 www.baidu.com&quot; 测试连通性安装配置好之后, 首先要测试一下连通性, salt会列出每个认证过的minion连通状态(true或false).123456[root@node-10 ~]# salt &apos;*&apos; test.ping[root@node-10 minions_pre]# salt &apos;*&apos; test.pingnode-10: Truenode-11: True 远程执行模块： `cmd.run12345[root@node-10 minions_pre]# salt &apos;*&apos; cmd.run &apos;/etc/init.d/network restart &apos;node-11: Restarting network (via systemctl): [ OK ]node-10: Restarting network (via systemctl): [ OK ] 批量查看系统时间12345[root@node-10 minions_pre]# salt &apos;*&apos; cmd.run &quot;uptime&quot;node-11: 19:42:12 up 3:28, 1 user, load average: 0.00, 0.01, 0.05node-10: 18:03:25 up 1 day, 13:03, 2 users, load average: 0.02, 0.06, 0.10 注意:默认情况下master和minion之间使用以下端口进行通信:4505(publish_port)：salt的消息发布系统4506(ret_port)：salt客户端与服务端通信的端口cmd.run 为模块,又称之为超级命令. 可以执行Linux中的任何命令.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SaltStack（1）--简介]]></title>
      <url>%2F2016%2F01%2F01%2FSaltStack%EF%BC%881%EF%BC%89--%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[SaltStack简单说明一个配置管理系统，能够维护预定义状态的远程节点(比如，确保指定的报被安装，指定的服务在运行)一个分布式远程执行系统，用来在远程节点（可以是单个节点，也可以是任意规则挑选出来的节点）上执行命令和查询数据开发其的目的是为远程执行提供最好的解决方案，并使远程执行变得更好，更快，更简单 Salt的核心功能1.使命令发送到远程系统是并行的而不是串行的2.使用安全加密的协议3.使用最小最快的网络载荷4.提供简单的编程接口5.Salt同样引入了更加细致化的领域控制系统来远程执行，使得系统成为目标不止可以通过主机名，还可以通过系统属性。 Builds on proven technology 为了允许简单的扩展，Salt执行程序可以写为纯Python模块。数据从Salt执行过程中收集到可以发送回master服务端，或者发送到任何任意程序。Salt可以从一个简单的PythonAPI调用，或者从命令行被调用，所以Salt可以用来执行一次性命令，也可以作为一个更大的应用程序的一个组成部分。 Python客户端接口为了允许简单的扩展，Salt执行程序可以写为纯Python模块。数据从Salt执行过程中收集到可以发送回master服务端，或者发送到任何任意程序。Salt可以从一个简单的PythonAPI调用，或者从命令行被调用，所以Salt可以用来执行一次性命令，也可以作为一个更大的应用程序的一个组成部分。 特性快速，灵活，易扩展结果是能够在1台或多台目标机器上快速执行命令的系统。Salt运行快速，安装简单，高度可定制；Salt用相同的远程执行架构满足管理不同数量服务器的需求。Salt基础设施可以集成最好的远程执行工具，增强了Salt的能力及用途，得到功能丰富实用可以适用于任何网络的系统 Salt 三大功能A、远程执行B、配置管理（状态，不可以回滚，需要谨慎操作）C、云管理 Salt竞争对手Pupper （需要ruby，不支持远程执行）+func使用ansible （Python） 四种运行方式1.Local 本地模式2.Minion/Master C/S架构（客户端/服务器 ）3.Syndic -Zabbix proxy 代理模式4.Salt SSHSSH模式 注意：最好使用Minion/Master模式来运行，一般大公司都是使用这种模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LVM常规操作记录梳理]]></title>
      <url>%2F2015%2F05%2F11%2FLVM%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[基本介绍Linux用户安装Linux 操作系统时遇到的一个最常见的难以决定的问题就是如何正确地给评估各分区大小，以分配合适的硬盘空间。随着 Linux的逻辑盘卷管理功能的出现，这些问题都迎刃而解，lvm是逻辑盘卷管理（Logical Volume Manager）的简称，它是 Linux环境下对磁盘分区进行管理的一种机制， LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。 LVM基本术语1）物理存储介质：这里指系统的存储设备：硬盘，如： /dev/hda、/dev/sda等等，是存储系统最低层的存储单元。2）物理卷physical volume （PV ）物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如 RAID)，是 LVM的基本存储逻辑块3）卷组Volume Group （VG ）LVM卷组由一个或多个物理卷组成，但是更确切的说，它包含由这些物理卷提供的许多PE。4）逻辑卷logical volume （LV ）这里是我们存储信息的地方，在逻辑卷之上可以建立文件系统 (比如/home或者 /usr等)。5）PE（physical extent ）每一个物理卷被划分为称为 PE的基本单元，具有唯一编号的 PE是可以被 LVM寻址的最小单元。 PE的大小是可配置的，默认为 4MB。 具体操作创建一个分区12345678910111213141516[root@test-server ~]# fdisk -l // 查看磁盘情况 [root@test-server ~]# fdisk /dev/sda // 进入磁盘（可以依次按键p-&gt;n-&gt;e-&gt;回车-&gt;回车-&gt;w，即用此磁盘所有空闲空间创建分区）Command (m for help): n //n 为添加一个分区， p查看分区 First cylinder (2898-10443, default 2898): // 按Enter 键决定Using default value 2898 // 起始柱面选择默认值 Last cylinder or +size or +sizeM or +sizeK (289810443, default 10443): +2G // 给2G的大小 Command (m for help): t // 更改分区类型Partition number (1-5): 5 // 选着分区Hex code (type L to list codes): l // 分区类型列表Hex code (type L to list codes):8e //将新添加的分区标注成 lvm Command (m for help): p // 查看分区表/dev/sda5 2756 2999 1959898+ 8e Linux LVM Command (m for help): w // 保存[root@test-server ~]# partprobe /dev/sda // 系统识别分区（代替重启） [root@test-server ~]# mkfs.ext4 /dev/sda5 // 格式化新添加的分区 PV的创建123456[root@test-server ~]# pvcreate /dev/sda5 // 创建pv Writing physical volume data to disk &quot;/dev/sda5&quot; Physical volume &quot;/dev/sda5&quot; successfully created [root@test-server ~]# pvs //或pvdisplay,查看当前pv的信息 PV VG Fmt Attr PSize PFree /dev/sda5 lvm2 a-- 1.87G 1.87G VG的创建12345[root@test-server ~]# vgcreate vg0 /dev/sda5 //vg0 为当前vg的名 Volume group &quot;vg0&quot; successfully created [root@test-server ~]# vgs //或vgdispaly,查看vg 的信息VG #PV #LV #SN Attr VSize VFree vg0 1 0 0 wz--n- 1.87G 1.87G lvm的创建123456789#lvcreate -L 大小 -n 名字 隶属哪一个巻组#lvcreate -l PE个数 -n 名字 隶属哪一个巻组 [root@test-server ~]# lvcreate -L +500M -n lv01 vg0 Logical volume &quot;lv01&quot; created [root@test-server ~]# lvs //或lvdispaly,查看lv 的信息LV VG Attr LSize Origin Snap% Move Log Copy% Convert lv01 vg0 -wi-a- 500.00M You have mail in /var/spool/mail/root[root@test-server ~]# mkfs.ext4 /dev/vg0/lv01 //格式化 lvm的使用12345[root@test-server ~]# mkdir /mnt/lv01 //建立挂在目录 [root@test-server ~]# mount /dev/vg0/lv01 /mnt/lv01 //将制作的lvm挂载起来 [root@test-server ~]# df -h[root@test-server ~]# touch /mnt/lv01/lv.file [root@test-server ~]#ls /mnt/lv01 lvm的增大123456[root@test-server ~]# lvextend -L +300M /dev/vg0/lv01 //原来lv大小500M ，拉伸分区到 800M。前提是vg0里面还有剩余空间（vgdispaly查看Free PE）。如没有剩余，需要vgextend扩建。Logical volume lv01 successfully resized [root@test-server ~]# resize2fs /dev/vg0/lv01 //拉伸文件系统[root@test-server ~]# lvsLV VG Attr LSize Origin Snap% Move Log Copy% Convert lv01 vg0 -wi-ao 800.00M //大小变成了 800M lvm的减小12345678910111213141516171819[root@test-server ~]# umount /dev/vg0/lv01 //卸载逻辑卷 /dev/vg0/lv01，或者卸载/mnt/lv01目录也可以[root@test-server ~]# df -h //查看 [root@test-server ~]# e2fsck -f /dev/vg0/lv01 // 磁盘校验 [root@test-server ~]# resize2fs /dev/vg0/lv01 500M //回缩文件系统到 500M [root@test-server ~]# lvreduce -L 500M /dev/vg0/lv01 //回缩分区到 500M WARNING: Reducing active logical volume to 500.00 MB THIS MAY DESTROY YOUR DATA (filesystem etc.) Do you really want to reduce lv01? [y/n]: y [root@test-server ~]# lvs LV VG Attr LSize Origin Snap% Move Log Copy% Convert lv01 vg0 -wi-a- 500.00M //此时已变成500M大小[root@test-server ~]# mount /dev/vg0/lv01 /mnt/lv01 //重新挂载分区 [root@test-server ~]# df -h //查看 [root@test-server ~]# ls /mnt/lv01 //查看文件特别注意的是：resize2fs命令 针对的是ext2、ext3、ext4文件系统。xfs_growfs命令 针对的是xfs文件系统 lvm的系统快照原理：系统快照（snapshot）是 lvm的另外一种重要的功能，快照就是将当时的数据记录下来，就好像照相记录一样，以后数据有任何改动，原数据会被移动到快照区，没有被改变的区域则由快照区与文件系统共享。由于快照区和原本的 LV共享很多 PE，所以快照区与被快照的区域必须在同一个 VG上操作：以上面创建的 lv01为例 挂载lvm12345[root@test-server ~]# mount /dev/vg0/lv01 /mnt/lv01 [root@test-server ~]# cd /mnt/lv01[root@test-server lv01]# touch &#123;a,b,c&#125;&#123;a,b,c&#125;[root@test-server lv01]# lsaa ab ac ba bb bc ca cb cc lost+found lv.file restoresymtable 为lvm创建快照12[root@test-server lv01]# lvcreate -L 64M -s -n lv-backup /dev/vg0/lv01 Logical volume &quot;lv-backup&quot; create 挂载快照12[root@test-server lv01]# mkdir /mnt/lv-backup[root@test-server mnt]# mount -o ro /dev/vg0/lv-backup /mnt/lv-backup/ 备份快照123[root@test-server tmp]# dump -0u -f /tmp/lv-backup.dump /mnt/lv-backup/ //备份DUMP: Date of this level 0 dump: Sun Nov 11 14:53:31 2012 DUMP: Dumping /dev/mapper/vg0-lv--backup (/mnt/lv-backup) to /tmp/lv-backup.dump 删除快照1234[root@test-server tmp]# umount /mnt/lv-backup/ [root@test-server tmp]# lvremove /dev/vg0/lv-backup Do you really want to remove active logical volume lv-backup? [y/n]: y Logical volume &quot;lv-backup&quot; successfully removed 清空/dev/vg0/lv01下内容12345[root@test-server tmp]# umount /mnt/lv01[root@test-server tmp]# mkfs.ext3 /dev/vg0/lv01 mke2fs 1.39 (29-May-2006)Filesystem label=OS type: Linux 恢复数据12345678[root@test-server tmp]# mount /dev/vg0/lv01 /mnt/lv01 [root@test-server tmp]# cd /mnt/lv01[root@test-server lv01]# lslost+found[root@test-server lv01]# restore -rf /tmp/lv-backup.dump //恢复restore: ./lost+found: File exists[root@test-server lv01]# ls //由于之前都删除了，所以这些都是改变的部分 aa ab ac ba bb bc ca cb cc lost+found lv.file restoresymtable lvm的关闭12345678910[root@test-server ~]# umount /mnt/lv01[root@test-server ~]# lvremove /dev/vg0/lv01 //删除lv Do you really want to remove active logical volume lv01? [y/n]: y Logical volume &quot;lv01&quot; successfully removed [root@test-server ~]# vgchange -a n vg0 //使vg0不具有 active标志 0 logical volume(s) in volume group &quot;vg0&quot; now active [root@test-server ~]# vgremove vg0 //删除vg Volume group &quot;vg0&quot; successfully removed [root@test-server ~]# pvremove /dev/sda5 //删除pv Labels on physical volume &quot;/dev/sda5&quot; successfully wiped]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx 伪静态设置]]></title>
      <url>%2F2015%2F04%2F11%2FNginx%20%E4%BC%AA%E9%9D%99%E6%80%81%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[伪静态是一种可以把文件后缀改成任何可能的一种方法，如果我想把php文件伪静态成html文件，这种相当简单的，下面来介绍nginx 伪静态配置方法有需要了解的朋友可参考 nginx只需要打开nginx.conf配置文件，在server里面写需要的规则即可。 示例配置：12345678910111213141516171819cat nginx.confserver &#123;listen 80;server_name localhost;location / &#123;root /usr/local/nginx-1.10/html/bbs;index index.html index.htm;ssi on;ssi_silent_errors on;ssi_types text/shtml;if (!-e $request_filename)&#123;rewrite ^(.*)$ /$1.html last;break;&#125;&#125;&#125;]]></content>
    </entry>

    
  
  
</search>
