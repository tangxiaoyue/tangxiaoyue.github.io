<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Docker高级（3）--架构总览]]></title>
      <url>%2F2017%2F03%2F12%2FDocker%E9%AB%98%E7%BA%A7%EF%BC%883%EF%BC%89--%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%2F</url>
      <content type="text"><![CDATA[背景###Docker简介&#8194;&#8194;&#8194;&#8194;Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache2.0协议。&#8194;&#8194;&#8194;&#8194;目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。&#8194;&#8194;&#8194;&#8194;由于众多新颖的特性以及项目本身的开放性，Docker在不到两年的时间里迅速获得诸多厂商的青睐，其中更是包括Google、Microsoft、VMware等业界行业领导者。Google在今年六月份推出了Kubernetes，提供Docker容器的调度服务，而今年8月Microsoft宣布Azure上支持Kubernetes，随后传统虚拟化巨头VMware宣布与Docker强强合作。今年9月中旬，Docker更是获得4000万美元的C轮融资，以推动分布式应用方面的发展。&#8194;&#8194;&#8194;&#8194;从目前的形势来看，Docker的前景一片大好。本系列文章从源码的角度出发，详细介绍Docker的架构、Docker的运行以及Docker的卓越特性。本文是Docker源码分析系列的第一篇­­­——Docker架构篇。 Docker版本信息&#8194;&#8194;&#8194;&#8194;本文关于Docker架构的分析都是基于Docker的源码与Docker相应版本的运行结果，其中Docker为最新的1.2版本。 Docker架构分析内容安排&#8194;&#8194;&#8194;&#8194;本文的目的是：在理解Docker源代码的基础上，分析Docker架构。分析过程中主要按照以下三个步骤进行： ● Docker的总架构图展示 ● Docker架构图内部各模块功能与实现分析 ● 以Docker命令的执行为例，进行Docker运行流程阐述 Docker总架构图&#8194;&#8194;&#8194;&#8194;学习Docker的源码并不是一个枯燥的过程，反而可以从中理解Docker架构的设计原理。Docker对使用者来讲是一个C/S模式的架构，而Docker的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑Docker的运行。在此，先附上Docker总架构，如图3.1。&#8194;&#8194;&#8194;&#8194;如图3.1，不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。&#8194;&#8194;&#8194;&#8194;而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。&#8194;&#8194;&#8194;&#8194;Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。&#8194;&#8194;&#8194;&#8194;而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。&#8194;&#8194;&#8194;&#8194;当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。 Docker架构内各模块的功能与实现分析&#8194;&#8194;&#8194;&#8194;接下来，我们将从Docker总架构图入手，抽离出架构内各个模块，并对各个模块进行更为细化的架构分析与功能阐述。主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。 Docker Client&#8194;&#8194;&#8194;&#8194;Docker Client是Docker架构中用户用来和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。&#8194;&#8194;&#8194;&#8194;Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。为了简单起见，本文一律使用第一种方式作为讲述两者通信的原型。与此同时，与Docker &#8194;&#8194;&#8194;&#8194;Daemon建立连接并传输请求的时候，Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。&#8194;&#8194;&#8194;&#8194;Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。 Docker Daemon&#8194;&#8194;&#8194;&#8194;Docker Daemon是Docker架构中一个常驻在后台的系统进程，功能是：接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker &#8194;&#8194;&#8194;&#8194;Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。&#8194;&#8194;&#8194;&#8194;Docker Daemon启动所使用的可执行文件也为docker，与Docker Client启动所使用的可执行文件docker相同。在docker命令执行时，通过传入的参数来判别Docker Daemon与Docker Client。&#8194;&#8194;&#8194;&#8194;Docker Daemon的架构，大致可以分为以下三部分：Docker Server、Engine和Job。Daemon架构如图4.1。 &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.1 Docker Daemon架构示意图 Docker Server &#8194;&#8194;&#8194;&#8194; Docker Server在Docker架构中是专门服务于Docker Client的server。该server的功能是：接受并调度分发Docker Client发送的请求。Docker Server的架构如图4.2。 &#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194; 图4.2 Docker Server架构示意图 &#8194;&#8194;&#8194;&#8194;在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。&#8194;&#8194;&#8194;&#8194;若Docker Client通过HTTP的形式访问Docker &#8194;&#8194;&#8194;&#8194;Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。&#8194;&#8194;&#8194;&#8194;在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。&#8194;&#8194;&#8194;&#8194;需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。 Engine&#8194;&#8194;&#8194;&#8194;Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。&#8194;&#8194;&#8194;&#8194;在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler Job&#8194;&#8194;&#8194;&#8194;一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。&#8194;&#8194;&#8194;&#8194;Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等 Docker Registry&#8194;&#8194;&#8194;&#8194;Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。&#8194;&#8194;&#8194;&#8194;在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。&#8194;&#8194;&#8194;&#8194;其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成 Graph&#8194;&#8194;&#8194;&#8194;Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如图4.3。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;图4.3 Graph架构示意图 &#8194;&#8194;&#8194;&#8194;其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。&#8194;&#8194;&#8194;&#8194;同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs Driver&#8194;&#8194;&#8194;&#8194;Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。&#8194;&#8194;&#8194;&#8194;因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。&#8194;&#8194;&#8194;&#8194;在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。&#8194;&#8194;&#8194;&#8194;graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。&#8194;&#8194;&#8194;&#8194;在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。graphdriver的架构如图4.4： &#8194;&#8194;&#8194;&#8194;networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如图4.5： &#8194;&#8194;&#8194;&#8194;execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如图4.6： libcontainer&#8194;&#8194;&#8194;&#8194;libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如图4.7 &#8194;&#8194;&#8194;&#8194;另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。&#8194;&#8194;&#8194;&#8194;暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。 Docker container&#8194;&#8194;&#8194;&#8194;Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。Docker按照用户的需求与指令，订制相应的Docker容器： ● 用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统； ● 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源； ● 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境； ● 用户通过指定运行的命令，使得Docker容器执行指定的工作。Docker容器示意图如图4.8： Docker运行案例分析上一章节着重于Docker架构中各个部分的介绍。本章的内容，将以串联Docker各模块来简要分析，分析原型为Docker中的docker pull与docker run两个命令。 docker pull&#8194;&#8194;&#8194;&amp;#8194docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。docker pull命令执行流程如图5.1。 如图，图中标记的红色箭头表示docker pull命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。(1) Docker Client接受docker pull命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/images/create? “+”xxx”；(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(3) mux.Router将请求路由分发至相应的handler，具体为PostImagesCreate；(4) 在PostImageCreate这个handler之中，一个名为”pull”的job被创建，并开始执行；(5) 名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；(6) 名为”pull”的job将下载的image交给graphdriver；(7) graphdriver负责将image进行存储，一方创建graph对象，另一方面在GraphDB中记录image之间的关系。 docker run&#8194;&#8194;&#8194;docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client给Docker Server发送了两次HTTP请求，第二次请求的发起取决于第一次请求的返回状态。Docker run命令执行流程如图5.2。 如图，图中标记的红色箭头表示docker run命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。(1) Docker Client接受docker run命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/containers/create? “+”xxx”；(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(3) mux.Router将请求路由分发至相应的handler，具体为PostContainersCreate；(4) 在PostImageCreate这个handler之中，一个名为”create”的job被创建，并开始让该job运行；(5) 名为”create”的job在运行过程中，执行Container.Create操作，该操作需要获取容器镜像来为Docker容器创建rootfs，即调用graphdriver；(6) graphdriver从Graph中获取创建Docker容器rootfs所需要的所有的镜像；(7) graphdriver将rootfs所有镜像，加载安装至Docker容器指定的文件目录下；(8) 若以上操作全部正常执行，没有返回错误或异常，则Docker Client收到Docker Server返回状态之后，发起第二次HTTP请求。请求方法为”POST”，请求URL为”/containers/“+container_ID+”/start”；(9) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；(10)mux.Router将请求路由分发至相应的handler，具体为PostContainersStart；(11)在PostContainersStart这个handler之中，名为”start”的job被创建，并开始执行；(12)名为”start”的job执行完初步的配置工作后，开始配置与创建网络环境，调用networkdriver；(13)networkdriver需要为指定的Docker容器创建网络接口设备，并为其分配IP，port，以及设置防火墙规则，相应的操作转交至libcontainer中的netlink包来完成；(14)netlink完成Docker容器的网络环境配置与创建；(15)返回至名为”start”的job，执行完一些辅助性操作后，job开始执行用户指令，调用execdriver；(16)execdriver被调用，初始化Docker容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至libcontainer来完成；(17)libcontainer被调用，完成Docker容器内部的运行环境初始化，并最终执行用户要求启动的命令。 总结本文从Docker 1.2的源码入手，分析抽象出Docker的架构图，并对该架构图中的各个模块进行功能与实现的分析，最后通过两个docker命令展示了Docker内部的运行。通过对Docker架构的学习，可以全面深化对Docker设计、功能与价值的理解。同时在借助Docker实现用户定制的分布式系统时，也能更好地找到已有平台与Docker较为理想的契合点。另外，熟悉Docker现有架构以及设计思想，也能对云计算PaaS领域带来更多的启发，催生出更多实践与创新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法大全]]></title>
      <url>%2F2017%2F03%2F11%2FMarkdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[题记：随着Markdown语言的热度不断提升，越来越多的人喜欢使用Markdown这种简洁、便宜的语言来编辑自己的blog、文章。下面笔者就一些简单常用的Markdown语句进行介绍，希望对大家在进行Markdown语言编辑自己的文章时有所帮助。 1.斜体和粗体 代码： 1. *斜体*或_斜体_ 2. **粗体** 3. ***加粗斜体*** 显示效果： 这是一段斜体 这是一段粗体 这是一段加粗斜体 2.分级标题 第一种写法： 1.这是一个一级标题 2.================ 3. 4. 这是一个一级标题 5. -------------------------- 第二种写法： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3.超链接行内式 代码： 1.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk) 2. 3.欢迎来到[梵居闹市](http:// blog.leanote.com/freewalk &quot;梵居闹市&quot;) 显示效果： 欢迎来到梵居闹市欢迎来到梵居闹市 参考式 代码： 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]: http://www. google.com &quot;Google&quot; [2]:http://www. leanote.com &quot;Leanote&quot; [3]:http://http:/ /blog.leanote.com/freewalk &quot;梵居闹市&quot; [网站]:http: //http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 自动链接 代码： &lt;http://example.com/&gt; &lt;address@example.com&gt; 显示效果： http://example.com/&#97;&#x64;&#100;&#x72;&#x65;&#115;&#x73;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109; 4.锚点 代码： 跳转到[目录](#index) 显示效果： 跳转到目录 5.列表无序列表 使用 *，+，- 表示无序列表。 代码： 无序列表项 一 无序列表项 二 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表 代码： 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 列表缩进 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩 包含段落的列表 代码： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表 代码： * 阅读的方法:（一个空格） &gt; 打开书本。 &gt; 打开电灯。 显示效果： 阅读的方法: 打开书本。打开电灯。 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 一列表项包含一个列表区块： &lt;代码写在这&gt; 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 会显示成： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 1986\. What a great season. 会显示成：1986. What a great season. 6. 引用 代码： &gt; 这是一个有两段文字的引用, &gt; 无意义的占行文字1. &gt; 无意义的占行文字2. &gt; &gt; 无意义的占行文字3. &gt; 无意义的占行文字4 显示效果： 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4. 引用的多层嵌套 代码： &gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白 &gt;&gt; 自己看教程！ - 愤青 &gt; 教程在哪？ - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 引用其它要素 代码： &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 显示效果： 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像行内式 代码： 高圆圆： ![高圆圆](ht tp://pic2016.5442.com:82/2015/1117/16/7.jpg%21960.jpg &quot;高圆圆&quot;) 显示效果 高圆圆： 8. 内容目录 markdownpad居然不支持该语法，我就呵呵了. 代码： [TOC]0.目录 [TOC]1. 斜体和粗体 [TOC]2. 分级标题 [TOC]3. 超链接 [TOC] 行内式 [TOC] 参考式 [TOC] 自动链接 [TOC]4. 锚点 9. 注脚 代码： 使用 Markdown[1]可以效率的书写文档,你可以使用 Leanote[Le] 编辑器进行书写。 [1]:Markdown是一种纯文本标记语言 [Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果： 使用 Markdown1可以效率的书写文档,你可以使用 LeanoteLe 编辑器进行书写。 原文链接：http://blog.leanote.com/post/freewalk/Markdown-语法手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（6）--仓库管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89--%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker的仓库是DockerHub，类似于github，github有一个开源的软件叫gitlab。Docker也有一个开源软件docker registry [root@tang ~]# docker pull registry [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 默认占用5000端口，我们查看是否存在5000端口 [root@tang ~]# netstat -lntup | grep 5000 运行容器 [root@tang ~]# docker run -d -p 5000:5000 registry f002089ab95474290853a2a24b86cb0adbb5848c4a468175304b59b27d6e3b0e 提示：docker比较老的版本运行起来就可以运行，1.7之后都不可以]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（7）--数据管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89--%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[挂载本地目录到容器里[root@tang /]# mkdir /data/docker -p root@tang docker]# mkdir docker_01 [root@tang docker]# docker run -it -h docker_01 --name docker_01 -v /data/docker/docker_01/:/docker_01 centos bash [root@docker_01 /]# cd /docker_01/ [root@docker_01 docker_01]# touch docker_01.txt [root@docker_01 docker_01]# exit exit [root@tang docker]# cd /data/docker/docker_01/ [root@tang docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 08:03 docker_01.txt [root@tang docker_01]# cd .. [root@tang docker]# mkdir docker_02 [root@tang docker]# docker run -it -h docker_02 --name docker_02 -v /data/docker/docker_02/:/docker_02 centos bash [root@docker_02 /]# cd /docker_02/ [root@docker_02 docker_02]# mkdir docker_02.txt [root@docker_02 docker_02]# exit exit [root@tang docker]# cd docker_02/ [root@tang docker_02]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 08:05 docker_02.txt 提示： -v: 指定挂载目录 : : 前面的为本地目录 : : 后面到为容器里的目录 即使将删除这个容器,文件也不会丢失. 挂载数据卷(多个容器挂载宿主机的同一个目录)[root@tang data]# docker run -it -h docker_03 --name docker_03 --volumes-from docker_01 centos bash [root@docker_03 /]# cd /docker_01/ [root@docker_03 docker_01]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@docker_03 docker_01]# df -h|grep docker_01 /dev/vda1 99G 5.4G 88G 6% /docker_01 [root@docker_03 docker_01]# echo &quot;This is Doceker_3&quot; &gt; /docker_01/3.txt [root@docker_03 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt [root@tang ~]# docker start docker_01 docker_01 [root@tang ~]# docker-enter docker_01 [root@docker_01 ~]# cd /docker_01/ [root@docker_01 docker_01]# ll total 4 -rw-r--r-- 1 root root 18 Apr 3 00:26 3.txt -rw-r--r-- 1 root root 0 Apr 3 00:03 docker_01.txt 自定义数据卷容器[root@tang ~]# docker run -itd -h node --name node -v /data centos bash 056ac10e28855c3d29a94fe552711e6a712a5670e6e9c43c4b79270cbc6b0a0f #这里的/data是容器node的/data目录,而不是宿主机的/data目录 [root@tang ~]# docker-enter node [root@node ~]# touch /data/1 /data/2 /data/3 [root@node ~]# cd /data/ [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node data]# exit logout [root@tang ~]# docker run -itd -h node1 --name node1 --volumes-from node centos bash 2965a8f1184a7a1cbd26ef07e4b3d201fa17e5b68a52c619d6292da75c85d117 [root@tang ~]# docker-enter node1 [root@node1 ~]# cd /data/ [root@node1 data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 [root@node1 data]# touch 4 [root@node data]# ll total 0 -rw-r--r-- 1 root root 0 Apr 3 01:00 1 -rw-r--r-- 1 root root 0 Apr 3 01:00 2 -rw-r--r-- 1 root root 0 Apr 3 01:00 3 -rw-r--r-- 1 root root 0 Apr 3 01:02 4 数据卷的备份[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 250da7a47222e52c5a5d387ff8ce816a72b221ffb8d481739c4c68073507fe [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /data [root@tang ~]# touch /data/{1,2,3,4} [root@tang ~]# tar cvf /backup/data.tar /data/ [root@tang ~]# cd /backup/ [root@tang backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 01:30 data.tar [root@tang backup]# exit logout [root@docker ~]# cd /docker_data_backup/ [root@docker docker_data_backup]# ll total 12 -rw-r--r-- 1 root root 10240 Apr 3 09:30 data.tar 数据卷的恢复[root@docker ~]# mkdir /docker_data_backup [root@docker ~]# docker run -itd -h tang --name tang -v /docker_data_backup/:/backup centos bash 3728f6b0a6e5b47f904de0474db7d4479f33e87740906e1539eca385c3fab04d [root@docker ~]# docker-enter tang [root@tang ~]# mkdir /tools/ [root@tang ~]# touch /tools/{1,2,3,4} [root@tang ~]# tar zcvf /backup/tools.tar /tools/ /tools/ /tools/1 /tools/2 /tools/3 /tools/4 [root@tang ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang ~]# exit logout [root@docker ~]# docker run -itd -h tang1 --name tang1 -v /tang1 centos bash 7ec371bb67f136234878771c227c4245a0ccf6c986e8c94a412d6c4111852a2b [root@docker ~]# docker run -itd -h tang2 --name tang2 --volumes-from tang1 -v /docker_data_backup/:/backup centos bash 53e4cea1c45f3c081a6dd95b935f906aa037e6ed2170b6249a913ccd6fb4c119 [root@docker ~]# docker-enter tang2 [root@tang2 ~]# ll /backup/ total 4 -rw-r--r-- 1 root root 162 Apr 3 02:08 tools.tar [root@tang2 tang1]# tar xvf /backup/tools.tar -C /tang1 [root@tang2 tang1]# exit logout [root@docker ~]# docker-enter tang1 [root@tang1 ~]# cd /tang1/ [root@tang1 tang1]# ll total 4 drwxr-xr-x 2 root root 4096 Apr 3 02:07 tools]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（9）--Dockerfile]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89--Dockerfile%2F</url>
      <content type="text"><![CDATA[使用Dockerfile构建nginxDockerfile是由一行命令和语句组成的 Dockerfile构建步骤： [root@tang /]# mkdir /dockerfile/nginx -p 我们要在nginx目录上自动化创建一个nginx镜像 注意：D需要大写，当我们构建dockerfile的时候，docker默认会在我们当前目录读取一个名为Dockerfile的文件。这时候的D必须大写 [root@tang nginx]# cat Dockerfile # This Dockerfile # My Name is TangXiaoyue # Base image FROM centos # Maintainer MAINTAINE tang 1060336375@qq.com #Commands RUN rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm RUN yum install -y nginx &amp;&amp; yum clean all RUN echo &quot;daemon off;&quot; &gt;&gt;/etc/nginx/nginx.conf ADD index.html /usr/share/nginx/html/index.html EXPOSE 80 CMD [&quot;nginx&quot;] #井号代表注释 #Base image 除了注释的第一行，必须是FROM，意思就是我们需要告诉dockerfile基础镜像是什么 #Maintainer 维护信息 #Commands 命令 #ADD index.html 这个文件需要我们在当前目录下有才可以，我们配置我们可以准备好，然后使用ADD命令进行添加或修改 EXPOSE 对外端口号 CMD [“nginx”] 它要启动的命令是nginx （就算是nginx服务） 我们写好dockerfile还需要一个index.html [root@tang nginx]# echo TangXiaoyue &gt;index.html [root@tang nginx]# ll total 8 -rw-r--r-- 1 root root 364 Apr 2 20:50 Dockerfile -rw-r--r-- 1 root root 12 Apr 2 20:52 index.html 使用docker build进行构建 [root@tang ~]# docker build -t nginx_test:v1 /dockerfile/nginx/ [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx_test v1 bc69ee414a0f 17 seconds ago 280.7 MB 启动镜像 [root@tang ~]# docker run --name nginx_test -d -p 82:80 nginx_test:v1 7a02c27a0a04d34eec8f858e35848416b95572dbb1f485310caee5c185d2e426 [root@tang ~]# curl 127.0.0.1:82 TangXiaoyue Dockerfile参数解释FROM格式：FROM&lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;。 解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。 然后后面的其它指令FROM的镜像中执行。 MAINTAINER格式：MAINTAINER &lt;name&gt; 解释：指定维护者信息。 RUN格式：RUN &lt;command&gt;或 RUN[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。 解释：运行命令，命令较长使可以使用\来换行。推荐使用上面数组的格式 CMD格式： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式； CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用； CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT的默认参数； 解释： CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。 如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。 ENTRYPOINT格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;] ENTRYPOINT command param1 param2（shell中执行）。 解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。 ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。 所以生产实践中我们可以同时使用ENTRYPOINT和CMD， 例如： ENTRYPOINT [&quot;/usr/bin/rethinkdb&quot;] CMD [&quot;--help&quot;] USER格式：USER daemon 解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。 EXPOSE格式：EXPOSE&lt;port&gt; [&lt;port&gt;...] 解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。 ENV格式：ENV&lt;key&gt; &lt;value&gt; ENV &lt;key&gt;=&lt;value&gt; ... 解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定 ADD格式： ADD &lt;src&gt;... &lt;dest&gt; ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 解释： 将指定的&lt;src&gt;复制到容器文件系统中的&lt;dest&gt; 所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0 如果文件是可识别的压缩格式，则docker会帮忙解压缩 VOLUME格式：VOLUME [&quot;/data&quot;] 解释：可以将本地文件夹或者其他container的文件夹挂载到container中。 WORKDIR格式：WORKDIR/path/to/workdir 解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。 可以多次切换(相当于cd命令)， 也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如: WORKDIR /a WORKDIR b WORKDIR c RUN pwd 则最终路径为 /a/b/c。 ONBUILDONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行 ARG格式：ARG&lt;name&gt;[=&lt;default value&gt;] 解释：ARG指定了一个变量在docker build的时候使用， 可以使用--build-arg &lt;varname&gt;=&lt;value&gt;来指定参数的值，不过如果构建的时候不指定就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（8）--网络管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89--%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Docker四种网络模式第一种网络模式hosthost模式: 使用--net=host指定docker使用的网络实际上和宿主机一样,在容器内看到的网卡ip是宿主机上的ip. [root@docker ~]# docker run -itd -h node1 --name node1 --net=host centos bash 406cdb306f3c350b6f5344048ae25426f1df3f6863162c0b3a91e3dcd48eba [root@docker ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 [root@docker ~]# docker-enter node1 #进去之后修改主机名，因为主机名个宿主机一样，貌似-h也指定不了主机名 [root@node1 ~]# yum install -y net-tools [root@node1 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; 172.17.82.185 第二种网络模式containercontainer模式: 使用--net=container:container_id/container_name多个容器使用共同的网络,看到的ip是一样的. [root@docker ~]# docker run -itd -h node2 --name node2 --net=container:node1 centos bash #此处不能指定主机名创建，否则失败 /usr/bin/docker-current: Error response from daemon: Conflicting options: hostname and the network mode. See &apos;/usr/bin/docker-current run --help&apos; [root@docker ~]# docker run -itd --name node2 --net=container:node1 centos bash 0fc16c4a055cf0035c1241ba6cce6c5ad0c711f2ef13e0589c3254f19a96b271 [root@docker ~]# docker-enter node2 [root@node2 ~]# yum install -y net-tools [root@node2 ~]# ifconfig |awk -F &apos; &apos; &apos;NR==10{print$2}&apos; #和node1的ip一样，也和宿主机的ip一样（node1使用的是--net=host模式） 172.17.82.185 第三种网络模式nonenone模式: 使用--net=none, 这种模式下,不会配置任何网络 [root@docker ~]# docker run -itd -h node3 --name node3 --net=none centos c1f4bd859566f11517248718a94456066d16ad66748a2c78743881e450d4ca09 [root@docker ~]# docker-enter node3 [root@node3 ~]# ping www.baidu.com ping: www.baidu.com: Name or service not known 第四种网络模式bridgebridge模式: 使用--net=bridge.创建完容器默认为这种网络模式.类似与vmware的nat网络模式. [root@docker ~]# docker run -itd -h node4 --name node4 --net=bridge centos bash fc4f817e741f22615d0cdbab6608877d268ea15be6ba790cae5706d03871ac41 外部访问容器[root@docker ~]# docker run -itd -h node1 --name node1 centos bash 27df97f0e77e745660ee7b9c8b318c64f63e6aa632db3d3b0c44c4e0f4006124 [root@docker ~]# docker-enter node1 [root@node1 ~]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@node1 ~]# yum install -y nginx [root@docker ~]# docker commit -m &quot;nginx&quot; -a &quot;tang&quot; 27df97f0e77e nginx:v1 #此处仅容器做为镜像，主要是减少以后重复性的工作，不需要新建一个容器在部署nginx [root@docker ~]# docker run -itd -h nginx --name nginx -p 81:80 nginx:v1 bash #-p 端口映射，射到宿主机81端口上 a5dd375e829d05734a935d5f41723841568b543822a64a4ec277480f5f552e41 [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# /usr/sbin/nginx [root@nginx ~]# echo &quot;TangXiaoyue&quot; &gt; /usr/share/nginx/html/1.html [root@nginx ~]# curl 127.0.0.1/1.html TangXiaoyue [root@nginx ~]# exit logout [root@docker ~]# curl 127.0.0.1:81/1.html TangXiaoyue 容器互联1.安装mysql [root@docker ~]# docker run --privileged -itd -h node1 --name node1 centos /sbin/init fd547b535ff3af19bf36b219f542864962d60480a8d56836db30c20f079ec43f [root@docker ~]# docker-enter node1 [root@node1 ~]# yum install -y wget [root@node1 ~]# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# rpm -ivh mysql-community-release-el7-5.noarch.rpm [root@node1 ~]# yum install mysql-community-server [root@node1 ~]# systemctl start mysql.service [root@node1 ~]# mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); 2.制作mysql镜像 [root@docker ~]# docker commit -m &quot;mysql&quot; -a &quot;tang&quot; fd547b535ff3 mysql:v1 sha256:21af416e70b0302163e4aa279118afdd96a0c8590487268a3d26920caf6c5d1a [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql v1 21af416e70b0 4 seconds ago 797.3 MB [root@docker ~]# docker run --privileged -itd -h mysql --name mysql mysql:v1 /sbin/init 8d71a34516a2c05a7ea63fde5773785360d1301509d687797eec5ead62a01d55 3.以mysql、nginx镜像分别创建两个容器并端口映射 [root@docker ~]# docker run -itd -h nginx --name nginx -p 10080:80 --link mysql:db nginx:v1 bash 8aea6116f67c9760b8f4d3de08251b28af839b9e2195860ad4b24d54833c286a [root@docker ~]# docker-enter nginx Last login: Mon Apr 3 07:00:51 UTC 2017 [root@nginx ~]# yum install -y telnet [root@nginx ~]# telnet db 3306 Trying 172.18.0.3... Connected to db. Escape character is &apos;^]&apos;. CHost &apos;172.18.0.4&apos; is not allowed to connect to this MySQL serverConnection closed by foreign host. [root@nginx ~]# cat /etc/hosts 172.18.0.3 db mysql mysql 172.18.0.4 nginx 配置网桥(centos7)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker问题梳理--持续更新]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于systemctl无法启动服务的问题处理问题： 使用systemctl启动服务的时候出现以下异常： Failed to get D-Bus connection: Operation not permitted 解决： docker run --privileged -itd -h node1 --name node1 centos /sbin/init]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（5）--容器管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[查看启动的容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f8c14f16e03 centos &quot;/bin/bash&quot; 5 minutes ago Up 2 minutes tang 查看所有的容器(包括启动、停止)[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e5d7ccb9522c centos &quot;/bin/bash&quot; 15 seconds ago Exited (0) 12 seconds ago tang1 2f8c14f16e03 centos &quot;/bin/bash&quot; 3 minutes ago Up 1 seconds tang Exited:表示该容器已经退出。没有启动 创建容器(create、run)、进入容器[root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB [root@tang ~]# docker create -it --name tang_create centos /bin/bash #使用create创建容器 3b316839ea357a3fe47fcae3488d6f491882ecb8c954412c502cbd6dcf9e2478 [root@tang ~]# docker run -it --name tang_run centos /bin/bash #使用run创建容器 [root@b5dbba42703a /]# exit exit 启动停止容器[root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker start tang_run #start启动容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b5dbba42703a centos &quot;/bin/bash&quot; 4 minutes ago Up 14 seconds tang_run [root@tang ~]# docker stop tang_run #stop停止容器 tang_run [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 创建容器,指定容器名[root@tang ~]# docker run -itd -h tang_run --name tang centos /bin/bash 8afe717f82718214056a61e3881552338d5c911d272a80342edec063b5048 -d: 容器退出后不关闭容器. -h:指定主机名 删除容器/镜像[root@tang ~]# docker rm tang #删除容器 [root@tang ~]# docker rm -f tang #强制删除容器，不管是否在运行 [root@tang ~]# docker rm $(docker ps -a -q) #删除所有容器 导出容器(可迁移到其它机器)/导入容器[root@tang ~]# docker export tang &gt;/opt/tang.tar #导出容器 [root@tang ~]# docker rm tang tang [root@tang ~]# cat /opt/tang.tar |docker import - tang #恢复的只是一个镜像，需要通过镜像创建容器 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tang latest 393d449b1ed4 44 seconds ago 192.5 MB 提示：如果在之前那个容器内创建的文件，导出，导入之后容器内的文件是不变的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（4）--镜像管理]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89--%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[使用容器生成镜像[root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@tang ~]# docker run -it -h nginx --name nginx centos /bin/bash [root@nginx /]# rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm [root@nginx /]# yum install -y nginx [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e46c71171306 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 40 seconds ago nginx [root@tang ~]# docker commit -m &quot;my nginx&quot; -a &quot;tang&quot; e46c71171306 new_nginx:v1 sha256:c15ceb0a6871e3a56e3b22d67254d09b2e03a8ae909719a6dea0daaf937940ef -m: 改动信息 -a: 作者信息 e46c71171306: 这一串为容器ID new_nginx:01 新镜像的名字 [root@tang ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE new_nginx v1 c15ceb0a6871 About a minute ago 355 MB docker.io/centos latest 98d35105a391 2 weeks ago 192.5 MB docker.io/registry latest 047218491f8c 4 weeks ago 33.17 MB 基于本地模块创建镜像模版获取,直接到openva官网下载(https://openvz.org/Download/template/precreated) [root@tang opt]# wget http://download.openvz.org/template/precreated/centos-6-x86_64-minimal.tar.gz [root@tang opt]# cat centos-6-x86_64-minimal.tar.gz |docker import - centos6 sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c [root@tang opt]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos6 镜像导出/导入[root@tang opt]# docker save centos6 &gt;/opt/centos6.tar.gz #导出 [root@tang opt]# ll total 1539880 -rw-r--r-- 1 root root 565194752 Apr 2 16:19 centos6.tar.gz [root@tang opt]# docker rmi centos6 Untagged: centos6:latest Deleted: sha256:3d2aed457a111b136bdb9178d6203cb4bb0116501f7a4847088d7593c0930a8c Deleted: sha256:dbcc6b3893af5f0b45e06f2934f73f5dc34f2e9e54fc4d50a51cc47195f19089 [root@tang opt]# docker load &lt; /opt/centos6.tar.gz #导入 [root@tang opt]# docker load --input /opt/centos6.tar.gz #导入 #以上两种导入方法都可以 [root@tang opt]# docker tag centos6 centos6_x86 #改名 将镜像上传到dockerhub官网需要提前注册dockerhub账号 1. docker hub 帐号在本地验证登陆: [root@tang opt]# docker login Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one. Username: tangxiaoyue Password: Login Succeeded 2. docker push 镜像到docker hub 的仓库 docker push &lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt; [root@tang ~]# docker tag centos tangxiaoyue/centos_tang:latest [root@tang ~]# docker push tangxiaoyue/centos_tang The push refers to a repository [docker.io/tangxiaoyue/centos_tang] 9b198ff9ff5b: Mounted from library/centos latest: digest: sha256:be5b4a93f116a57ab3fd454ada72421eac892a3a4925627ac9a44f65fcd69cf8 size: 529]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（3）--容器登入]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%20%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89--%E5%AE%B9%E5%99%A8%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[docker-enter登入容器 强烈推荐使用此种方法：简单、方便 下载.bashrc_docker，并将内容放到.bashrc中。 这个文件中定义了很多方便使用Docker的命令，比如docker-pid可以获取某个容器的 PID； 而 docker-enter 可以进入容器或直接在容器内执行命令 [root@tang ~]# wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker [root@tang ~]# echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc [root@tang ~]# docker- docker-containerd docker-ctr-current docker-pid docker-containerd-current docker-current docker-storage-setup docker-containerd-shim docker-enter docker-containerd-shim-current docker-ip [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 24 minutes ago Up 23 minutes tang [root@tang ~]# docker-pid tang 19271 [root@tang ~]# nsenter --target 19271 --mount --uts --ipc --net --pid #此种方法进入容器以下会讲到 [root@test /]# exit logout [root@tang ~]# docker-ip tang 172.18.0.2 直接使用docker-enter命令进入容器，非常方便！ [root@tang ~]# docker-enter tang Last login: Sun Apr 2 06:38:47 UTC 2017 [root@test ~]# exit logout [root@tang ~]# docker ps #退出登陆窗口后，容器还在 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 26 minutes ago Up 9 seconds tang 注意：以在容器的上下文中运行任意命令！即在宿主机上执行容器里的命令 [root@tang ~]# docker-enter tang uptime 07:06:28 up 1 day, 22:44, 0 users, load average: 0.00, 0.01, 0.05 注意：在宿主机上使用docker-enter命令执行容器中的命令时，最好后面加上--符号，这样容器里的所有存在的命令都可以正常执行。 [root@tang ~]# docker-enter tang -- uptime 07:06:59 up 1 day, 22:45, 0 users, load average: 0.00, 0.01, 0.05 [root@tang ~]# docker-enter tang -- df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/docker-253:1-2024335-661487685eb1f6a356157463d60db20caa2c1fb3ac273de680c367e3b12dabab 10G 238M 9.8G 3% / tmpfs 920M 0 920M 0% /dev tmpfs 920M 0 920M 0% /sys/fs/cgroup /dev/vda1 99G 4.7G 89G 5% /etc/hosts shm 64M 0 64M 0% /dev/shm [root@tang ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@tang ~]# docker-enter tang -- cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) nsenter登入容器使用外部工具nsenter登陆容器，该工具和docker exec命令的效果差不多。 使用nsenter或dockerexec，都可以在容器的上下文（严格地说，是命名空间）中运行任意命令！ ==nsenter安装： [root@tang ~]# yum install util-linux -y ==nsenter使用： [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 50 minutes ago Up 24 minutes tang [root@tang ~]# docker inspect -f &quot;{{ .State.Pid }}&quot; tang 19271 [root@tang ~]# nsenter -t 19271 -m -u -i -n -p 解释nsenter指令中进程id之后的参数的含义： –mount参数是进去到mount namespace中 –uts参数是进入到uts namespace中 –ipc参数是进入到System V IPC namaspace中 –net参数是进入到network namespace中 –pid参数是进入到pid namespace中 –user参数是进入到user namespace中 [root@tang ~]# nsenter --help Usage: nsenter [options] &lt;program&gt; [&lt;argument&gt;...] Run a program with namespaces of other processes. Options: -t, --target &lt;pid&gt; target process to get namespaces from -m, --mount[=&lt;file&gt;] enter mount namespace -u, --uts[=&lt;file&gt;] enter UTS namespace (hostname etc) -i, --ipc[=&lt;file&gt;] enter System V IPC namespace -n, --net[=&lt;file&gt;] enter network namespace -p, --pid[=&lt;file&gt;] enter pid namespace -U, --user[=&lt;file&gt;] enter user namespace -S, --setuid &lt;uid&gt; set uid in entered namespace -G, --setgid &lt;gid&gt; set gid in entered namespace --preserve-credentials do not touch uids or gids -r, --root[=&lt;dir&gt;] set the root directory -w, --wd[=&lt;dir&gt;] set the working directory -F, --no-fork do not fork before exec ing &lt;program&gt; -Z, --follow-context set SELinux context according to --target PID -h, --help display this help and exit -V, --version output version information and exit 我们进入容器中查看进程 以下是以nsenter启动的进程 [root@test /]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 11768 1684 ? Ss+ 07:03 0:00 /bin/bash root 77 0.0 0.1 15200 1988 ? S 07:31 0:00 -bash root 90 0.0 0.0 50872 1816 ? R+ 07:31 0:00 ps aux /bin/bash是我们运行容器产生的进程 -bash 是我们使用nsenter产生的，这样如果我们退出容器，容器就不会退出，因为-bash还在运行 [root@test /]# exit logout [root@tang ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; 55 minutes ago Up 29 minutes tang 因为每次进入容器都需要输入那两条命令，所以我们可以写一个脚本来获取。 ==脚本内容如下： [root@tang opt]# cat docker_in.sh #!/bin/bash # Use nsenter to access docker docker_in(){ NAME_ID=$1 PID=$(docker inspect -f &quot;{{ .State.Pid }}&quot; $NAME_ID) nsenter -t $PID -m -u -i -n -p } docker_in $1 [root@tang opt]# chmod +x docker_in.sh [root@tang opt]# ./docker_in.sh tang [root@test /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 91 0 0 07:34 ? 00:00:00 -bash root 104 91 0 07:34 ? 00:00:00 ps -ef [root@test /]# exit logout [root@tang opt]# docker exec tang ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 07:03 ? 00:00:00 /bin/bash root 105 0 0 07:35 ? 00:00:00 ps -ef 我们还可以使用exec进入docker容器中 [root@tang opt]# docker exec -it tang /bin/bash start -ai登入容器对于一个已关闭的容器的登陆，可以使用&quot;docker start -ai container&quot;登陆。这种其实就是先启动容器，然后再进入容器内。 [root@tang ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Exited (0) 53 seconds ago tang [root@tang ~]# docker start -ai tang #-a -i 都可以 [root@test /]# exit exit [root@tang ~]# docker start -i tang [root@tang ~]# docker start -a tang docker exec登入容器使用自带命令docker exec登陆容器 命令格式：docker exec -ti container_id /bin/bash [root@tang ~]# docker ps #前提是容器已经启动 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 2 minutes tang [root@tang ~]# docker exec -it tang /bin/bash [root@test /]# exit docker attach登入容器使用自带命令docker attach登陆容器。 命令格式：docker attach container_id [root@tang ~]# docker ps #前提容器已经启动了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e657e9214a57 centos &quot;/bin/bash&quot; About an hour ago Up 5 minutes tang [root@tang ~]# docker attach tang [root@test /]# exit ssh登入容器使用ssh登陆容器。这种方法需要在容器中启动sshd，存在开销和攻击面增大的问题。同时也违反了Docker所倡导的一个容器一个进程的原则 ssh登入会专门写一篇文章介绍。这里就不叙述了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XtraBackup主从复制及备份]]></title>
      <url>%2F2017%2F03%2F11%2FXtraBackup%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A4%87%E4%BB%BD%2F</url>
      <content type="text"><![CDATA[XtraBackup备份1、yum安装mysql（以centos7为例） ###主从操作一致 #查看操作系统版本： [root@node2 ~]# cat /etc/redhat-release CentOS Linux release 7.0.1406 (Core) #关闭防火墙和seLinux [root@node2 ~]# systemctl stop firewalld [root@node2 ~]# sed -i &quot;s#SELINUX=enforcing#SELINUX=disabled#g&quot; /etc/selinux/config [root@node2 ~]# setenforce 0 #yum安装mysql wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server systemctl start mysql.service mysql -uroot &gt;set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); ###配置主从 主： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=1 从： vim /etc/my.cnf [mysqld] log-bin = mysql-bin server-id=2 2、安装xtrabackup备份软件（主从进行安装） wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.3.4/binary/redhat/6/x86_64/percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y epel-release yum localinstall percona-xtrabackup-2.3.4-1.el6.x86_64.rpm yum install -y perl-Time-HiRes #查看版本 &gt;select version(); #查看前默认的存储引擎 &gt;show variables like &apos;%storage_engine%&apos;; 3、导入数据（为了模拟比较真实可以往主库导入数据）（主库操作） #导入bubi_api数据库 [root@node2 opt]# mysql -uroot -ppassword &lt; bubi_api.sql # 查看数据大小 &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed &gt; select concat(round(sum(data_length/1024/1024),2),&apos;MB&apos;) as data from tables; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.04 sec) 4、数据库备份（主操作） ###备份 [root@node2 opt]# mkdir /extrabackup [root@node2 opt]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=bubi --parallel=4 /mnt/resource/extrabackup ###出现completed OK! 表示备份成功 语法解释：–user=数据库用户 –password=数据库密码 –socket=指定socket –default-file=指定配置文件 - 最后面是存放位 ###保持事务一致（主操作） [root@node2 2017-02-17_14-45-11]# innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --parallel=4 --apply-log /extrabackup/2017-02-17_14-45-11/ ###出现completed OK!表示事务保持了一致，可以用于恢复 二、mysql主从同步操作 1、传输数据、将/extrabackup/2017-02-17_14-45-11/拷贝到从库 [root@node2 extrabackup]# scp -r 2017-02-17_14-45-11 root@192.168.1.13:/extrabackup/ 2、从库恢复数据 [root@node3 extrabackup]# ll 总用量 0 drwx------. 4 root root 47 2月 17 14:47 2017-02-17_14-45-11 #停止mysql [root@node3 extrabackup]# systemctl stop mysql #清空mysql data目录 [root@node3 extrabackup]# cd /var/lib/mysql [root@node3 mysql]# mv * /opt/mysqlbak/ #数据恢复 innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 --copy-back /extrabackup/2017-02-17_11-49-35/ ###出现completed OK! 表示恢复成功 #还原权限 [root@node3 mysql]# cd .. [root@node3 lib]# chown mysql:mysql mysql -R #重启mysql并查看数据的大小 [root@node3 lib]# systemctl start mysql [root@node3 lib]# ps -ef | grep mysql mysql 8173 1 0 14:59 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe --basedir=/usr mysql 8338 8173 3 14:59 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sock root 8364 5840 0 15:00 pts/0 00:00:00 grep --color=auto mysql &gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; +----------+ | data | +----------+ | 194.94MB | +----------+ 1 row in set (0.26 sec) ###数据主从大小都一样 3、mysql主从同步操作 ###主库授权 &gt; GRANT REPLICATION SLAVE ON *.* TO &apos;rep&apos;@&apos;192.168.1.13&apos; IDENTIFIED BY &apos;123456&apos;; &gt;FLUSH PRIVILEGES; ###从库开启同步 [root@node3 mysql]# cat /extrabackup/2017-02-17_14-45-11/xtrabackup_binlog_info mysql-bin.000001 171510867 CHANGE MASTER TO MASTER_HOST=&apos;10.25.159.23&apos;, MASTER_USER=&apos;rep&apos;, MASTER_PASSWORD=&apos;db0226&apos;, MASTER_PORT=3306, MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;, MASTER_LOG_POS=982559769; ####在还没同步之前我们可以在主库继续增加入一个库，验证不锁表是否可以同步 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) #####开启主从同步 &gt;flush logs; &gt; start slave; ###从库操作 &gt; show slave status\G Slave_IO_Running: Yes Slave_SQL_Running: Yes ##查看从库数据 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bubi_api | | mysql | | performance_schema | | tang | +--------------------+ 5 rows in set (0.00 sec) 注意： 1、当从库停掉了（宕机还没测试）。主库继续写入数据，从库开启时，会自动同步 ##########mysql命令 #查看binlog是否开启 &gt;show binary logs; #查看serverid &gt;show variables like &apos;server_id&apos;; #查看binlog模式 &gt;show variables like &apos;%log%&apos;; &gt;/dev/null 2&gt;&amp;1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 基础（2）--命令]]></title>
      <url>%2F2017%2F03%2F11%2FDocker%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89--%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[安装下载yum install -y docker #下载 systemctl start docker #启动 systemctl enable docker #自启动 镜像操作docker search images #搜索镜像 docker pull images #下载镜像 docker images #查看镜像 docker tag centos6 centos6_x86 #镜像改名 docker save image&gt;/opt/images.tar.gz #导出镜像 docker load&lt;/opt/images.tar.gz #导入镜像 docker load --input /opt/images.tar.gz #导入镜像 docker rmi images_id #删除镜像 docker rmi $(docker images -q) #删除所有镜像 容器操作docker ps -a #查看容器 docker run centos /bin/echo &quot;hehe&quot; #首次创建一个容器 docekr run -h tang --name tang -t -i centos /bin/bah #创建一个以tang为名的容器； --name：指定容器名 -t：分配一个tty终端 -i：容器的标准输出保持打开状态 -h:指定主机名 docker create -it --name centos1 centos #使用create创建容器 docekr stop ID（name） #停止容器 docker start ID（name） #启动容器 docker attach ID（name） #进入容器 docker exec -it ID(name) /bin/bash docker rm ID（name） #删除容器 -f：强制删除容器，包括在运行的 #exec和attach总结: attach登陆容器后,退出时容器会关闭. 推荐使用exec进入容器 docker rm $(docker ps -a -q) #删除所有容器 映射docker run --name nginx -d -P nginx #随机映射 docker run --name nginx -d -p 81:80 nginx #指定映射 docker run -it --name nginx -p 80:80 nginx /bin/bash #指定映射 日志docker logs ID（name） #查看日志 数据管理docker run -it --name tang -v /data centos #默认挂载目录 docekr inspect ID(name) #查看容器信息 ==查看mounts模块 docekr run -it --name tang -v /data:/data centos #指定挂载目录 docker run -it --name tang -v /data:/data:rw centos #指定权限挂载 ==rw：读写 docker run -it --name tang -v /data:/data:ro centos #指定权限挂载 ==ro：只读 docker run -it --name tang ~/.bash_history:/.bash_history centos #记录历史记录 数据卷容器docker run -d --name nfs -v /data:/data centos #启动nfs容器，挂在一个卷， -d：直接在后台执行 docker run -it --name test1 --volumes-from nfs centos #启动test1容器，挂载到nfs的数据卷容器上 docker run -it --name test2 --volumes-from nfs centos #启动test2容器，挂载到nfs的数据卷容器上 #test1和test2的/data数据可以共享 手动制作镜像docker run -it --name mynginx centos #基础centos进行创建容器mynginx 在mynginx容器内安装nginxrpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm yum install -y nginx docker commit -m &quot;my nginx&quot; f9c7dfb6f552 tang/mynginx:v1 #提交镜像， ==同时打一个标签叫mynginx:v1 ==tang相当于你向github上提交的用户名 docker run -it --anme nginxv1 tang/mynginx:v1 #基于镜像tang/mynginx:v1创建容器nginxv1 ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo常用命令]]></title>
      <url>%2F2017%2F03%2F11%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Hexo部署步骤 npm install npm install hexo-deployer-git --save hexo new &quot;新页面&quot; hexo clean hexo generate hexo deploy Hexo常用命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令的简写为： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五分钟商学院--大纲]]></title>
      <url>%2F2016%2F09%2F25%2F%E4%BA%94%E5%88%86%E9%92%9F%E5%95%86%E5%AD%A6%E9%99%A2--%E5%A4%A7%E7%BA%B2%2F</url>
      <content type="text"><![CDATA[商业四大体系合体。 1）商业，你与企业外部的关系；2）管理，你与企业内部的关系；3）个人，你与自己的关系；4）以及提升前三者的：工具。 商业篇消费心理学1.心理账户2.沉没成本3.比例偏见4.损失规避5.价格锚点 商业世界五大基础逻辑6.流量之河7.倍率之刀8.价量之秤9.风险之眼10.规则之缝 互联网世界五大基本定律11.信息对称12.平台经济13.边际成本14.长尾理论15.免费理论 行为经济学16.结果偏见17.适应性偏见18.鸡蛋理论19.概率偏见20.凡勃伦效应 微观经济学21.供需理论22.边际效用23.机会成本24.代理两难25.科斯定理 宏观经济学26.节约悖论27.张维迎林毅夫之争28.人口抚养比29.经济泡沫30.福利经济 金融法律31.风险投资32.公司的形态：有限责任，合伙企业，个人独资33.期权（员工激励方案）34.庞氏骗局35.互联网金融 市场营销 Product36.产品定位37.自我认知38.极致单品39.三驾马车40.最小可用品 市场营销 Price41.渗透定价法42.组合定价法43.撇脂定价法44.价格歧视45.客户自定价 市场营销 Promotion46.定位营销47.饥饿营销48.死亡之井49.危机公关50.独特的销售主张-USP 市场营销 Place51.深度分销52.直接销售53.虚实结合54.社区商务55.反向定制 市场营销 互联网营销56.社群经济57.口碑经济（POE理论）58.粉丝经济59.引爆点60.红利理论 所有现象背后都有商业逻辑61.运动对赌62.雇佣客户63.服务行业美女越多，经济越不景气64.狩猎式 vs 农耕式65.稳定平衡态 vs 不稳定平衡态 管理篇管理选人66.上下车法则67.奥格尔维定律68.首因效应/光环效应69.特雷默定律70.重视面试被拒的人 管理育人71.蘑菇定律72.师傅制73.情境领导II74.鲶鱼效应75.贝尼斯定理 管理用人76.不值得定律77.懒蚂蚁效应78.热炉法则79.拜伦法则80.波特定律 管理留人81.酒与污水定律82.格雷欣法则（劣币驱逐良币）83.雷尼尔效应84.南风法则85.离职面试 管理就是激励需求理论86.马斯洛人类需求五层次理论-生理87.马斯洛人类需求五层次理论-安全88.马斯洛人类需求五层次理论-归属89.马斯洛人类需求五层次理论-尊重90.马斯洛人类需求五层次理论-实现 管理就是激励其他理论91.卡诺满意度模型92.赫兹伯格的双因素激励理论93.亚佛斯德原则（期望理论）94.马蝇效应95.波什定律 从员工到经理96.古狄逊定理97.吉格勒定理98.刺猬法则99.目标置换效应100.篮球架子原理 管理1101.崔西定律102.蓝柏格定理103.阿什定律104.彼得斯定律105.超限效应 管理2106.奥卡姆剃刀定律107.法约尔原则（责权利心法）108.例外原则109.洛克忠告110.海恩法则 管理3111.波特法则112.卡贝定律113.飞轮效应114.墨菲定律115.克里夫兰法则 团队合作116.球队，交响乐队，军队117.木桶定律118.多样性（异性效应）119.苛希纳定律120.蚁群效应 项目管理121.作战指挥室122.关键路径123.范围、时间、资源的金三角124.风险管理（已知的未知风险）125.权利来源：专业 管理常见病126.破窗效应127.旁观者效应128.帕金森定律129.彼得原理130.手表定律 个人篇高效能人士的七种习惯131.范式转变132.情感账户133.积极主动134.以终为始135.要事第一 高效能人士的七种习惯136.双赢思维137.知彼解己138.统合综效139.不断更新140.找到心声 时间管理141.时间成本142.GTD143.猴子理论144.三八理论145.番茄钟 职业素养146.如何打招呼147.如何吃西餐148.如何和老板一起坐车149.如何搭配衣服150.邮件礼仪 学习能力151.幸存者偏见152.库博经验学习圈153.知识、技能、态度154.学习小组（私人董事会）155.如何最快速的学习 思考能力156.六顶思考帽157.批判性思维/辩证思维158.系统思维-关联的、整体的、动态的159.正向思维160.逆向思维 逻辑思维161.偷换概念-同一律162.自相矛盾-矛盾律163.模棱两可-排中律164.三段论165.归纳法与黑天鹅事件 谈判能力166.吉普赛陷阱167.定位调整偏见168.有限的权利 &amp; 不露面的人169.战略延迟 &amp; 最终期限170.吃惊 &amp; 撤退 情感能力171.元能力：同理心172.元能力：自我认知（卢维斯定理）173.元能力：自我控制174.元能力：自我激励175.元能力：人际关系处理 演讲能力176.导游心法177.注意力法则178.空中加油179.案例和幽默感180.打透 沟通能力181.快乐痛苦四原则182.亨利法则183.踢猫效应184.电梯测验185.如何问出好问题 创新能力186.创新者的窘境187.人无我有，人有我优，人优我廉……188.达维多定律189.路径依赖190.比伦定律 领导能力191.远（后喻文明）192.小（科斯定理）193.变（企业生命周期）194.快（快鱼吃慢鱼）195.专（网状激活系统） 战略篇战略工具196.麦肯锡·MECE法197.波特·五力模型198.波士顿矩阵199.金字塔原理200.通用电器矩阵 战略工具201.正态分布理论202.逻辑树/决策树203.平衡计分表204.SWOT模型205.麦肯锡·七步成诗法 博弈工具206.纳什均衡207.囚徒困境208.贝叶斯均衡209.智猪博弈210.公地悲剧 博弈工具211.你分我拿212.拍卖逻辑213.零和游戏原理214.拍卖美元215.用餐者困境 决策工具216.儒佛尔定律217.吉德林法则218.布利丹效应219.羊群效应220.麦穗哲理 创新工具221.减法创新222.除法创新223.乘法创新224.任务统筹策略225.属性依存策略 管理工具226.OKR227.MBTI人格理论（自我管理）228.SMART原则（目标管理）229.PDCA循环规则（项目管理）230.5W2H法（目标管理） 思考工具231.头脑风暴法232.思考工具：白板233.思维导图234.5WHY分析法235.复盘 沟通工具236.有效的1：1237.罗伯特议事规则238.白板墙、低隔板、下午茶和即时贴239.拉波波特评论规则240.结构沟通法 财务工具241.财务分析中的五力分析法242.零基预算？243.本福特定律244.独立P&amp;L245.计算企业价值 营销工具246.直播营销247.Focus Group248.STP249.4C250.4P 未来已来256.零边际成本社会257.奇点临近258.比特币259.基因科技260.人工智能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysqladmin命令总结]]></title>
      <url>%2F2016%2F03%2F11%2FMysqladmin%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[mysqladmin 工具的使用格式： mysqladmin [option] command [command option] command ...... 参数选项： -c number 自动运行次数统计，必须和 -i 一起使用 -i number 间隔多长时间重复执行 0）每个两秒查看一次服务器的状态，总共重复5次。 [root@test-huanqiu ~]# mysqladmin -uroot -p -i 2 -c 5 status 1）查看服务器的状况：status [root@test-huanqiu ~]# mysqladmin -uroot -p status 2）修改root 密码： [root@test-huanqiu ~]# mysqladmin -u root -p原密码 password &apos;newpassword&apos; 3）检查mysqlserver是否可用： [root@test-huanqiu ~]# mysqladmin -uroot -p ping 4）查询服务器的版本 [root@test-huanqiu ~]# mysqladmin -uroot -p version 5）查看服务器状态的当前值： [root@test-huanqiu ~]# mysqladmin -uroot -p extended-status 6）查询服务器系统变量值： [root@test-huanqiu ~]# mysqladmin -uroot -p variables 7）显示服务器所有运行的进程： [root@test-huanqiu ~]# mysqladmin -uroot -p processlist [root@test-huanqiu ~]# mysqladmin -uroot -p-i 1 processlist 8）创建数据库 [root@test-huanqiu ~]# mysqladmin -uroot -p create daba-test//每秒刷新一次 9）显示服务器上的所有数据库 [root@test-huanqiu ~]# mysqlshow -uroot -p 10）显示数据库daba-test下有些什么表： [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test 11）统计daba-test 下数据库表列的汇总 [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v 12）统计daba-test 下数据库表的列数和行数 [root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v -v 13）删除数据库 daba-test [root@test-huanqiu ~]# mysqladmin -uroot -p drop daba-test 14）重载权限信息 [root@test-huanqiu ~]# mysqladmin -uroot -p reload 15）刷新所有表缓存，并关闭和打开log [root@test-huanqiu ~]# mysqladmin -uroot -p refresh 16）使用安全模式关闭数据库 [root@test-huanqiu ~]# mysqladmin -uroot -p shutdown 17）刷新命令mysqladmin flush commands [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-hosts [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-logs [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-privileges [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-status [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-tables [root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-threads 18）mysqladmin 执行kill 进程： [root@test-huanqiu ~]# mysqladmin -uroot -p processlist [root@test-huanqiu ~]# mysqladmin -uroot -p kill idnum 19）停止和启动MySQL replication on a slave server [root@test-huanqiu ~]# mysqladmin -u root -p stop-slave [root@test-huanqiu ~]# mysqladmin -u root -p start-slave 20）同时执行多个命令 [root@test-huanqiu ~]# mysqladmin -u root -p process status version]]></content>
    </entry>

    
  
  
</search>
